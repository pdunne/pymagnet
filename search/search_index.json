{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pymagnet User friendly magnetic field calculations in Python Getting Started Installing pymagnet can be done using python -m pip install pymagnet or conda install -c pdunne pymagnet Examples Additional examples are in the examples directory of the repository . 3D calculation and render using plotly A cylinder of radius 5 mm, length 20 mm, is instantiated and rotated by 30 degrees about the x-axis by 330 degrees. Two example plots are shown, using surface slices along the three principal axes, and a volume plot. import pymagnet as pm pm . reset_magnets () # clear magnet registry center = ( 0 , 0 , 0 ) radius = 5 length = 20 # Create a magnet instance m_cyl = pm . magnets . Cylinder ( radius = radius , length = length , Jr = 1.0 , center = center , alpha = 0 , # rotation of magnet w.r.t. z-axis beta = - 30 , # rotation of magnet w.r.t. y-axis gamma = 0 , # rotation of magnet w.r.t. x-axis ) # Calculate and display 3 slices # Cache is a dictionary containing all the calculated values cache = pm . plots . surface_slice3 ( cmin = 0.0 , # minimum field value cmax = 0.3 , # maximum field value opacity = 1.0 , # opacity of slices num_arrows = 10 , # number of arrows in vector field cone_opacity = 0.9 , # opacity of arrows ) # Calculate and display volume plot # volume_cache is a dictionary containing all the calculated values volume_cache = pm . plots . volume_plot ( cmin = 0.0 , # minimum field value cmax = 0.3 , # maximum field value opacity = 0.1 , # needs to be small for visibility num_levels = 6 , # number of color levels to be plotted # number of points in each direction, total number is num_points^3 num_points = 50 , ) 3D surface slice plot 3D volume plot 2D calculation and render using matplotlib 2D contour plot and streamplot of a long bipolar rod Two square magnets of 20x20 mm are added, and a contour plot with a vector field are drawn. import pymagnet as pm pm . reset_magnets () # clear magnet registry cmap = 'viridis' # set the colormap radius = 10 center = ( 0 , 0 ) # Create magnet _ = pm . magnets . Circle ( radius = radius , Jr = 1.0 , center = center , alpha = 45 ) # Prepare 100x100 grid of x,y coordinates to calculate the field x , y = pm . grid2D ( 2 * radius , 2 * radius ) # Calculate the magnetic field due to all magnets in the registry B = pm . B_calc_2D ( x , y ) # Plot the result, vector_plot = True toggles on the vector field plot pm . plots . plot_2D_contour ( x , y , B , cmax = 0.5 , num_levels = 6 , cmap = cmap , vector_plot = True , vector_arrows = 11 ) # Plot the result as a streamplot pm . plots . plot_2D_contour ( x , y , B , cmin = - 0.3 , cmax = 0.3 , cmap = 'coolwarm' , plot_type = \"streamplot\" , stream_color = 'vertical' , # 'vertical', 'horizontal', 'normal': # corresponds to coloring by B.x, B.y, B.n ) 2D contour plot import pymagnet as pm pm . reset_magnets () # clear magnet registry cmap = 'viridis' # set the colormap width = 20 height = 20 # Set the space between magnets to be the width of one half_gap = width / 2 # Center of first magnet center = ( - width / 2 - half_gap , 0 ) # Create first magnet _ = pm . magnets . Rectangle ( width = width , height = height , Jr = 1.0 , center = center , theta = 0.0 ) # Centre of second magnet center = ( width / 2 + half_gap , 0 ) # Create second magnet _ = pm . magnets . Rectangle ( width = width , height = height , Jr = 1.0 , center = center , theta = 90.0 ) # Prepare 100x100 grid of x,y coordinates to calculate the field x , y = pm . grid2D ( 2 * width , 2 * height ) # Calculate the magnetic field due to all magnets in the registry B = pm . B_calc_2D ( x , y ) # Plot the result, vector_plot = True toggles on the vector field plot pm . plots . plot_2D_contour ( x , y , B , cmin = 0.0 , # minimum field value cmax = 0.5 , # maximum field value vector_plot = True , # plot the vector field cmap = cmap , # set the colormap ) Calculating Magnetic Fields and Forces Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 . Features This code uses analytical expressions to calculate the magnetic field due to simple magnets. These include: 3D objects: cubes, cuboids, cylinders, spheres 2D: rectangles, squares There are helper functions to plot the data as either line or countour plots, but the underlying data is also accessible. Prerequisites Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy matplotlib numba plotly Todo Complete documentation Warning For spheres, rotate them using alpha, beta, gamma, rather than the magnetisation angles theta and phi, as phi rotations are not implemented. Similarly, for circles, rotate them using alpha, not phi. Licensing Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Home"},{"location":"#pymagnet","text":"User friendly magnetic field calculations in Python","title":"Pymagnet"},{"location":"#getting-started","text":"Installing pymagnet can be done using python -m pip install pymagnet or conda install -c pdunne pymagnet","title":"Getting Started"},{"location":"#examples","text":"Additional examples are in the examples directory of the repository .","title":"Examples"},{"location":"#3d-calculation-and-render-using-plotly","text":"A cylinder of radius 5 mm, length 20 mm, is instantiated and rotated by 30 degrees about the x-axis by 330 degrees. Two example plots are shown, using surface slices along the three principal axes, and a volume plot. import pymagnet as pm pm . reset_magnets () # clear magnet registry center = ( 0 , 0 , 0 ) radius = 5 length = 20 # Create a magnet instance m_cyl = pm . magnets . Cylinder ( radius = radius , length = length , Jr = 1.0 , center = center , alpha = 0 , # rotation of magnet w.r.t. z-axis beta = - 30 , # rotation of magnet w.r.t. y-axis gamma = 0 , # rotation of magnet w.r.t. x-axis ) # Calculate and display 3 slices # Cache is a dictionary containing all the calculated values cache = pm . plots . surface_slice3 ( cmin = 0.0 , # minimum field value cmax = 0.3 , # maximum field value opacity = 1.0 , # opacity of slices num_arrows = 10 , # number of arrows in vector field cone_opacity = 0.9 , # opacity of arrows ) # Calculate and display volume plot # volume_cache is a dictionary containing all the calculated values volume_cache = pm . plots . volume_plot ( cmin = 0.0 , # minimum field value cmax = 0.3 , # maximum field value opacity = 0.1 , # needs to be small for visibility num_levels = 6 , # number of color levels to be plotted # number of points in each direction, total number is num_points^3 num_points = 50 , ) 3D surface slice plot 3D volume plot","title":"3D calculation and render using plotly"},{"location":"#2d-calculation-and-render-using-matplotlib","text":"2D contour plot and streamplot of a long bipolar rod Two square magnets of 20x20 mm are added, and a contour plot with a vector field are drawn. import pymagnet as pm pm . reset_magnets () # clear magnet registry cmap = 'viridis' # set the colormap radius = 10 center = ( 0 , 0 ) # Create magnet _ = pm . magnets . Circle ( radius = radius , Jr = 1.0 , center = center , alpha = 45 ) # Prepare 100x100 grid of x,y coordinates to calculate the field x , y = pm . grid2D ( 2 * radius , 2 * radius ) # Calculate the magnetic field due to all magnets in the registry B = pm . B_calc_2D ( x , y ) # Plot the result, vector_plot = True toggles on the vector field plot pm . plots . plot_2D_contour ( x , y , B , cmax = 0.5 , num_levels = 6 , cmap = cmap , vector_plot = True , vector_arrows = 11 ) # Plot the result as a streamplot pm . plots . plot_2D_contour ( x , y , B , cmin = - 0.3 , cmax = 0.3 , cmap = 'coolwarm' , plot_type = \"streamplot\" , stream_color = 'vertical' , # 'vertical', 'horizontal', 'normal': # corresponds to coloring by B.x, B.y, B.n ) 2D contour plot import pymagnet as pm pm . reset_magnets () # clear magnet registry cmap = 'viridis' # set the colormap width = 20 height = 20 # Set the space between magnets to be the width of one half_gap = width / 2 # Center of first magnet center = ( - width / 2 - half_gap , 0 ) # Create first magnet _ = pm . magnets . Rectangle ( width = width , height = height , Jr = 1.0 , center = center , theta = 0.0 ) # Centre of second magnet center = ( width / 2 + half_gap , 0 ) # Create second magnet _ = pm . magnets . Rectangle ( width = width , height = height , Jr = 1.0 , center = center , theta = 90.0 ) # Prepare 100x100 grid of x,y coordinates to calculate the field x , y = pm . grid2D ( 2 * width , 2 * height ) # Calculate the magnetic field due to all magnets in the registry B = pm . B_calc_2D ( x , y ) # Plot the result, vector_plot = True toggles on the vector field plot pm . plots . plot_2D_contour ( x , y , B , cmin = 0.0 , # minimum field value cmax = 0.5 , # maximum field value vector_plot = True , # plot the vector field cmap = cmap , # set the colormap )","title":"2D calculation and render using matplotlib"},{"location":"#calculating-magnetic-fields-and-forces","text":"Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 .","title":"Calculating Magnetic Fields and Forces"},{"location":"#features","text":"This code uses analytical expressions to calculate the magnetic field due to simple magnets. These include: 3D objects: cubes, cuboids, cylinders, spheres 2D: rectangles, squares There are helper functions to plot the data as either line or countour plots, but the underlying data is also accessible.","title":"Features"},{"location":"#prerequisites","text":"Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy matplotlib numba plotly Todo Complete documentation Warning For spheres, rotate them using alpha, beta, gamma, rather than the magnetisation angles theta and phi, as phi rotations are not implemented. Similarly, for circles, rotate them using alpha, not phi.","title":"Prerequisites"},{"location":"#licensing","text":"Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.","title":"Licensing"},{"location":"#contribution","text":"Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Contribution"},{"location":"equations/","text":"Magnetic Field Equations Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. Many of the relations here come from 2 , those that do not are noted below, or derived. 1D Calculations Cylinder The magnetic field directly above the centre of a cylinder is: Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\] Cuboid While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\] 2D Calculations For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\] Rectangles 2D Magnet Rectangle The magnetic field due to rectangle and magnetised in \\(x\\) is: TODO: $$ B_x = \\frac{\\mu_0 M_r}{2\\pi} $$ \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\] and if magnetised in \\(y\\) is: \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\] Biaxial Rods (Circle) 2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\] Line Elements The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\] Composite Polygons An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet. 3D Calculations The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) . Prisms/Cuboids For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis. Cylinders/Solenoids Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 . Bulirsch's complete elliptic integral See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s) Example Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 ) Spheres Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\] Composite Objects Polyhedra For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements: \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ b + \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 } - z }{ \\sqrt{(a-x)^2 + y^2 + z^2} - z}\\right)\\right.\\\\ & + \\left. \\frac{b}{c} \\ln \\left( \\frac{r - s }{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{\\sqrt{(a-x)^2 + y^2 + z^2} + a}\\right)\\right.\\\\ & + \\left. \\frac{a}{c} \\ln \\left( \\frac{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t}{r - s } \\right) \\right] \\end{align} \\] where \\(r = \\sqrt{x^2 + y^2 + z^2},\\, c = \\sqrt{a^2 + b^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{(x-a) + z + \\sqrt{(x-a)^2 + y^2 + z^2}}{y}\\right)\\right.\\\\ & - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha\\sqrt{B^2 - A^2 - C^2}} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{(\\alpha+\\beta)^2}{\\gamma^2}} + \\frac{\\alpha + \\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{\\beta^2}{\\gamma^2}} + \\frac{\\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{1 + \\frac{b^2}{a^2}}, \\, \\gamma = \\sqrt{\\frac{r^2}{1 + \\frac{b^2}{a^2}} - \\beta^2}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\sqrt{1 + \\frac{b^2}{a^2}},\\, C = z + \\beta\\frac{b}{a}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9","title":"Magnets"},{"location":"equations/#magnetic-field-equations","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. Many of the relations here come from 2 , those that do not are noted below, or derived.","title":"Magnetic Field Equations"},{"location":"equations/#1d-calculations","text":"","title":"1D Calculations"},{"location":"equations/#cylinder","text":"The magnetic field directly above the centre of a cylinder is: Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\]","title":"Cylinder"},{"location":"equations/#cuboid","text":"While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\]","title":"Cuboid"},{"location":"equations/#2d-calculations","text":"For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\]","title":"2D Calculations"},{"location":"equations/#rectangles","text":"2D Magnet Rectangle The magnetic field due to rectangle and magnetised in \\(x\\) is: TODO: $$ B_x = \\frac{\\mu_0 M_r}{2\\pi} $$ \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\] and if magnetised in \\(y\\) is: \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\]","title":"Rectangles"},{"location":"equations/#biaxial-rods-circle","text":"2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\]","title":"Biaxial Rods (Circle)"},{"location":"equations/#line-elements","text":"The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\]","title":"Line Elements"},{"location":"equations/#composite-polygons","text":"An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet.","title":"Composite Polygons"},{"location":"equations/#3d-calculations","text":"The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) .","title":"3D Calculations"},{"location":"equations/#prismscuboids","text":"For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis.","title":"Prisms/Cuboids"},{"location":"equations/#cylinderssolenoids","text":"Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 .","title":"Cylinders/Solenoids"},{"location":"equations/#bulirschs-complete-elliptic-integral","text":"See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s)","title":"Bulirsch's  complete elliptic integral"},{"location":"equations/#example","text":"Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 )","title":"Example"},{"location":"equations/#spheres","text":"Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\]","title":"Spheres"},{"location":"equations/#composite-objects","text":"","title":"Composite Objects"},{"location":"equations/#polyhedra","text":"For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements: \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ b + \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 } - z }{ \\sqrt{(a-x)^2 + y^2 + z^2} - z}\\right)\\right.\\\\ & + \\left. \\frac{b}{c} \\ln \\left( \\frac{r - s }{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{\\sqrt{(a-x)^2 + y^2 + z^2} + a}\\right)\\right.\\\\ & + \\left. \\frac{a}{c} \\ln \\left( \\frac{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t}{r - s } \\right) \\right] \\end{align} \\] where \\(r = \\sqrt{x^2 + y^2 + z^2},\\, c = \\sqrt{a^2 + b^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{(x-a) + z + \\sqrt{(x-a)^2 + y^2 + z^2}}{y}\\right)\\right.\\\\ & - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha\\sqrt{B^2 - A^2 - C^2}} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{(\\alpha+\\beta)^2}{\\gamma^2}} + \\frac{\\alpha + \\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{\\beta^2}{\\gamma^2}} + \\frac{\\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{1 + \\frac{b^2}{a^2}}, \\, \\gamma = \\sqrt{\\frac{r^2}{1 + \\frac{b^2}{a^2}} - \\beta^2}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\sqrt{1 + \\frac{b^2}{a^2}},\\, C = z + \\beta\\frac{b}{a}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9","title":"Polyhedra"},{"location":"magnets/","text":"Magnets module pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Todo Quaternions and arbitrary rotation Conversion between cylindrical and cartesian coordinates pymagnets._fields Private module consiting of point/vector classes and their methods. Point2 2D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Parameters: Name Type Description Default object [type] [description] required Examples: TODO: Point3 \"3D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Parameters: Name Type Description Default object [type] [description] required Examples: TODO: Vector2 2D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n Vector3 3D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required z required Methods calculates the magnitude of the fields at every point and stores in self.n Magnet Base class This private module implements the registry and base magnet classes Magnet Magnet base class Returns: Type Description Magnet magnet base class Registry Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset() __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = [] __new__ ( cls , * args , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o get_num_instances ( Print_Val = False ) classmethod Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances ) print_instances () classmethod Prints class instantiations Source code in pymagnet/magnets/_magnet.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance ) reset () classmethod Removes all instances from registry. Source code in pymagnet/magnets/_magnet.py @classmethod def reset ( cls ) -> None : \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = [] list_magnets () Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances () reset_magnets () Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2 import Magnet_2D , Rectangle , Square , Circle from ._poly2D import PolyMagnet from ._magnet3 import Magnet_3D , Prism , Cube , Cylinder , Sphere from ._poly3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet_2D , Rectangle , Square , Circle , PolyMagnet , Magnet_3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet. magnetic_field_cylinder_1D ( magnet , z ) Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3 import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr if type ( z ) is not _np . ndarray : # z_local = z z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . zc else : # z_local = z z_local = z - magnet . length / 2 - magnet . zc zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) data = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) data *= Jr / 2 return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return _np . NaN magnetic_field_prism_1D ( magnet , z ) Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3 import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr if type ( z ) is not _np . ndarray : z_local = _np . asarray ( z ) - c - magnet . zc else : z_local = z - c - magnet . zc ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) data = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) data *= Jr / _np . pi return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return _np . full_like ( z , _np . nan ) 2D Magnet classes This private module implements the rectangle and square 2D magnet classes Todo Add del method for removing strong ref in class instance list Circle Circle Magnet Class Parameters: Name Type Description Default radius [float] magnet radius [m] (defaults to 10) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: center: magnet centre (Point2 object) [default Point2(0.0, 0.0)] calcB ( self , x , y ) Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ._routines import cart2pol , vector_pol2cart from ._routines2 import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x , y , self . alpha_radians ) xci , yci = rotate_points_2D ( _np . array ([ self . xc ]), _np . array ([ self . yc ]), self . alpha_radians ) rho , phi = cart2pol ( xi - xci [ 0 ], yi - yci [ 0 ]) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . xc , y - self . yc ) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By get_Jr ( self ) Returns Magnetisation components [Jr] Returns: Type Description ndarray [Jr] Source code in pymagnet/magnets/_magnet2.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jr] Returns: ndarray: [Jr] \"\"\" return _np . array ([ self . Jr ]) Magnet_2D 2D Magnet class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or Point2]: center of magnet, defaults to Point2(0.0, 0.0) center ( self ) Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2.py def center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return _np . array ([ self . xc , self . yc ]) get_orientation ( self ) Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha Rectangle Rectangle Magnet Class Parameters: Name Type Description Default width [float] magnet width [m] (defaults to 20) required height [float] magnet height [m] (defaults to 40) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] calcB ( self , x , y ) Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required Returns: Type Description Vector2 magnetic field vector Source code in pymagnet/magnets/_magnet2.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (float/array): x co-ordinates y (float/array): y co-ordinates Returns: Vector2: magnetic field vector \"\"\" from ._routines2 import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x , y , self . alpha_radians ) xci , yci = rotate_points_2D ( _np . array ([ self . xc ]), _np . array ([ self . yc ]), self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi - xci [ 0 ], yi - yci [ 0 ]) Bty = self . _calcBy_mag_x ( xi - xci [ 0 ], yi - yci [ 0 ]) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . xc , y - self . yc ) By = self . _calcBy_mag_x ( x - self . xc , y - self . yc ) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : Btx = self . _calcBx_mag_y ( xi - xci [ 0 ], yi - yci [ 0 ]) Bty = self . _calcBy_mag_y ( xi - xci [ 0 ], yi - yci [ 0 ]) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . xc , y - self . yc ) By += self . _calcBy_mag_y ( x - self . xc , y - self . yc ) return Bx , By get_Jr ( self ) Returns Magnetisation components [Jx, Jy] Returns: Type Description J[ndarray] [Jx, Jy] Source code in pymagnet/magnets/_magnet2.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jx, Jy] Returns: J[ndarray]: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ]) size ( self ) Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, height] Source code in pymagnet/magnets/_magnet2.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ]) Square Square Magnet Class Parameters: Name Type Description Default width [float] magnet side length [m] (defaults to 20) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] 3D Magnet classes This private module implements the Prism , Cube , Cylinder , and Sphere 3D magnet classes. The parent class Magnet_3D implements the location and orientation methods, i.e. magnet center and quaternion methods for rotating the magnet with respect to each principal axis. Examples: Examples can be given using either the Example or Examples sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.py Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. Todo Add del method for removing strong ref in class instance list Update str and repr methods to show orientation and magnetisation Cube Cube Magnet Class. Cuboid width x depth x height. Parameters: Name Type Description Default width [float] magnet side length [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees] Cylinder Cylinder Magnet Class Parameters: Name Type Description Default radius radius [default 10] required length length [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] get_Jr ( self ) Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ 0.0 , 0.0 , self . Jr ]) size ( self ) Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [radius, length] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [radius, length] \"\"\" return _np . array ([ self . radius , self . length ]) Magnet_3D 3D Magnet Class Parameters: Name Type Description Default width magnet width [default 10] required depth magnet depth [default 20] required height magnet height [default 30] required Optional Arguments: centre: magnet centre (Point3_3D object) [default Point3(.0, .0, .0)] J: remnant magnetisation in Tesla [default 1.0] calcB ( self , x , y , z ) Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_magnet3.py def calcB ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" from ._routines3 import _tile_arrays , _apply_mask # If any rotation angle is set, transform the data if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Magnet . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation pos_vec = Quaternion . _prepare_vector ( x - self . xc , y - self . yc , z - self . zc ) # Rotate points x_rot , y_rot , z_rot = forward_rotation * pos_vec # Calls internal child method to calculate the field B_local = self . _calcB_local ( x_rot , y_rot , z_rot ) mask = self . _generate_mask ( x_rot , y_rot , z_rot ) B_local = _apply_mask ( self , B_local , mask ) # Rearrange the field vectors in a 3xN array for quaternion rotation Bvec = Quaternion . _prepare_vector ( B_local . x , B_local . y , B_local . z ) # Rotate the local fields back into the global frame using quaternions Bx , By , Bz = reverse_rotation * Bvec # finally return the fields return Bx , By , Bz else : B = self . _calcB_local ( x - self . xc , y - self . yc , z - self . zc ) xloc , yloc , zloc = _tile_arrays ( x - self . xc , y - self . yc , z - self . zc ) mask = self . _generate_mask ( xloc , yloc , zloc ) B = _apply_mask ( self , B , mask ) return B . x , B . y , B . z center ( self ) Returns magnet center Returns: Type Description ndarray [center_x, center_y, center_z] Source code in pymagnet/magnets/_magnet3.py def center ( self ): \"\"\"Returns magnet center Returns: ndarray: [center_x, center_y, center_z] \"\"\" return _np . array ([ self . xc , self . yc , self . zc ]) get_Jr ( self ) Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): \"\"\"Returns local magnetisation orientation Must be implemented for all classes \"\"\" pass get_orientation ( self ) Returns magnet orientation, alpha , beta , gamma in degrees Returns: Type Description ndarray alpha, beta, gamma rotation angles w.r.t z, y, and x axes Source code in pymagnet/magnets/_magnet3.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha`, `beta`, `gamma` in degrees Returns: ndarray: alpha, beta, gamma rotation angles w.r.t z, y, and x axes \"\"\" return _np . array ([ self . alpha , self . beta , self . gamma ]) size ( self ) Returns magnet dimesions Must be implemented for each magnet Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Must be implemented for each magnet \"\"\" pass Prism Prism Magnet Class. Cuboid (width, depth height). Parameters: Name Type Description Default width float magnet width [default 10] required depth float magnet depth [default 20] required height float magnet height [default 30] required Jr float remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees] get_Jr ( self ) Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ self . Jx , self . Jy , self . Jz ]) size ( self ) Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, depth, height] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, depth, height] \"\"\" return _np . array ([ self . width , self . depth , self . height ]) Sphere Sphere Magnet Class Parameters: Name Type Description Default radius radius [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees] get_Jr ( self ) Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ 0.0 , 0.0 , self . Jr ]) size ( self ) Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [radius, length] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [radius, length] \"\"\" return _np . array ([ self . radius ]) Routines for converting between coordinate systems cart2pol ( x , y ) Converts from cartesian to polar coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/magnets/_routines.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi ) cart2sph ( x , y , z ) Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required z float/array z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/magnets/_routines.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (float/array): x coordinates y (float/array): y coordinates z (float/array): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi ) pol2cart ( rho , phi ) Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho float/array radial coordinates required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/magnets/_routines.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (float/array): radial coordinates phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y ) sph2cart ( r , theta , phi ) Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r float/array radial coordinates required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/magnets/_routines.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (float/array): radial coordinates theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z sphere_sph2cart ( Br , Btheta , theta , phi ) Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/magnets/_routines.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz vector_pol2cart ( Brho , Bphi , phi ) Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho float/array radial vector component required Bphi float/array azimuthal vector component required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/magnets/_routines.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (float/array): radial vector component Bphi (float/array): azimuthal vector component phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By vector_sph2cart ( Br , Btheta , Bphi , theta , phi ) Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required Bphi float/array azimuthal vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/magnets/_routines.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component Bphi (float/array): azimuthal vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz Routines for Two Dimensional Magnet Classes B_calc_2D ( x , y ) Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M Source code in pymagnet/magnets/_routines2.py def B_calc_2D ( x , y ): \"\"\"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M \"\"\" from ._magnet2 import Magnet_2D # Empty data structure B = _allocate_field_array2 ( x , y ) for magnet in Magnet_2D . instances : Bx , By = magnet . calcB ( x , y ) B . x += Bx B . y += By B . calc_norm () return B FgradB_2D ( B , x , y , chi_m , c ) Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Vector2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Vector2 Magnetic field gradient force vector Source code in pymagnet/magnets/_routines2.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Vector2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Vector2: Magnetic field gradient force vector \"\"\" from ._fields import Vector2 from .. import u0 BgB = Vector2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Vector2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / u0 ) * chi_m * c * BgB . n FB . x = ( 1 / u0 ) * chi_m * c * BgB . x FB . y = ( 1 / u0 ) * chi_m * c * BgB . y return FB gradB_2D ( B , x , y ) Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Vector2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Vector2 Magnetic field gradient vector Source code in pymagnet/magnets/_routines2.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Vector2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Vector2: Magnetic field gradient vector \"\"\" from ._fields import Vector2 dB = Vector2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB grid2D ( ux , uy , ** kwargs ) Grid of x,y points. Parameters: Name Type Description Default ux [float] [x upper limit] required uy [float] [y upper limit] required lx [float, optional] [x lower limit defaults to -ux] required ly [optional] [x lower limit defaults to -ux] required NP int [number of points in each direction]. Defaults to 100. required Source code in pymagnet/magnets/_routines2.py def grid2D ( ux , uy , ** kwargs ): \"\"\"Grid of x,y points. Args: ux ([float]): [x upper limit] uy ([float]): [y upper limit] lx ([float, optional]): [x lower limit defaults to -ux] ly ([optional]): [x lower limit defaults to -ux] NP (int, optional): [number of points in each direction]. Defaults to 100. \"\"\" NP = kwargs . pop ( \"NP\" , 100 ) lx = kwargs . pop ( \"lx\" , - 1 * ux ) ly = kwargs . pop ( \"ly\" , - 1 * uy ) NPJ = NP * 1 j return _np . mgrid [ lx : ux : NPJ , ly : uy : NPJ ] rotate_points_2D ( x , y , alpha ) Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x float/array array of x coordinates required y float/array array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/magnets/_routines2.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (float/array): array of x coordinates y (float/array): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes grid3D ( ux , uy , uz , ** kwargs ) Grid of x,y, z points. Parameters: Name Type Description Default ux [float] [x upper limit] required uy [float] [y upper limit] required uz [float] [z upper limit] required lx [float, optional] [x lower limit defaults to -ux] required ly [optional] [y lower limit defaults to -uy] required lz [optional] [x lower limit defaults to -ux] required NP int [number of points in each direction]. Defaults to 100. required Returns: Type Description grid numpy array Source code in pymagnet/magnets/_routines3.py def grid3D ( ux , uy , uz , ** kwargs ): \"\"\"Grid of x,y, z points. Args: ux ([float]): [x upper limit] uy ([float]): [y upper limit] uz ([float]): [z upper limit] lx ([float, optional]): [x lower limit defaults to -ux] ly ([optional]): [y lower limit defaults to -uy] lz ([optional]): [x lower limit defaults to -ux] NP (int, optional): [number of points in each direction]. Defaults to 100. Returns: grid: numpy array \"\"\" NP = kwargs . pop ( \"NP\" , None ) if NP is None : NPx = kwargs . pop ( \"NPx\" , 100 ) NPy = kwargs . pop ( \"NPy\" , 100 ) NPz = kwargs . pop ( \"NPz\" , 100 ) else : NPx = NP NPy = NP NPz = NP lx = kwargs . pop ( \"lx\" , - 1 * ux ) ly = kwargs . pop ( \"ly\" , - 1 * uy ) lz = kwargs . pop ( \"lz\" , - 1 * uz ) return _np . mgrid [ lx : ux : NPx * 1 j , ly : uy : NPy * 1 j , lz : uz : NPz * 1 j ]","title":"magnets"},{"location":"magnets/#magnets-module","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Todo Quaternions and arbitrary rotation Conversion between cylindrical and cartesian coordinates pymagnets._fields Private module consiting of point/vector classes and their methods.","title":"Magnets module"},{"location":"magnets/#pymagnet.magnets._fields.Point2","text":"2D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Parameters: Name Type Description Default object [type] [description] required Examples: TODO:","title":"Point2"},{"location":"magnets/#pymagnet.magnets._fields.Point3","text":"\"3D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Parameters: Name Type Description Default object [type] [description] required Examples: TODO:","title":"Point3"},{"location":"magnets/#pymagnet.magnets._fields.Vector2","text":"2D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Vector2"},{"location":"magnets/#pymagnet.magnets._fields.Vector3","text":"3D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required z required Methods calculates the magnitude of the fields at every point and stores in self.n Magnet Base class This private module implements the registry and base magnet classes","title":"Vector3"},{"location":"magnets/#pymagnet.magnets._magnet.Magnet","text":"Magnet base class Returns: Type Description Magnet magnet base class","title":"Magnet"},{"location":"magnets/#pymagnet.magnets._magnet.Registry","text":"Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset()","title":"Registry"},{"location":"magnets/#pymagnet.magnets._magnet.Registry.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = []","title":"__init_subclass__()"},{"location":"magnets/#pymagnet.magnets._magnet.Registry.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o","title":"__new__()"},{"location":"magnets/#pymagnet.magnets._magnet.Registry.get_num_instances","text":"Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances )","title":"get_num_instances()"},{"location":"magnets/#pymagnet.magnets._magnet.Registry.print_instances","text":"Prints class instantiations Source code in pymagnet/magnets/_magnet.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance )","title":"print_instances()"},{"location":"magnets/#pymagnet.magnets._magnet.Registry.reset","text":"Removes all instances from registry. Source code in pymagnet/magnets/_magnet.py @classmethod def reset ( cls ) -> None : \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = []","title":"reset()"},{"location":"magnets/#pymagnet.magnets._magnet.list_magnets","text":"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances ()","title":"list_magnets()"},{"location":"magnets/#pymagnet.magnets._magnet.reset_magnets","text":"Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2 import Magnet_2D , Rectangle , Square , Circle from ._poly2D import PolyMagnet from ._magnet3 import Magnet_3D , Prism , Cube , Cylinder , Sphere from ._poly3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet_2D , Rectangle , Square , Circle , PolyMagnet , Magnet_3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet.","title":"reset_magnets()"},{"location":"magnets/#pymagnet.magnets._magnet1.magnetic_field_cylinder_1D","text":"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3 import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr if type ( z ) is not _np . ndarray : # z_local = z z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . zc else : # z_local = z z_local = z - magnet . length / 2 - magnet . zc zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) data = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) data *= Jr / 2 return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return _np . NaN","title":"magnetic_field_cylinder_1D()"},{"location":"magnets/#pymagnet.magnets._magnet1.magnetic_field_prism_1D","text":"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3 import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr if type ( z ) is not _np . ndarray : z_local = _np . asarray ( z ) - c - magnet . zc else : z_local = z - c - magnet . zc ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) data = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) data *= Jr / _np . pi return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return _np . full_like ( z , _np . nan ) 2D Magnet classes This private module implements the rectangle and square 2D magnet classes Todo Add del method for removing strong ref in class instance list","title":"magnetic_field_prism_1D()"},{"location":"magnets/#pymagnet.magnets._magnet2.Circle","text":"Circle Magnet Class Parameters: Name Type Description Default radius [float] magnet radius [m] (defaults to 10) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: center: magnet centre (Point2 object) [default Point2(0.0, 0.0)]","title":"Circle"},{"location":"magnets/#pymagnet.magnets._magnet2.Circle.calcB","text":"Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ._routines import cart2pol , vector_pol2cart from ._routines2 import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x , y , self . alpha_radians ) xci , yci = rotate_points_2D ( _np . array ([ self . xc ]), _np . array ([ self . yc ]), self . alpha_radians ) rho , phi = cart2pol ( xi - xci [ 0 ], yi - yci [ 0 ]) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . xc , y - self . yc ) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._magnet2.Circle.get_Jr","text":"Returns Magnetisation components [Jr] Returns: Type Description ndarray [Jr] Source code in pymagnet/magnets/_magnet2.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jr] Returns: ndarray: [Jr] \"\"\" return _np . array ([ self . Jr ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet2.Magnet_2D","text":"2D Magnet class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or Point2]: center of magnet, defaults to Point2(0.0, 0.0)","title":"Magnet_2D"},{"location":"magnets/#pymagnet.magnets._magnet2.Magnet_2D.center","text":"Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2.py def center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return _np . array ([ self . xc , self . yc ])","title":"center()"},{"location":"magnets/#pymagnet.magnets._magnet2.Magnet_2D.get_orientation","text":"Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha","title":"get_orientation()"},{"location":"magnets/#pymagnet.magnets._magnet2.Rectangle","text":"Rectangle Magnet Class Parameters: Name Type Description Default width [float] magnet width [m] (defaults to 20) required height [float] magnet height [m] (defaults to 40) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees]","title":"Rectangle"},{"location":"magnets/#pymagnet.magnets._magnet2.Rectangle.calcB","text":"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required Returns: Type Description Vector2 magnetic field vector Source code in pymagnet/magnets/_magnet2.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (float/array): x co-ordinates y (float/array): y co-ordinates Returns: Vector2: magnetic field vector \"\"\" from ._routines2 import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x , y , self . alpha_radians ) xci , yci = rotate_points_2D ( _np . array ([ self . xc ]), _np . array ([ self . yc ]), self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi - xci [ 0 ], yi - yci [ 0 ]) Bty = self . _calcBy_mag_x ( xi - xci [ 0 ], yi - yci [ 0 ]) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . xc , y - self . yc ) By = self . _calcBy_mag_x ( x - self . xc , y - self . yc ) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : Btx = self . _calcBx_mag_y ( xi - xci [ 0 ], yi - yci [ 0 ]) Bty = self . _calcBy_mag_y ( xi - xci [ 0 ], yi - yci [ 0 ]) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . xc , y - self . yc ) By += self . _calcBy_mag_y ( x - self . xc , y - self . yc ) return Bx , By","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._magnet2.Rectangle.get_Jr","text":"Returns Magnetisation components [Jx, Jy] Returns: Type Description J[ndarray] [Jx, Jy] Source code in pymagnet/magnets/_magnet2.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jx, Jy] Returns: J[ndarray]: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet2.Rectangle.size","text":"Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, height] Source code in pymagnet/magnets/_magnet2.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ])","title":"size()"},{"location":"magnets/#pymagnet.magnets._magnet2.Square","text":"Square Magnet Class Parameters: Name Type Description Default width [float] magnet side length [m] (defaults to 20) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] 3D Magnet classes This private module implements the Prism , Cube , Cylinder , and Sphere 3D magnet classes. The parent class Magnet_3D implements the location and orientation methods, i.e. magnet center and quaternion methods for rotating the magnet with respect to each principal axis. Examples: Examples can be given using either the Example or Examples sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.py Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. Todo Add del method for removing strong ref in class instance list Update str and repr methods to show orientation and magnetisation","title":"Square"},{"location":"magnets/#pymagnet.magnets._magnet3.Cube","text":"Cube Magnet Class. Cuboid width x depth x height. Parameters: Name Type Description Default width [float] magnet side length [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees]","title":"Cube"},{"location":"magnets/#pymagnet.magnets._magnet3.Cylinder","text":"Cylinder Magnet Class Parameters: Name Type Description Default radius radius [default 10] required length length [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)]","title":"Cylinder"},{"location":"magnets/#pymagnet.magnets._magnet3.Cylinder.get_Jr","text":"Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ 0.0 , 0.0 , self . Jr ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet3.Cylinder.size","text":"Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [radius, length] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [radius, length] \"\"\" return _np . array ([ self . radius , self . length ])","title":"size()"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D","text":"3D Magnet Class Parameters: Name Type Description Default width magnet width [default 10] required depth magnet depth [default 20] required height magnet height [default 30] required Optional Arguments: centre: magnet centre (Point3_3D object) [default Point3(.0, .0, .0)] J: remnant magnetisation in Tesla [default 1.0]","title":"Magnet_3D"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D.calcB","text":"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_magnet3.py def calcB ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" from ._routines3 import _tile_arrays , _apply_mask # If any rotation angle is set, transform the data if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Magnet . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation pos_vec = Quaternion . _prepare_vector ( x - self . xc , y - self . yc , z - self . zc ) # Rotate points x_rot , y_rot , z_rot = forward_rotation * pos_vec # Calls internal child method to calculate the field B_local = self . _calcB_local ( x_rot , y_rot , z_rot ) mask = self . _generate_mask ( x_rot , y_rot , z_rot ) B_local = _apply_mask ( self , B_local , mask ) # Rearrange the field vectors in a 3xN array for quaternion rotation Bvec = Quaternion . _prepare_vector ( B_local . x , B_local . y , B_local . z ) # Rotate the local fields back into the global frame using quaternions Bx , By , Bz = reverse_rotation * Bvec # finally return the fields return Bx , By , Bz else : B = self . _calcB_local ( x - self . xc , y - self . yc , z - self . zc ) xloc , yloc , zloc = _tile_arrays ( x - self . xc , y - self . yc , z - self . zc ) mask = self . _generate_mask ( xloc , yloc , zloc ) B = _apply_mask ( self , B , mask ) return B . x , B . y , B . z","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D.center","text":"Returns magnet center Returns: Type Description ndarray [center_x, center_y, center_z] Source code in pymagnet/magnets/_magnet3.py def center ( self ): \"\"\"Returns magnet center Returns: ndarray: [center_x, center_y, center_z] \"\"\" return _np . array ([ self . xc , self . yc , self . zc ])","title":"center()"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D.get_Jr","text":"Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): \"\"\"Returns local magnetisation orientation Must be implemented for all classes \"\"\" pass","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D.get_orientation","text":"Returns magnet orientation, alpha , beta , gamma in degrees Returns: Type Description ndarray alpha, beta, gamma rotation angles w.r.t z, y, and x axes Source code in pymagnet/magnets/_magnet3.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha`, `beta`, `gamma` in degrees Returns: ndarray: alpha, beta, gamma rotation angles w.r.t z, y, and x axes \"\"\" return _np . array ([ self . alpha , self . beta , self . gamma ])","title":"get_orientation()"},{"location":"magnets/#pymagnet.magnets._magnet3.Magnet_3D.size","text":"Returns magnet dimesions Must be implemented for each magnet Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Must be implemented for each magnet \"\"\" pass","title":"size()"},{"location":"magnets/#pymagnet.magnets._magnet3.Prism","text":"Prism Magnet Class. Cuboid (width, depth height). Parameters: Name Type Description Default width float magnet width [default 10] required depth float magnet depth [default 20] required height float magnet height [default 30] required Jr float remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees]","title":"Prism"},{"location":"magnets/#pymagnet.magnets._magnet3.Prism.get_Jr","text":"Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ self . Jx , self . Jy , self . Jz ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet3.Prism.size","text":"Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, depth, height] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, depth, height] \"\"\" return _np . array ([ self . width , self . depth , self . height ])","title":"size()"},{"location":"magnets/#pymagnet.magnets._magnet3.Sphere","text":"Sphere Magnet Class Parameters: Name Type Description Default radius radius [default 10] required J remnant magnetisation in Tesla [default 1.0] required Optional Arguments: centre: magnet centre (tuple or Point3) [default Point3(.0, .0, .0)] theta: Angle between magnetisation and x-axis [default 90.0 degrees] phi: Angle between magnetisation and z-axis [default 0.0 degrees]","title":"Sphere"},{"location":"magnets/#pymagnet.magnets._magnet3.Sphere.get_Jr","text":"Returns local magnetisation orientation Must be implemented for all classes Source code in pymagnet/magnets/_magnet3.py def get_Jr ( self ): return _np . array ([ 0.0 , 0.0 , self . Jr ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet3.Sphere.size","text":"Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [radius, length] Source code in pymagnet/magnets/_magnet3.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [radius, length] \"\"\" return _np . array ([ self . radius ]) Routines for converting between coordinate systems","title":"size()"},{"location":"magnets/#pymagnet.magnets._routines.cart2pol","text":"Converts from cartesian to polar coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/magnets/_routines.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi )","title":"cart2pol()"},{"location":"magnets/#pymagnet.magnets._routines.cart2sph","text":"Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required z float/array z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/magnets/_routines.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (float/array): x coordinates y (float/array): y coordinates z (float/array): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi )","title":"cart2sph()"},{"location":"magnets/#pymagnet.magnets._routines.pol2cart","text":"Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho float/array radial coordinates required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/magnets/_routines.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (float/array): radial coordinates phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y )","title":"pol2cart()"},{"location":"magnets/#pymagnet.magnets._routines.sph2cart","text":"Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r float/array radial coordinates required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/magnets/_routines.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (float/array): radial coordinates theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z","title":"sph2cart()"},{"location":"magnets/#pymagnet.magnets._routines.sphere_sph2cart","text":"Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/magnets/_routines.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz","title":"sphere_sph2cart()"},{"location":"magnets/#pymagnet.magnets._routines.vector_pol2cart","text":"Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho float/array radial vector component required Bphi float/array azimuthal vector component required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/magnets/_routines.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (float/array): radial vector component Bphi (float/array): azimuthal vector component phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By","title":"vector_pol2cart()"},{"location":"magnets/#pymagnet.magnets._routines.vector_sph2cart","text":"Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required Bphi float/array azimuthal vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/magnets/_routines.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component Bphi (float/array): azimuthal vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz Routines for Two Dimensional Magnet Classes","title":"vector_sph2cart()"},{"location":"magnets/#pymagnet.magnets._routines2.B_calc_2D","text":"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M Source code in pymagnet/magnets/_routines2.py def B_calc_2D ( x , y ): \"\"\"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M \"\"\" from ._magnet2 import Magnet_2D # Empty data structure B = _allocate_field_array2 ( x , y ) for magnet in Magnet_2D . instances : Bx , By = magnet . calcB ( x , y ) B . x += Bx B . y += By B . calc_norm () return B","title":"B_calc_2D()"},{"location":"magnets/#pymagnet.magnets._routines2.FgradB_2D","text":"Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Vector2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Vector2 Magnetic field gradient force vector Source code in pymagnet/magnets/_routines2.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Vector2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Vector2: Magnetic field gradient force vector \"\"\" from ._fields import Vector2 from .. import u0 BgB = Vector2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Vector2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / u0 ) * chi_m * c * BgB . n FB . x = ( 1 / u0 ) * chi_m * c * BgB . x FB . y = ( 1 / u0 ) * chi_m * c * BgB . y return FB","title":"FgradB_2D()"},{"location":"magnets/#pymagnet.magnets._routines2.gradB_2D","text":"Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Vector2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Vector2 Magnetic field gradient vector Source code in pymagnet/magnets/_routines2.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Vector2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Vector2: Magnetic field gradient vector \"\"\" from ._fields import Vector2 dB = Vector2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB","title":"gradB_2D()"},{"location":"magnets/#pymagnet.magnets._routines2.grid2D","text":"Grid of x,y points. Parameters: Name Type Description Default ux [float] [x upper limit] required uy [float] [y upper limit] required lx [float, optional] [x lower limit defaults to -ux] required ly [optional] [x lower limit defaults to -ux] required NP int [number of points in each direction]. Defaults to 100. required Source code in pymagnet/magnets/_routines2.py def grid2D ( ux , uy , ** kwargs ): \"\"\"Grid of x,y points. Args: ux ([float]): [x upper limit] uy ([float]): [y upper limit] lx ([float, optional]): [x lower limit defaults to -ux] ly ([optional]): [x lower limit defaults to -ux] NP (int, optional): [number of points in each direction]. Defaults to 100. \"\"\" NP = kwargs . pop ( \"NP\" , 100 ) lx = kwargs . pop ( \"lx\" , - 1 * ux ) ly = kwargs . pop ( \"ly\" , - 1 * uy ) NPJ = NP * 1 j return _np . mgrid [ lx : ux : NPJ , ly : uy : NPJ ]","title":"grid2D()"},{"location":"magnets/#pymagnet.magnets._routines2.rotate_points_2D","text":"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x float/array array of x coordinates required y float/array array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/magnets/_routines2.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (float/array): array of x coordinates y (float/array): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes","title":"rotate_points_2D()"},{"location":"magnets/#pymagnet.magnets._routines3.grid3D","text":"Grid of x,y, z points. Parameters: Name Type Description Default ux [float] [x upper limit] required uy [float] [y upper limit] required uz [float] [z upper limit] required lx [float, optional] [x lower limit defaults to -ux] required ly [optional] [y lower limit defaults to -uy] required lz [optional] [x lower limit defaults to -ux] required NP int [number of points in each direction]. Defaults to 100. required Returns: Type Description grid numpy array Source code in pymagnet/magnets/_routines3.py def grid3D ( ux , uy , uz , ** kwargs ): \"\"\"Grid of x,y, z points. Args: ux ([float]): [x upper limit] uy ([float]): [y upper limit] uz ([float]): [z upper limit] lx ([float, optional]): [x lower limit defaults to -ux] ly ([optional]): [y lower limit defaults to -uy] lz ([optional]): [x lower limit defaults to -ux] NP (int, optional): [number of points in each direction]. Defaults to 100. Returns: grid: numpy array \"\"\" NP = kwargs . pop ( \"NP\" , None ) if NP is None : NPx = kwargs . pop ( \"NPx\" , 100 ) NPy = kwargs . pop ( \"NPy\" , 100 ) NPz = kwargs . pop ( \"NPz\" , 100 ) else : NPx = NP NPy = NP NPz = NP lx = kwargs . pop ( \"lx\" , - 1 * ux ) ly = kwargs . pop ( \"ly\" , - 1 * uy ) lz = kwargs . pop ( \"lz\" , - 1 * uz ) return _np . mgrid [ lx : ux : NPx * 1 j , ly : uy : NPy * 1 j , lz : uz : NPz * 1 j ]","title":"grid3D()"},{"location":"methods/","text":"Methods Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calcuated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot. Classes At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes. Magnet Classes The hierarcy of magnet classes is (click image for high resolution view) Quaternion Class This is a convenience class for performing rotations of points/vectors about arbitrary axes. Plot Methods Draw Magnets on Plot","title":"Methods"},{"location":"methods/#methods","text":"Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calcuated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot.","title":"Methods"},{"location":"methods/#classes","text":"At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes.","title":"Classes"},{"location":"methods/#magnet-classes","text":"The hierarcy of magnet classes is (click image for high resolution view)","title":"Magnet Classes"},{"location":"methods/#quaternion-class","text":"This is a convenience class for performing rotations of points/vectors about arbitrary axes.","title":"Quaternion Class"},{"location":"methods/#plot-methods","text":"","title":"Plot Methods"},{"location":"methods/#draw-magnets-on-plot","text":"","title":"Draw Magnets on Plot"},{"location":"plots/","text":"Plots module pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of 3D magnets plot_1D_field ( magnet , ** kwargs ) Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet magnet object Must be a Magnet_3D type of magnet, either Prism, Cube, required Kwargs NP (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple z,Bz: arrays of z the distance from the magnet surface, and Bz the magnetic field. Source code in pymagnet/plots/_plot1.py def plot_1D_field ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (magnet object): Must be a Magnet_3D type of magnet, either Prism, Cube, or Cylinder. Kwargs: NP (int): Number of points to calculate. Defaults to 101. Returns: tuple: z,Bz: arrays of z the distance from the magnet surface, and Bz the magnetic field. \"\"\" NP = kwargs . pop ( \"NP\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) if issubclass ( magnet . __class__ , _mag . Cylinder ): mag_boundary = magnet . length / 2 z = _np . linspace ( - 2 * magnet . length + magnet . zc , 2 * magnet . length + magnet . zc , NP ) Bz = _mag . magnetic_field_cylinder_1D ( magnet , z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . zc , z ) Bz [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , _mag . Prism ): mag_boundary = magnet . height / 2 z = _np . linspace ( - 2 * magnet . height + magnet . zc , 2 * magnet . height + magnet . zc , NP ) Bz = _mag . magnetic_field_prism_1D ( magnet , z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . zc , z ) Bz [ mask ] = _np . NaN else : print ( \"Error\" ) return None _ , _ = _plt . subplots () _plt . xlabel ( r \"$z$ (mm)\" ) _plt . ylabel ( r \"$B_z$ (mT)\" ) _plt . plot ( z * 1e3 , Bz * 1e3 , label = \"Cube\" ) _plt . axvline ( x =- mag_boundary * 1e3 + magnet . zc * 1e3 , c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary * 1e3 + magnet . zc * 1e3 , c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return z , Bz Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and arrow Encodes magnetisation vector for drawing on plots __init__ ( self , x , y , dx , dy , transform , width = 3 ) special Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width magnet_patch Magnet drawing class Parameters: Name Type Description Default object [type] [description] required patch Encodes magnet dimensions for drawing on plots Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required __init__ ( self , x , y , width , height , transform , type ) special Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type contour_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [type] [description] required Source code in pymagnet/plots/_plot2.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet ([type]): [description] \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (mm)\" ylab = \"z (mm)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , ) line_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [magnet object] required Source code in pymagnet/plots/_plot2.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet ([magnet object]): \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) _ , _ = _plt . subplots () _plt . plot ( rho * 1 , Bz , label = \"Bz\" ) _plt . plot ( rho * 1 , Br , label = \"Br\" ) _plt . legend ( loc = \"best\" ) _plt . show () param_test_2D ( width , height ) Example plots while varying the size of a permanent magnet This is an example helper function. Parameters: Name Type Description Default width [type] [description] required height [type] [description] required Source code in pymagnet/plots/_plot2.py def param_test_2D ( width , height ): \"\"\"Example plots while varying the size of a permanent magnet This is an example helper function. Args: width ([type]): [description] height ([type]): [description] \"\"\" x = _np . linspace ( - 2 * width , 2 * width , 100 ) y = 1 + height B = _mag . _routines2 . B_calc_2D ( x , y ) plot_2D_line ( x , B ) x , y = _mag . _routines2 . grid2D ( 1.5 * width , height ) B = _mag . _routines2 . B_calc_2D ( x , y ) cmap = \"viridis\" plot_2D_contour ( x , y , B , cmax = 1 , num_levels = 11 , cmap = cmap ) plot_2D_contour ( x , y , Field , ** kwargs ) Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_2D_contour ( x , y , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector_2D]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._poly2D import PolyMagnet scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) _ , ax = _plt . subplots () if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"magma\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = Field . x elif field_component == \"y\" : field_chosen = Field . y else : field_chosen = Field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] * scale_cb cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( x * scale_x , y * scale_y , field_chosen * scale_cb , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( x * scale_x , y * scale_y , field_chosen * scale_cb , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( x , y , Field , NQ , scale_x , scale_y , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = x [:, 0 ] * scale_x ypl = y [ 0 , :] * scale_y cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( Field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( Field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : Field . n . T , \"horizontal\" : Field . x . T , \"vertical\" : Field . y . T , } CS = _plt . streamplot ( xpl , ypl , Field . x . T / Field . n . T , Field . y . T / Field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , Field . x . T / Field . n . T , Field . y . T / Field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax , scale_x , scale_y ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ) * scale_x , ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) plot_2D_line ( x , Field , ** kwargs ) Line Plot of field from 2D magnet Parameters: Name Type Description Default x [array] [assumes in m] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_2D_line ( x , Field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: x ([array]): [assumes in m] Field ([field vector_2D]): [field vector object] \"\"\" scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) _ , ax = _plt . subplots () _plt . plot ( x * scale_x , Field . n * scale_cb , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( x * scale_x , Field . x * scale_cb , label = r \"$B_x$\" ) _plt . plot ( x * scale_x , Field . y * scale_cb , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 ) plot_3D_contour ( x , y , z , Field , ** kwargs ) Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_3D_contour ( x , y , z , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._fields import Vector2 scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_z = kwargs . pop ( \"scale_z\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) zlab = kwargs . pop ( \"zlab\" , f \"z (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = Field . n [ _np . isfinite ( Field . n )] * scale_cb cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if _np . ndim ( z ) < 2 : orientation = \"xy\" stream_x = Field . x stream_y = Field . y plot_x = x * scale_x plot_y = y * scale_y plot_xlab = xlab plot_ylab = ylab elif _np . ndim ( y ) < 2 : orientation = \"xz\" stream_x = Field . x stream_y = Field . z plot_x = x * scale_x plot_y = z * scale_z plot_xlab = xlab plot_ylab = zlab else : orientation = \"yz\" stream_x = Field . y stream_y = Field . z plot_x = y * scale_y plot_y = z * scale_z plot_xlab = ylab plot_ylab = zlab _ , ax = _plt . subplots () # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"magma\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , Field . n * scale_cb , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , Field . n * scale_cb , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Vector2 ( stream_x , stream_y ) B_2D . calc_norm () _vector_plot2 ( plot_x , plot_y , B_2D , NQ , 1 , 1 , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : Field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / Field . n . T , stream_y . T / Field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / Field . n . T , stream_y . T / Field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ) Contour plot of 3D simulation Parameters: Name Type Description Default plot_x [type] [description] required plot_y [type] [description] required plot_B [type] [description] required Source code in pymagnet/plots/_plot2.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of 3D simulation Args: plot_x ([type]): [description] plot_y ([type]): [description] plot_B ([type]): [description] \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) _ , _ = _plt . subplots () CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2 module, here plotly is used as the backend. Todo Update str and repr for polyhedra Graphic_Cuboid Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size tuple [description]. Defaults to (1, 1, 1). (1, 1, 1) Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords Graphic_Cylinder Generates vertices for a Cylinder Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required length float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords Graphic_Mesh Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs color (float): __init__ ( self , mesh_vectors , start , stop , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required size tuple [description]. Defaults to (1, 1, 1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , mesh_vectors , start , stop , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" self . color = kwargs . pop ( \"color\" , \"C0\" ) self . mesh_vectors = mesh_vectors [ start : stop ] generate_vertices ( self ) Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T # FIXME: Color-Pink trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = \"pink\" ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace Graphic_Sphere Generates vertices for a sphere Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords Polyhedron Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere __init__ ( self , center , size , ** kwargs ) special Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"pink\" ) generate_vertices ( self ) Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass list_polyhedra () Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plot3.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances () reset_polyhedra () Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plot3.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset () surface_slice3 ( ** kwargs ) Calculates and plots magnetic field slices a Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plot3.py def surface_slice3 ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices a Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" import plotly.graph_objects as go # from plotly.subplots import make_subplots reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) xlim = kwargs . pop ( \"xlim\" , 30 ) ylim = kwargs . pop ( \"ylim\" , 30 ) zlim = kwargs . pop ( \"zlim\" , 30 ) if \"xz\" in planes : x , z = _mag . grid2D ( xlim , zlim , NP = num_points ) y = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"xz\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } # Tile for plotting y = _np . tile ( y , x . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) if \"xy\" in planes : x , y = _mag . grid2D ( xlim , ylim , NP = num_points ) z = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"xy\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } # Tile for plotting z = _np . tile ( z , x . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = len ( planes ) < 2 , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) if \"yz\" in planes : y , z = _mag . grid2D ( ylim , zlim , NP = num_points ) x = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"yz\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } x = _np . tile ( x , y . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = len ( planes ) < 2 , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (mm)\" , yaxis_title = \"y (mm)\" , zaxis_title = \"z (mm)\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return cache , data_objects volume_plot ( ** kwargs ) Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plot3.py def volume_plot ( ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" # import plotly.graph_objects as _go # from plotly.subplots import make_subplots reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , 30 ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] cache = {} if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) xlim = kwargs . pop ( \"xlim\" , 30 ) ylim = kwargs . pop ( \"ylim\" , 30 ) zlim = kwargs . pop ( \"zlim\" , 30 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) x , y , z = _mag . grid3D ( xlim , ylim , zlim , NP = num_points ) B = _mag . B_calc_3D ( x , y , z ) data_objects . append ( _generate_volume_data ( x , y , z , B , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , ) ) cache = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (m)\" , yaxis_title = \"y (m)\" , zaxis_title = \"z (m)\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return cache","title":"plots"},{"location":"plots/#plots-module","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of 3D magnets","title":"Plots module"},{"location":"plots/#pymagnet.plots._plot1.plot_1D_field","text":"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet magnet object Must be a Magnet_3D type of magnet, either Prism, Cube, required Kwargs NP (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple z,Bz: arrays of z the distance from the magnet surface, and Bz the magnetic field. Source code in pymagnet/plots/_plot1.py def plot_1D_field ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (magnet object): Must be a Magnet_3D type of magnet, either Prism, Cube, or Cylinder. Kwargs: NP (int): Number of points to calculate. Defaults to 101. Returns: tuple: z,Bz: arrays of z the distance from the magnet surface, and Bz the magnetic field. \"\"\" NP = kwargs . pop ( \"NP\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) if issubclass ( magnet . __class__ , _mag . Cylinder ): mag_boundary = magnet . length / 2 z = _np . linspace ( - 2 * magnet . length + magnet . zc , 2 * magnet . length + magnet . zc , NP ) Bz = _mag . magnetic_field_cylinder_1D ( magnet , z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . zc , z ) Bz [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , _mag . Prism ): mag_boundary = magnet . height / 2 z = _np . linspace ( - 2 * magnet . height + magnet . zc , 2 * magnet . height + magnet . zc , NP ) Bz = _mag . magnetic_field_prism_1D ( magnet , z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . zc , z ) Bz [ mask ] = _np . NaN else : print ( \"Error\" ) return None _ , _ = _plt . subplots () _plt . xlabel ( r \"$z$ (mm)\" ) _plt . ylabel ( r \"$B_z$ (mT)\" ) _plt . plot ( z * 1e3 , Bz * 1e3 , label = \"Cube\" ) _plt . axvline ( x =- mag_boundary * 1e3 + magnet . zc * 1e3 , c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary * 1e3 + magnet . zc * 1e3 , c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return z , Bz Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and","title":"plot_1D_field()"},{"location":"plots/#pymagnet.plots._plot2.arrow","text":"Encodes magnetisation vector for drawing on plots","title":"arrow"},{"location":"plots/#pymagnet.plots._plot2.arrow.__init__","text":"Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot2.magnet_patch","text":"Magnet drawing class Parameters: Name Type Description Default object [type] [description] required","title":"magnet_patch"},{"location":"plots/#pymagnet.plots._plot2.patch","text":"Encodes magnet dimensions for drawing on plots Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required","title":"patch"},{"location":"plots/#pymagnet.plots._plot2.patch.__init__","text":"Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot2.contour_plot_cylinder","text":"Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [type] [description] required Source code in pymagnet/plots/_plot2.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet ([type]): [description] \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (mm)\" ylab = \"z (mm)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , )","title":"contour_plot_cylinder()"},{"location":"plots/#pymagnet.plots._plot2.line_plot_cylinder","text":"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [magnet object] required Source code in pymagnet/plots/_plot2.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet ([magnet object]): \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) _ , _ = _plt . subplots () _plt . plot ( rho * 1 , Bz , label = \"Bz\" ) _plt . plot ( rho * 1 , Br , label = \"Br\" ) _plt . legend ( loc = \"best\" ) _plt . show ()","title":"line_plot_cylinder()"},{"location":"plots/#pymagnet.plots._plot2.param_test_2D","text":"Example plots while varying the size of a permanent magnet This is an example helper function. Parameters: Name Type Description Default width [type] [description] required height [type] [description] required Source code in pymagnet/plots/_plot2.py def param_test_2D ( width , height ): \"\"\"Example plots while varying the size of a permanent magnet This is an example helper function. Args: width ([type]): [description] height ([type]): [description] \"\"\" x = _np . linspace ( - 2 * width , 2 * width , 100 ) y = 1 + height B = _mag . _routines2 . B_calc_2D ( x , y ) plot_2D_line ( x , B ) x , y = _mag . _routines2 . grid2D ( 1.5 * width , height ) B = _mag . _routines2 . B_calc_2D ( x , y ) cmap = \"viridis\" plot_2D_contour ( x , y , B , cmax = 1 , num_levels = 11 , cmap = cmap )","title":"param_test_2D()"},{"location":"plots/#pymagnet.plots._plot2.plot_2D_contour","text":"Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_2D_contour ( x , y , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector_2D]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._poly2D import PolyMagnet scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) _ , ax = _plt . subplots () if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"magma\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = Field . x elif field_component == \"y\" : field_chosen = Field . y else : field_chosen = Field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] * scale_cb cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( x * scale_x , y * scale_y , field_chosen * scale_cb , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( x * scale_x , y * scale_y , field_chosen * scale_cb , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( x , y , Field , NQ , scale_x , scale_y , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = x [:, 0 ] * scale_x ypl = y [ 0 , :] * scale_y cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( Field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( Field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : Field . n . T , \"horizontal\" : Field . x . T , \"vertical\" : Field . y . T , } CS = _plt . streamplot ( xpl , ypl , Field . x . T / Field . n . T , Field . y . T / Field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , Field . x . T / Field . n . T , Field . y . T / Field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax , scale_x , scale_y ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ) * scale_x , ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 )","title":"plot_2D_contour()"},{"location":"plots/#pymagnet.plots._plot2.plot_2D_line","text":"Line Plot of field from 2D magnet Parameters: Name Type Description Default x [array] [assumes in m] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_2D_line ( x , Field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: x ([array]): [assumes in m] Field ([field vector_2D]): [field vector object] \"\"\" scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) _ , ax = _plt . subplots () _plt . plot ( x * scale_x , Field . n * scale_cb , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( x * scale_x , Field . x * scale_cb , label = r \"$B_x$\" ) _plt . plot ( x * scale_x , Field . y * scale_cb , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 )","title":"plot_2D_line()"},{"location":"plots/#pymagnet.plots._plot2.plot_3D_contour","text":"Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector] [field vector object] required Source code in pymagnet/plots/_plot2.py def plot_3D_contour ( x , y , z , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._fields import Vector2 scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_z = kwargs . pop ( \"scale_z\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) zlab = kwargs . pop ( \"zlab\" , f \"z (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = Field . n [ _np . isfinite ( Field . n )] * scale_cb cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if _np . ndim ( z ) < 2 : orientation = \"xy\" stream_x = Field . x stream_y = Field . y plot_x = x * scale_x plot_y = y * scale_y plot_xlab = xlab plot_ylab = ylab elif _np . ndim ( y ) < 2 : orientation = \"xz\" stream_x = Field . x stream_y = Field . z plot_x = x * scale_x plot_y = z * scale_z plot_xlab = xlab plot_ylab = zlab else : orientation = \"yz\" stream_x = Field . y stream_y = Field . z plot_x = y * scale_y plot_y = z * scale_z plot_xlab = ylab plot_ylab = zlab _ , ax = _plt . subplots () # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"magma\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , Field . n * scale_cb , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , Field . n * scale_cb , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Vector2 ( stream_x , stream_y ) B_2D . calc_norm () _vector_plot2 ( plot_x , plot_y , B_2D , NQ , 1 , 1 , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : Field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / Field . n . T , stream_y . T / Field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / Field . n . T , stream_y . T / Field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 )","title":"plot_3D_contour()"},{"location":"plots/#pymagnet.plots._plot2.plot_sub_contour_3D","text":"Contour plot of 3D simulation Parameters: Name Type Description Default plot_x [type] [description] required plot_y [type] [description] required plot_B [type] [description] required Source code in pymagnet/plots/_plot2.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of 3D simulation Args: plot_x ([type]): [description] plot_y ([type]): [description] plot_B ([type]): [description] \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) _ , _ = _plt . subplots () CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2 module, here plotly is used as the backend. Todo Update str and repr for polyhedra","title":"plot_sub_contour_3D()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cuboid","text":"Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Cuboid"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cuboid.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size tuple [description]. Defaults to (1, 1, 1). (1, 1, 1) Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cuboid.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cylinder","text":"Generates vertices for a Cylinder Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required length float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Cylinder"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cylinder.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Cylinder.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Mesh","text":"Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs color (float):","title":"Graphic_Mesh"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Mesh.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required size tuple [description]. Defaults to (1, 1, 1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , mesh_vectors , start , stop , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" self . color = kwargs . pop ( \"color\" , \"C0\" ) self . mesh_vectors = mesh_vectors [ start : stop ]","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Mesh.generate_vertices","text":"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T # FIXME: Color-Pink trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = \"pink\" ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Sphere","text":"Generates vertices for a sphere Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Sphere"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Sphere.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot3.Graphic_Sphere.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): forward_rotation , reverse_rotation = self . _generate_rotation_quaternions () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plot3.Polyhedron","text":"Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere","title":"Polyhedron"},{"location":"plots/#pymagnet.plots._plot3.Polyhedron.__init__","text":"Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plot3.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"pink\" )","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot3.Polyhedron.generate_vertices","text":"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plot3.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plot3.list_polyhedra","text":"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plot3.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances ()","title":"list_polyhedra()"},{"location":"plots/#pymagnet.plots._plot3.reset_polyhedra","text":"Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plot3.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset ()","title":"reset_polyhedra()"},{"location":"plots/#pymagnet.plots._plot3.surface_slice3","text":"Calculates and plots magnetic field slices a Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plot3.py def surface_slice3 ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices a Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" import plotly.graph_objects as go # from plotly.subplots import make_subplots reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) xlim = kwargs . pop ( \"xlim\" , 30 ) ylim = kwargs . pop ( \"ylim\" , 30 ) zlim = kwargs . pop ( \"zlim\" , 30 ) if \"xz\" in planes : x , z = _mag . grid2D ( xlim , zlim , NP = num_points ) y = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"xz\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } # Tile for plotting y = _np . tile ( y , x . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) if \"xy\" in planes : x , y = _mag . grid2D ( xlim , ylim , NP = num_points ) z = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"xy\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } # Tile for plotting z = _np . tile ( z , x . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = len ( planes ) < 2 , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) if \"yz\" in planes : y , z = _mag . grid2D ( ylim , zlim , NP = num_points ) x = _np . array ([ 0 ]) B = _mag . B_calc_3D ( x , y , z ) cache [ \"yz\" ] = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } x = _np . tile ( x , y . shape ) data_objects . append ( _draw_surface_slice ( x , y , z , B , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = len ( planes ) < 2 , ) ) data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (mm)\" , yaxis_title = \"y (mm)\" , zaxis_title = \"z (mm)\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return cache , data_objects","title":"surface_slice3()"},{"location":"plots/#pymagnet.plots._plot3.volume_plot","text":"Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plot3.py def volume_plot ( ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" # import plotly.graph_objects as _go # from plotly.subplots import make_subplots reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , 30 ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] cache = {} if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) xlim = kwargs . pop ( \"xlim\" , 30 ) ylim = kwargs . pop ( \"ylim\" , 30 ) zlim = kwargs . pop ( \"zlim\" , 30 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) x , y , z = _mag . grid3D ( xlim , ylim , zlim , NP = num_points ) B = _mag . B_calc_3D ( x , y , z ) data_objects . append ( _generate_volume_data ( x , y , z , B , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , ) ) cache = { \"x\" : x , \"y\" : y , \"z\" : z , \"B\" : B } if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( x , y , z , B , NA = NA , cone_opacity = cone_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (m)\" , yaxis_title = \"y (m)\" , zaxis_title = \"z (m)\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return cache","title":"volume_plot()"},{"location":"pymagnet/","text":"Main module pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules PI_2 float: Module level PI/2. PI_4 float: Module level PI/4. u0 float: Module level u0, permittivity of free space. __main__ special Example plots fit Fit data for magnetic field models This module demonstrates documentation as specified by the Google Python Style Guide _. Docstrings may extend over multiple lines. Sections are created with a section header and a colon followed by a block of indented text. Examples: Examples can be given using either the Example or Examples sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.py Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. Todo Reimplement all data fits .. _Google Python Style Guide: https://google.github.io/styleguide/pyguide.html magnets special pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Todo Quaternions and arbitrary rotation Conversion between cylindrical and cartesian coordinates plots special pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly.","title":"pymagnet"},{"location":"pymagnet/#main-module","text":"pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules","title":"Main module"},{"location":"pymagnet/#pymagnet.PI_2","text":"float: Module level PI/2.","title":"PI_2"},{"location":"pymagnet/#pymagnet.PI_4","text":"float: Module level PI/4.","title":"PI_4"},{"location":"pymagnet/#pymagnet.u0","text":"float: Module level u0, permittivity of free space.","title":"u0"},{"location":"pymagnet/#pymagnet.__main__","text":"Example plots","title":"__main__"},{"location":"pymagnet/#pymagnet.fit","text":"Fit data for magnetic field models This module demonstrates documentation as specified by the Google Python Style Guide _. Docstrings may extend over multiple lines. Sections are created with a section header and a colon followed by a block of indented text. Examples: Examples can be given using either the Example or Examples sections. Sections support any reStructuredText formatting, including literal blocks:: $ python example_google.py Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. Todo Reimplement all data fits .. _Google Python Style Guide: https://google.github.io/styleguide/pyguide.html","title":"fit"},{"location":"pymagnet/#pymagnet.magnets","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Todo Quaternions and arbitrary rotation Conversion between cylindrical and cartesian coordinates","title":"magnets"},{"location":"pymagnet/#pymagnet.plots","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly.","title":"plots"},{"location":"quaternions/","text":"Quaternion Class Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1 Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts. Quaternion Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ) special Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/magnets/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z ) as_tuple ( self ) Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/magnets/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z euler_to_quaternion ( alpha , beta , gamma ) staticmethod Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz ) gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ) staticmethod Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > 1e-4 : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > 1e-4 : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > 1e-4 : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation get_conjugate ( self ) Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/magnets/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z ) q_angle_from_axis ( theta , vec ) Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion vec_norm ( x , y , z ) staticmethod Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/magnets/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ) special Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/magnets/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z ) as_tuple ( self ) Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/magnets/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z euler_to_quaternion ( alpha , beta , gamma ) staticmethod Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz ) gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ) staticmethod Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > 1e-4 : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > 1e-4 : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > 1e-4 : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation get_conjugate ( self ) Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/magnets/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z ) q_angle_from_axis ( theta , vec ) Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion vec_norm ( x , y , z ) staticmethod Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/magnets/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 )","title":"quaternions"},{"location":"quaternions/#quaternion-class","text":"Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1 Section breaks are created by resuming unindented text. Section breaks are also implicitly created anytime a new section starts.","title":"Quaternion Class"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion","text":"Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications","title":"Quaternion"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.__init__","text":"Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/magnets/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z )","title":"__init__()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.as_tuple","text":"Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/magnets/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z","title":"as_tuple()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.euler_to_quaternion","text":"Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz )","title":"euler_to_quaternion()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.gen_rotation_quaternion","text":"Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > 1e-4 : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > 1e-4 : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > 1e-4 : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation","title":"gen_rotation_quaternion()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.get_conjugate","text":"Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/magnets/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z )","title":"get_conjugate()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.q_angle_from_axis","text":"Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion","title":"q_angle_from_axis()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.vec_norm","text":"Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/magnets/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications","title":"vec_norm()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.__init__","text":"Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/magnets/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z )","title":"__init__()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.as_tuple","text":"Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/magnets/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z","title":"as_tuple()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.euler_to_quaternion","text":"Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz )","title":"euler_to_quaternion()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.gen_rotation_quaternion","text":"Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > 1e-4 : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > 1e-4 : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > 1e-4 : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation","title":"gen_rotation_quaternion()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.get_conjugate","text":"Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/magnets/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z )","title":"get_conjugate()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.q_angle_from_axis","text":"Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/magnets/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion","title":"q_angle_from_axis()"},{"location":"quaternions/#pymagnet.magnets._quaternion.Quaternion.vec_norm","text":"Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/magnets/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 )","title":"vec_norm()"},{"location":"transforms/","text":"Transforms Coordinate System Transforms Scalar Transforms Vector Transforms For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) . Polar to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\] Cylindrical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\] Spherical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\] Misc Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Transforms"},{"location":"transforms/#transforms","text":"","title":"Transforms"},{"location":"transforms/#coordinate-system-transforms","text":"","title":"Coordinate System Transforms"},{"location":"transforms/#scalar-transforms","text":"","title":"Scalar Transforms"},{"location":"transforms/#vector-transforms","text":"For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) .","title":"Vector Transforms"},{"location":"transforms/#polar-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\]","title":"Polar to Cartesian"},{"location":"transforms/#cylindrical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\]","title":"Cylindrical to Cartesian"},{"location":"transforms/#spherical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\]","title":"Spherical to Cartesian"},{"location":"transforms/#misc","text":"Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Misc"}]}