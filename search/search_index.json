{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pymagnet User friendly magnetic field calculations in Python Getting Started Installing pymagnet can be done using python -m pip install pymagnet or conda install -c pdunne pymagnet Pymagnet is a collection of routines to calculate and plot the magnetic field due to arbitrary 2D and 3D objects, like cubes or cylinders, as well as complex non-convex structures stored in STL files. The approach assumes the magnets are uniformly magnetised, and fully transparent to magnetic fields. There are some drawbacks to this compared to Finite Element Methods (FEM), but with the advantage of significantly faster calculations. The current version is written in Python with some speed up using Numpy and Numba , but the backend is being ported to Rust for improved performance. Features This code uses analytical expressions to calculate the magnetic field due to simple magnets: 3D: cubes, prisms (cuboids), cylinders, spheres Cylinder Plots 2D: rectangles, squares, circles 2D contour plot and streamplot of a long bipolar rod and complex compound objects: 3D: Polyhedra stored as STL meshes 2D: Polygons constructed from collections of line elements There are helper functions to plot the data as line, contour, slice, and volume plots, but the underlying data is also accessible. Prerequisites Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy numpy-stl numba matplotlib plotly Warning For spheres, rotate them using alpha, beta, gamma, rather than the magnetisation angles theta and phi, as phi rotations are not implemented. Similarly, for circles, rotate them using alpha, not phi. Examples Examples can be found in the repository . Usage Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 . Licensing Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Home"},{"location":"#pymagnet","text":"User friendly magnetic field calculations in Python","title":"Pymagnet"},{"location":"#getting-started","text":"Installing pymagnet can be done using python -m pip install pymagnet or conda install -c pdunne pymagnet Pymagnet is a collection of routines to calculate and plot the magnetic field due to arbitrary 2D and 3D objects, like cubes or cylinders, as well as complex non-convex structures stored in STL files. The approach assumes the magnets are uniformly magnetised, and fully transparent to magnetic fields. There are some drawbacks to this compared to Finite Element Methods (FEM), but with the advantage of significantly faster calculations. The current version is written in Python with some speed up using Numpy and Numba , but the backend is being ported to Rust for improved performance.","title":"Getting Started"},{"location":"#features","text":"This code uses analytical expressions to calculate the magnetic field due to simple magnets: 3D: cubes, prisms (cuboids), cylinders, spheres Cylinder Plots 2D: rectangles, squares, circles 2D contour plot and streamplot of a long bipolar rod and complex compound objects: 3D: Polyhedra stored as STL meshes 2D: Polygons constructed from collections of line elements There are helper functions to plot the data as line, contour, slice, and volume plots, but the underlying data is also accessible.","title":"Features"},{"location":"#prerequisites","text":"Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy numpy-stl numba matplotlib plotly Warning For spheres, rotate them using alpha, beta, gamma, rather than the magnetisation angles theta and phi, as phi rotations are not implemented. Similarly, for circles, rotate them using alpha, not phi.","title":"Prerequisites"},{"location":"#examples","text":"Examples can be found in the repository .","title":"Examples"},{"location":"#usage","text":"Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 .","title":"Usage"},{"location":"#licensing","text":"Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.","title":"Licensing"},{"location":"#contribution","text":"Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Contribution"},{"location":"equations/","text":"Magnetic Field Equations Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. Many of the relations here come from 2 , those that do not are noted below, or derived. 1D Calculations Cylinder The magnetic field directly above the centre of a cylinder is: Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\] Cuboid While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\] 2D Calculations For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\] Rectangles 2D Magnet Rectangle The magnetic field due to rectangle and magnetised in \\(x\\) is: TODO: $$ B_x = \\frac{\\mu_0 M_r}{2\\pi} $$ \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\] and if magnetised in \\(y\\) is: \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\] Biaxial Rods (Circle) 2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\] Line Elements The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\] Composite Polygons An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet. 3D Calculations The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) . Prisms/Cuboids For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis. Cylinders/Solenoids Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 . Bulirsch's complete elliptic integral See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s) Example Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 ) Spheres Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\] Composite Objects Polyhedra For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements 8 : \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ b + \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 } - z }{ \\sqrt{(a-x)^2 + y^2 + z^2} - z}\\right)\\right.\\\\ & + \\left. \\frac{b}{c} \\ln \\left( \\frac{r - s }{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{\\sqrt{(a-x)^2 + y^2 + z^2} + a}\\right)\\right.\\\\ & + \\left. \\frac{a}{c} \\ln \\left( \\frac{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t}{r - s } \\right) \\right] \\end{align} \\] where \\(r = \\sqrt{x^2 + y^2 + z^2},\\, c = \\sqrt{a^2 + b^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{(x-a) + z + \\sqrt{(x-a)^2 + y^2 + z^2}}{y}\\right)\\right.\\\\ & - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha\\sqrt{B^2 - A^2 - C^2}} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{(\\alpha+\\beta)^2}{\\gamma^2}} + \\frac{\\alpha + \\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{\\beta^2}{\\gamma^2}} + \\frac{\\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{1 + \\frac{b^2}{a^2}}, \\, \\gamma = \\sqrt{\\frac{r^2}{1 + \\frac{b^2}{a^2}} - \\beta^2}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\sqrt{1 + \\frac{b^2}{a^2}},\\, C = z + \\beta\\frac{b}{a}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9 J. Hilton, Computational Modelling of Novel Permanent Magnetic Designs, Ph.D. thesis, Trinity College (Dublin, Ireland), School of Physics, (2005). \u21a9","title":"Magnets"},{"location":"equations/#magnetic-field-equations","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. Many of the relations here come from 2 , those that do not are noted below, or derived.","title":"Magnetic Field Equations"},{"location":"equations/#1d-calculations","text":"","title":"1D Calculations"},{"location":"equations/#cylinder","text":"The magnetic field directly above the centre of a cylinder is: Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\]","title":"Cylinder"},{"location":"equations/#cuboid","text":"While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\]","title":"Cuboid"},{"location":"equations/#2d-calculations","text":"For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\]","title":"2D Calculations"},{"location":"equations/#rectangles","text":"2D Magnet Rectangle The magnetic field due to rectangle and magnetised in \\(x\\) is: TODO: $$ B_x = \\frac{\\mu_0 M_r}{2\\pi} $$ \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\] and if magnetised in \\(y\\) is: \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\]","title":"Rectangles"},{"location":"equations/#biaxial-rods-circle","text":"2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\]","title":"Biaxial Rods (Circle)"},{"location":"equations/#line-elements","text":"The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\]","title":"Line Elements"},{"location":"equations/#composite-polygons","text":"An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet.","title":"Composite Polygons"},{"location":"equations/#3d-calculations","text":"The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) .","title":"3D Calculations"},{"location":"equations/#prismscuboids","text":"For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis.","title":"Prisms/Cuboids"},{"location":"equations/#cylinderssolenoids","text":"Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 .","title":"Cylinders/Solenoids"},{"location":"equations/#bulirschs-complete-elliptic-integral","text":"See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s)","title":"Bulirsch's  complete elliptic integral"},{"location":"equations/#example","text":"Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 )","title":"Example"},{"location":"equations/#spheres","text":"Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\]","title":"Spheres"},{"location":"equations/#composite-objects","text":"","title":"Composite Objects"},{"location":"equations/#polyhedra","text":"For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements 8 : \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ b + \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 } - z }{ \\sqrt{(a-x)^2 + y^2 + z^2} - z}\\right)\\right.\\\\ & + \\left. \\frac{b}{c} \\ln \\left( \\frac{r - s }{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{2\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{\\sqrt{(a-x)^2 + y^2 + z^2} + a}\\right)\\right.\\\\ & + \\left. \\frac{a}{c} \\ln \\left( \\frac{ \\sqrt{(a-x)^2 + y^2 + (b-z)^2} + t}{r - s } \\right) \\right] \\end{align} \\] where \\(r = \\sqrt{x^2 + y^2 + z^2},\\, c = \\sqrt{a^2 + b^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{(x-a) + z + \\sqrt{(x-a)^2 + y^2 + z^2}}{y}\\right)\\right.\\\\ & - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha\\sqrt{B^2 - A^2 - C^2}} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{(\\alpha+\\beta)^2}{\\gamma^2}} + \\frac{\\alpha + \\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\frac{\\beta^2}{\\gamma^2}} + \\frac{\\beta}{\\gamma} \\right)}{\\sqrt{B^2 - A^2 - C^2}} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{1 + \\frac{b^2}{a^2}}, \\, \\gamma = \\sqrt{\\frac{r^2}{1 + \\frac{b^2}{a^2}} - \\beta^2}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\sqrt{1 + \\frac{b^2}{a^2}},\\, C = z + \\beta\\frac{b}{a}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9 J. Hilton, Computational Modelling of Novel Permanent Magnetic Designs, Ph.D. thesis, Trinity College (Dublin, Ireland), School of Physics, (2005). \u21a9","title":"Polyhedra"},{"location":"examples/","text":"Examples Put some examples here.","title":"Examples"},{"location":"examples/#examples","text":"Put some examples here.","title":"Examples"},{"location":"magnets/","text":"Magnets module pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Magnet Base class This private module implements the registry and base magnet classes Magnet Magnet base class Returns: Type Description Magnet magnet base class Registry Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset() __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet_base.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = [] __new__ ( cls , * args , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet_base.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o get_num_instances ( Print_Val = False ) classmethod Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances ) print_instances () classmethod Prints class instantiations Source code in pymagnet/magnets/_magnet_base.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance ) reset () classmethod Removes all instances from registry. Source code in pymagnet/magnets/_magnet_base.py @classmethod def reset ( cls ): \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = [] list_magnets () Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet_base.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances () reset_magnets () Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet_base.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2D import Magnet_2D , Rectangle , Square , Circle from ._polygon2D import PolyMagnet from ._magnet3D import Magnet_3D , Prism , Cube , Cylinder , Sphere from ._polygon3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet_2D , Rectangle , Square , Circle , PolyMagnet , Magnet_3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet. magnetic_field_cylinder_1D ( magnet , z ) Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3D import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . center [ 2 ] zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) Bz = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) Bz *= Jr / 2 data = Field1 ( Bz ) return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None magnetic_field_prism_1D ( magnet , z ) Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, one of Prism, Cube, or Cylinder required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, one of Prism, Cube, or Cylinder z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr z_local = _np . asarray ( z ) - c - magnet . center [ 2 ] ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) Bz = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) Bz *= Jr / PI field = Field1 ( Bz ) return field else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None 2D Magnet classes This private module implements the rectangle and square 2D magnet classes Todo Add del method for removing strong ref in class instance list Circle Circle Magnet Class Parameters: Name Type Description Default radius [float] magnet radius [m] (defaults to 10) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: center: magnet centre (Point2 object) [default Point2(0.0, 0.0)] calcB ( self , x , y ) Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2D.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ..utils._conversions import cart2pol , vector_pol2cart from ..utils._routines2D import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # xci, yci = rotate_points_2D( # _np.array([self.xc]), _np.array([self.yc]), self.alpha_radians # ) rho , phi = cart2pol ( xi , yi ) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . center [ 0 ], y - self . center [ 1 ]) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By get_Jr ( self ) Returns Magnetisation components [Jr] Returns: Type Description ndarray [Jr] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jr] Returns: ndarray: [Jr] \"\"\" return _np . array ([ self . Jr ]) Magnet_2D 2D Magnet class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or numpy array]: center of magnet, defaults to numpy.array([0.0, 0.0]) get_center ( self ) Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center get_orientation ( self ) Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha Rectangle Rectangle Magnet Class Parameters: Name Type Description Default width [float] magnet width [m] (defaults to 20) required height [float] magnet height [m] (defaults to 40) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] calcB ( self , x , y ) Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required Returns: Type Description Vector2 magnetic field vector Source code in pymagnet/magnets/_magnet2D.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (float/array): x co-ordinates y (float/array): y co-ordinates Returns: Vector2: magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx / self . Jr ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi , yi ) Bty = self . _calcBy_mag_x ( xi , yi ) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) By = self . _calcBy_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy / self . Jr ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : Btx = self . _calcBx_mag_y ( xi , yi ) Bty = self . _calcBy_mag_y ( xi , yi ) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) By += self . _calcBy_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) return Bx , By get_Jr ( self ) Returns Magnetisation components [Jx, Jy] Returns: Type Description J[ndarray] [Jx, Jy] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jx, Jy] Returns: J[ndarray]: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ]) get_size ( self ) Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, height] Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ]) Square Square Magnet Class Parameters: Name Type Description Default width [float] magnet side length [m] (defaults to 20) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] 2D Polygon Magnet class Todo Add del method for removing strong ref in class instance list Line [summary] Parameters: Name Type Description Default object [type] [description] required calcB ( self , x , y ) [summary] Parameters: Name Type Description Default x [type] [description] required y [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py def calcB ( self , x , y ): \"\"\"[summary] Args: x ([type]): [description] y ([type]): [description] Returns: [type]: [description] \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . beta_rad ) > self . tol : xt , yt = rotate_points_2D ( x - self . xc , y - self . yc , 2 * PI - self . beta_rad ) Btx , Bty = _sheet_field ( xt , yt , self . length / 2 , self . K ) Bx , By = rotate_points_2D ( Btx , Bty , self . beta_rad ) else : Bx , By = _sheet_field ( x - self . xc , y - self . yc , self . length / 2 , self . K ) return Bx , By get_center ( self ) Returns line center Returns: Type Description ndarray center (x,y) Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns line center Returns: ndarray: center (x,y) \"\"\" return self . center LineUtils [summary] Parameters: Name Type Description Default object [type] [description] required Returns: Type Description [type] [description] line_center ( ver1 , ver2 ) staticmethod [summary] Parameters: Name Type Description Default ver1 [type] [description] required ver2 [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def line_center ( ver1 , ver2 ): \"\"\"[summary] Args: ver1 ([type]): [description] ver2 ([type]): [description] Returns: [type]: [description] \"\"\" xc = ( ver1 [ 0 ] + ver2 [ 0 ]) / 2 yc = ( ver1 [ 1 ] + ver2 [ 1 ]) / 2 return _np . array ([ xc , yc ]) signed_area ( polygon ) staticmethod Calculates signed area, Parameters: Name Type Description Default polygon [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def signed_area ( polygon ): \"\"\"Calculates signed area, Args: polygon ([type]): [description] Returns: [type]: [description] \"\"\" j = 1 NP = polygon . num_vertices () area = 0 norm = _np . empty ([ NP , 2 ]) center = _np . empty ([ NP , 2 ]) beta = _np . empty ( NP ) # angle w.r.t. y axis length = _np . empty ( NP ) for i in range ( NP ): j = j % NP area += ( polygon . vertices [ j ][ 0 ] - polygon . vertices [ i ][ 0 ]) * ( polygon . vertices [ j ][ 1 ] + polygon . vertices [ i ][ 1 ] ) norm [ i , :], length [ i ] = LineUtils . unit_norm ( polygon . vertices [ i ], polygon . vertices [ j ] ) center [ i , :] = LineUtils . line_center ( polygon . vertices [ i ], polygon . vertices [ j ] ) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points if area < 0 : norm *= - 1 beta [:] = _np . rad2deg ( _np . arctan2 ( norm [:, 1 ], norm [:, 0 ])) return area / 2.0 , norm , beta , length , center unit_norm ( ver1 , ver2 , clockwise = True ) staticmethod [summary] Parameters: Name Type Description Default ver1 [type] [description] required ver2 [type] [description] required clockwise bool [description]. Defaults to True. True Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def unit_norm ( ver1 , ver2 , clockwise = True ): \"\"\"[summary] Args: ver1 ([type]): [description] ver2 ([type]): [description] clockwise (bool, optional): [description]. Defaults to True. Returns: [type]: [description] \"\"\" dx = ver1 [ 0 ] - ver2 [ 0 ] dy = ver1 [ 1 ] - ver2 [ 1 ] # Clockwise winding of points: if clockwise : norm = _np . array ([ dy , - dx ]) else : norm = _np . array ([ - dy , dx ]) length = _np . linalg . norm ( norm ) norm = norm / length return norm , length Polygon [summary] Parameters: Name Type Description Default object [type] [description] required append ( self , vertex ) [summary] Parameters: Name Type Description Default vertex [type] [description] required Source code in pymagnet/magnets/_polygon2D.py def append ( self , vertex ): \"\"\"[summary] Args: vertex ([type]): [description] \"\"\" if len ( vertex ) != 2 : print ( \"Error\" ) if type ( vertex ) == tuple : self . vertices . append ( vertex ) elif len ( vertex ) == 2 : self . vertices . append ( tuple ( vertex )) self . set_center () gen_polygon ( N = 6 , center = ( 0 , 0 ), alpha = 0 , ** kwargs ) staticmethod [summary] Parameters: Name Type Description Default N int [description]. Defaults to 6. 6 apo int [description]. Defaults to 1. required center tuple [description]. Defaults to (0,0). (0, 0) offset int [description]. Defaults to 0. required Exceptions: Type Description Exception [description] Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def gen_polygon ( N = 6 , center = ( 0 , 0 ), alpha = 0 , ** kwargs ): \"\"\"[summary] Args: N (int, optional): [description]. Defaults to 6. apo (int, optional): [description]. Defaults to 1. center (tuple, optional): [description]. Defaults to (0,0). offset (int, optional): [description]. Defaults to 0. Raises: Exception: [description] Returns: [type]: [description] \"\"\" N = int ( N ) if N < 3 : raise Exception ( \"Error, N must be > 2.\" ) apothem = kwargs . pop ( \"apothem\" , None ) length = kwargs . pop ( \"length\" , None ) radius = kwargs . pop ( \"radius\" , None ) radius = Polygon . check_radius ( N , apothem , length , radius ) k = _np . arange ( 0 , N , 1 ) xc = center [ 0 ] yc = center [ 1 ] def f ( N ): if N % 2 == 0 : return PI / N + _np . deg2rad ( alpha ) else : return PI / N + PI + _np . deg2rad ( alpha ) xv = xc + radius * _np . sin ( 2 * PI * k / N + f ( N )) yv = yc + radius * _np . cos ( 2 * PI * k / N + f ( N )) poly_verts = _np . vstack (( xv , yv )) . T . tolist () return poly_verts num_vertices ( self ) [summary] Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py def num_vertices ( self ): \"\"\"[summary] Returns: [type]: [description] \"\"\" return len ( self . vertices ) set_center ( self ) [summary] Source code in pymagnet/magnets/_polygon2D.py def set_center ( self ): \"\"\"[summary]\"\"\" self . center = _np . mean ( _np . asarray ( self . vertices ), axis = 0 ) PolyMagnet 2D Magnet Polygon class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or Point2]: center of magnet, defaults to Point2(0.0, 0.0) get_center ( self ) Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center get_orientation ( self ) Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_polygon2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha Mesh Mesh Magnet Class. calcB ( self , x , y , z ) Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_polygon3D.py def calcB ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" B = self . _calcB_local ( x , y , z ) return B . x , B . y , B . z calcB_triangle ( self , triangle , Jr , x , y , z , i ) Calculates the magnetic field due to a triangle Parameters: Name Type Description Default triangle ndarray Vertices of a triangle required Jr float Remnant magnetisation component normal to triangle required x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple Bx, By, Bz magnetic field components Source code in pymagnet/magnets/_polygon3D.py def calcB_triangle ( self , triangle , Jr , x , y , z , i ): \"\"\"Calculates the magnetic field due to a triangle Args: triangle (ndarray): Vertices of a triangle Jr (float): Remnant magnetisation component normal to triangle x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: Bx, By, Bz magnetic field components \"\"\" ( total_rotation , rotated_triangle , offset , RA_triangle1 , RA_triangle2 , ) = _rotate_triangle ( triangle , Jr ) # Prepare points and quaternion pos_vec = Quaternion . _prepare_vector ( x , y , z ) # Rotate points x_rot , y_rot , z_rot = total_rotation * pos_vec norm1 = norm_plane ( triangle ) if _np . allclose ( norm1 , [ 0 , - 1 , 0 ], atol = ALIGN_CUTOFF ) and Jr < 0 : RA_triangle1 , RA_triangle2 = RA_triangle2 , RA_triangle1 Btx , Bty , Btz = self . _calcB_2_triangles ( RA_triangle1 , RA_triangle2 , Jr , x_rot - offset [ 0 ], y_rot - offset [ 1 ], z_rot - offset [ 2 ], ) Bvec = Quaternion . _prepare_vector ( Btx , Bty , Btz ) Bx , By , Bz = total_rotation . get_conjugate () * Bvec return Bx , By , Bz , rotated_triangle , offset , total_rotation get_center ( self ) Returns magnet center Returns: Type Description ndarray magnet center Source code in pymagnet/magnets/_polygon3D.py def get_center ( self ): \"\"\"Returns magnet center Returns: ndarray: magnet center \"\"\" return self . center get_Jr ( self ) Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy, Jz] Source code in pymagnet/magnets/_polygon3D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy, Jz] \"\"\" return self . J size ( self ) Returns magnet dimesions Returns: Type Description size (ndarray) numpy array [width, depth, height] Source code in pymagnet/magnets/_polygon3D.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size (ndarray): numpy array [width, depth, height] \"\"\" pass","title":"magnets"},{"location":"magnets/#magnets-module","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Magnet Base class This private module implements the registry and base magnet classes","title":"Magnets module"},{"location":"magnets/#pymagnet.magnets._magnet_base.Magnet","text":"Magnet base class Returns: Type Description Magnet magnet base class","title":"Magnet"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry","text":"Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset()","title":"Registry"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet_base.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = []","title":"__init_subclass__()"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet_base.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o","title":"__new__()"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry.get_num_instances","text":"Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances )","title":"get_num_instances()"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry.print_instances","text":"Prints class instantiations Source code in pymagnet/magnets/_magnet_base.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance )","title":"print_instances()"},{"location":"magnets/#pymagnet.magnets._magnet_base.Registry.reset","text":"Removes all instances from registry. Source code in pymagnet/magnets/_magnet_base.py @classmethod def reset ( cls ): \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = []","title":"reset()"},{"location":"magnets/#pymagnet.magnets._magnet_base.list_magnets","text":"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet_base.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances ()","title":"list_magnets()"},{"location":"magnets/#pymagnet.magnets._magnet_base.reset_magnets","text":"Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet_base.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2D import Magnet_2D , Rectangle , Square , Circle from ._polygon2D import PolyMagnet from ._magnet3D import Magnet_3D , Prism , Cube , Cylinder , Sphere from ._polygon3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet_2D , Rectangle , Square , Circle , PolyMagnet , Magnet_3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet.","title":"reset_magnets()"},{"location":"magnets/#pymagnet.magnets._magnet1D.magnetic_field_cylinder_1D","text":"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Parameters: Name Type Description Default magnet_object [type] [description] required Jr [type] [description] required z [type] [description] required Returns: Type Description [float] Bz Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cylinder along its axial symmetry center. Args: magnet_object ([type]): [description] Jr ([type]): [description] z ([type]): [description] Returns: [float]: Bz \"\"\" from ._magnet3D import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . center [ 2 ] zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) Bz = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) Bz *= Jr / 2 data = Field1 ( Bz ) return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None","title":"magnetic_field_cylinder_1D()"},{"location":"magnets/#pymagnet.magnets._magnet1D.magnetic_field_prism_1D","text":"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, one of Prism, Cube, or Cylinder required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, one of Prism, Cube, or Cylinder z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr z_local = _np . asarray ( z ) - c - magnet . center [ 2 ] ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) Bz = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) Bz *= Jr / PI field = Field1 ( Bz ) return field else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None 2D Magnet classes This private module implements the rectangle and square 2D magnet classes Todo Add del method for removing strong ref in class instance list","title":"magnetic_field_prism_1D()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Circle","text":"Circle Magnet Class Parameters: Name Type Description Default radius [float] magnet radius [m] (defaults to 10) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: center: magnet centre (Point2 object) [default Point2(0.0, 0.0)]","title":"Circle"},{"location":"magnets/#pymagnet.magnets._magnet2D.Circle.calcB","text":"Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2D.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ..utils._conversions import cart2pol , vector_pol2cart from ..utils._routines2D import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # xci, yci = rotate_points_2D( # _np.array([self.xc]), _np.array([self.yc]), self.alpha_radians # ) rho , phi = cart2pol ( xi , yi ) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . center [ 0 ], y - self . center [ 1 ]) Brho , Bphi = self . _calcB_polar ( rho , phi ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Circle.get_Jr","text":"Returns Magnetisation components [Jr] Returns: Type Description ndarray [Jr] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jr] Returns: ndarray: [Jr] \"\"\" return _np . array ([ self . Jr ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Magnet_2D","text":"2D Magnet class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or numpy array]: center of magnet, defaults to numpy.array([0.0, 0.0])","title":"Magnet_2D"},{"location":"magnets/#pymagnet.magnets._magnet2D.Magnet_2D.get_center","text":"Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center","title":"get_center()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Magnet_2D.get_orientation","text":"Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha","title":"get_orientation()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Rectangle","text":"Rectangle Magnet Class Parameters: Name Type Description Default width [float] magnet width [m] (defaults to 20) required height [float] magnet height [m] (defaults to 40) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees]","title":"Rectangle"},{"location":"magnets/#pymagnet.magnets._magnet2D.Rectangle.calcB","text":"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required Returns: Type Description Vector2 magnetic field vector Source code in pymagnet/magnets/_magnet2D.py def calcB ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (float/array): x co-ordinates y (float/array): y co-ordinates Returns: Vector2: magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx / self . Jr ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi , yi ) Bty = self . _calcBy_mag_x ( xi , yi ) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) By = self . _calcBy_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy / self . Jr ) > Magnet_2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet_2D . tol : Btx = self . _calcBx_mag_y ( xi , yi ) Bty = self . _calcBy_mag_y ( xi , yi ) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) By += self . _calcBy_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) return Bx , By","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Rectangle.get_Jr","text":"Returns Magnetisation components [Jx, Jy] Returns: Type Description J[ndarray] [Jx, Jy] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation components [Jx, Jy] Returns: J[ndarray]: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ])","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Rectangle.get_size","text":"Returns magnet dimesions Returns: Type Description size[ndarray] numpy array [width, height] Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns magnet dimesions Returns: size[ndarray]: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ])","title":"get_size()"},{"location":"magnets/#pymagnet.magnets._magnet2D.Square","text":"Square Magnet Class Parameters: Name Type Description Default width [float] magnet side length [m] (defaults to 20) required Jr [float] Remnant magnetisation [T] (defaults to 1.0) required Optional Arguments: centre: magnet centre (Point2 object) [default Point2(0.0, 0.0)] phi: Angle between magnetisation and x-axis [default 90.0 degrees] 2D Polygon Magnet class Todo Add del method for removing strong ref in class instance list","title":"Square"},{"location":"magnets/#pymagnet.magnets._polygon2D.Line","text":"[summary] Parameters: Name Type Description Default object [type] [description] required","title":"Line"},{"location":"magnets/#pymagnet.magnets._polygon2D.Line.calcB","text":"[summary] Parameters: Name Type Description Default x [type] [description] required y [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py def calcB ( self , x , y ): \"\"\"[summary] Args: x ([type]): [description] y ([type]): [description] Returns: [type]: [description] \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . beta_rad ) > self . tol : xt , yt = rotate_points_2D ( x - self . xc , y - self . yc , 2 * PI - self . beta_rad ) Btx , Bty = _sheet_field ( xt , yt , self . length / 2 , self . K ) Bx , By = rotate_points_2D ( Btx , Bty , self . beta_rad ) else : Bx , By = _sheet_field ( x - self . xc , y - self . yc , self . length / 2 , self . K ) return Bx , By","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._polygon2D.Line.get_center","text":"Returns line center Returns: Type Description ndarray center (x,y) Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns line center Returns: ndarray: center (x,y) \"\"\" return self . center","title":"get_center()"},{"location":"magnets/#pymagnet.magnets._polygon2D.LineUtils","text":"[summary] Parameters: Name Type Description Default object [type] [description] required Returns: Type Description [type] [description]","title":"LineUtils"},{"location":"magnets/#pymagnet.magnets._polygon2D.LineUtils.line_center","text":"[summary] Parameters: Name Type Description Default ver1 [type] [description] required ver2 [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def line_center ( ver1 , ver2 ): \"\"\"[summary] Args: ver1 ([type]): [description] ver2 ([type]): [description] Returns: [type]: [description] \"\"\" xc = ( ver1 [ 0 ] + ver2 [ 0 ]) / 2 yc = ( ver1 [ 1 ] + ver2 [ 1 ]) / 2 return _np . array ([ xc , yc ])","title":"line_center()"},{"location":"magnets/#pymagnet.magnets._polygon2D.LineUtils.signed_area","text":"Calculates signed area, Parameters: Name Type Description Default polygon [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def signed_area ( polygon ): \"\"\"Calculates signed area, Args: polygon ([type]): [description] Returns: [type]: [description] \"\"\" j = 1 NP = polygon . num_vertices () area = 0 norm = _np . empty ([ NP , 2 ]) center = _np . empty ([ NP , 2 ]) beta = _np . empty ( NP ) # angle w.r.t. y axis length = _np . empty ( NP ) for i in range ( NP ): j = j % NP area += ( polygon . vertices [ j ][ 0 ] - polygon . vertices [ i ][ 0 ]) * ( polygon . vertices [ j ][ 1 ] + polygon . vertices [ i ][ 1 ] ) norm [ i , :], length [ i ] = LineUtils . unit_norm ( polygon . vertices [ i ], polygon . vertices [ j ] ) center [ i , :] = LineUtils . line_center ( polygon . vertices [ i ], polygon . vertices [ j ] ) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points if area < 0 : norm *= - 1 beta [:] = _np . rad2deg ( _np . arctan2 ( norm [:, 1 ], norm [:, 0 ])) return area / 2.0 , norm , beta , length , center","title":"signed_area()"},{"location":"magnets/#pymagnet.magnets._polygon2D.LineUtils.unit_norm","text":"[summary] Parameters: Name Type Description Default ver1 [type] [description] required ver2 [type] [description] required clockwise bool [description]. Defaults to True. True Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def unit_norm ( ver1 , ver2 , clockwise = True ): \"\"\"[summary] Args: ver1 ([type]): [description] ver2 ([type]): [description] clockwise (bool, optional): [description]. Defaults to True. Returns: [type]: [description] \"\"\" dx = ver1 [ 0 ] - ver2 [ 0 ] dy = ver1 [ 1 ] - ver2 [ 1 ] # Clockwise winding of points: if clockwise : norm = _np . array ([ dy , - dx ]) else : norm = _np . array ([ - dy , dx ]) length = _np . linalg . norm ( norm ) norm = norm / length return norm , length","title":"unit_norm()"},{"location":"magnets/#pymagnet.magnets._polygon2D.Polygon","text":"[summary] Parameters: Name Type Description Default object [type] [description] required","title":"Polygon"},{"location":"magnets/#pymagnet.magnets._polygon2D.Polygon.append","text":"[summary] Parameters: Name Type Description Default vertex [type] [description] required Source code in pymagnet/magnets/_polygon2D.py def append ( self , vertex ): \"\"\"[summary] Args: vertex ([type]): [description] \"\"\" if len ( vertex ) != 2 : print ( \"Error\" ) if type ( vertex ) == tuple : self . vertices . append ( vertex ) elif len ( vertex ) == 2 : self . vertices . append ( tuple ( vertex )) self . set_center ()","title":"append()"},{"location":"magnets/#pymagnet.magnets._polygon2D.Polygon.gen_polygon","text":"[summary] Parameters: Name Type Description Default N int [description]. Defaults to 6. 6 apo int [description]. Defaults to 1. required center tuple [description]. Defaults to (0,0). (0, 0) offset int [description]. Defaults to 0. required Exceptions: Type Description Exception [description] Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py @staticmethod def gen_polygon ( N = 6 , center = ( 0 , 0 ), alpha = 0 , ** kwargs ): \"\"\"[summary] Args: N (int, optional): [description]. Defaults to 6. apo (int, optional): [description]. Defaults to 1. center (tuple, optional): [description]. Defaults to (0,0). offset (int, optional): [description]. Defaults to 0. Raises: Exception: [description] Returns: [type]: [description] \"\"\" N = int ( N ) if N < 3 : raise Exception ( \"Error, N must be > 2.\" ) apothem = kwargs . pop ( \"apothem\" , None ) length = kwargs . pop ( \"length\" , None ) radius = kwargs . pop ( \"radius\" , None ) radius = Polygon . check_radius ( N , apothem , length , radius ) k = _np . arange ( 0 , N , 1 ) xc = center [ 0 ] yc = center [ 1 ] def f ( N ): if N % 2 == 0 : return PI / N + _np . deg2rad ( alpha ) else : return PI / N + PI + _np . deg2rad ( alpha ) xv = xc + radius * _np . sin ( 2 * PI * k / N + f ( N )) yv = yc + radius * _np . cos ( 2 * PI * k / N + f ( N )) poly_verts = _np . vstack (( xv , yv )) . T . tolist () return poly_verts","title":"gen_polygon()"},{"location":"magnets/#pymagnet.magnets._polygon2D.Polygon.num_vertices","text":"[summary] Returns: Type Description [type] [description] Source code in pymagnet/magnets/_polygon2D.py def num_vertices ( self ): \"\"\"[summary] Returns: [type]: [description] \"\"\" return len ( self . vertices )","title":"num_vertices()"},{"location":"magnets/#pymagnet.magnets._polygon2D.Polygon.set_center","text":"[summary] Source code in pymagnet/magnets/_polygon2D.py def set_center ( self ): \"\"\"[summary]\"\"\" self . center = _np . mean ( _np . asarray ( self . vertices ), axis = 0 )","title":"set_center()"},{"location":"magnets/#pymagnet.magnets._polygon2D.PolyMagnet","text":"2D Magnet Polygon class. Parameters: Name Type Description Default width [float] magnet width required height [float] magnet height required Jr [float] Remnant magnetisation required **kwargs Arbitrary keyword arguments. required Kwargs center [Tuple(float, float), or Point2]: center of magnet, defaults to Point2(0.0, 0.0)","title":"PolyMagnet"},{"location":"magnets/#pymagnet.magnets._polygon2D.PolyMagnet.get_center","text":"Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center","title":"get_center()"},{"location":"magnets/#pymagnet.magnets._polygon2D.PolyMagnet.get_orientation","text":"Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_polygon2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha","title":"get_orientation()"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh","text":"Mesh Magnet Class.","title":"Mesh"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh.calcB","text":"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_polygon3D.py def calcB ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" B = self . _calcB_local ( x , y , z ) return B . x , B . y , B . z","title":"calcB()"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh.calcB_triangle","text":"Calculates the magnetic field due to a triangle Parameters: Name Type Description Default triangle ndarray Vertices of a triangle required Jr float Remnant magnetisation component normal to triangle required x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple Bx, By, Bz magnetic field components Source code in pymagnet/magnets/_polygon3D.py def calcB_triangle ( self , triangle , Jr , x , y , z , i ): \"\"\"Calculates the magnetic field due to a triangle Args: triangle (ndarray): Vertices of a triangle Jr (float): Remnant magnetisation component normal to triangle x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: Bx, By, Bz magnetic field components \"\"\" ( total_rotation , rotated_triangle , offset , RA_triangle1 , RA_triangle2 , ) = _rotate_triangle ( triangle , Jr ) # Prepare points and quaternion pos_vec = Quaternion . _prepare_vector ( x , y , z ) # Rotate points x_rot , y_rot , z_rot = total_rotation * pos_vec norm1 = norm_plane ( triangle ) if _np . allclose ( norm1 , [ 0 , - 1 , 0 ], atol = ALIGN_CUTOFF ) and Jr < 0 : RA_triangle1 , RA_triangle2 = RA_triangle2 , RA_triangle1 Btx , Bty , Btz = self . _calcB_2_triangles ( RA_triangle1 , RA_triangle2 , Jr , x_rot - offset [ 0 ], y_rot - offset [ 1 ], z_rot - offset [ 2 ], ) Bvec = Quaternion . _prepare_vector ( Btx , Bty , Btz ) Bx , By , Bz = total_rotation . get_conjugate () * Bvec return Bx , By , Bz , rotated_triangle , offset , total_rotation","title":"calcB_triangle()"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh.get_center","text":"Returns magnet center Returns: Type Description ndarray magnet center Source code in pymagnet/magnets/_polygon3D.py def get_center ( self ): \"\"\"Returns magnet center Returns: ndarray: magnet center \"\"\" return self . center","title":"get_center()"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh.get_Jr","text":"Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy, Jz] Source code in pymagnet/magnets/_polygon3D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy, Jz] \"\"\" return self . J","title":"get_Jr()"},{"location":"magnets/#pymagnet.magnets._polygon3D.Mesh.size","text":"Returns magnet dimesions Returns: Type Description size (ndarray) numpy array [width, depth, height] Source code in pymagnet/magnets/_polygon3D.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size (ndarray): numpy array [width, depth, height] \"\"\" pass","title":"size()"},{"location":"methods/","text":"Methods Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calcuated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot. Classes At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes. Magnet Classes The hierarcy of magnet classes is (click image for high resolution view) Quaternion Class This is a convenience class for performing rotations of points/vectors about arbitrary axes. Plot Methods Draw Magnets on Plot","title":"Methods"},{"location":"methods/#methods","text":"Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calcuated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot.","title":"Methods"},{"location":"methods/#classes","text":"At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes.","title":"Classes"},{"location":"methods/#magnet-classes","text":"The hierarcy of magnet classes is (click image for high resolution view)","title":"Magnet Classes"},{"location":"methods/#quaternion-class","text":"This is a convenience class for performing rotations of points/vectors about arbitrary axes.","title":"Quaternion Class"},{"location":"methods/#plot-methods","text":"","title":"Plot Methods"},{"location":"methods/#draw-magnets-on-plot","text":"","title":"Draw Magnets on Plot"},{"location":"plots/","text":"Plots module pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of cubes, cuboids, and cylinders plot_1D_field ( magnet , unit = 'mm' , ** kwargs ) Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet magnet object Must be a Magnet_3D type of magnet, either Prism, Cube, required Kwargs num_points (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). Source code in pymagnet/plots/_plot1D.py def plot_1D_field ( magnet , unit = \"mm\" , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (magnet object): Must be a Magnet_3D type of magnet, either Prism, Cube, or Cylinder. Kwargs: num_points (int): Number of points to calculate. Defaults to 101. Returns: tuple: Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). \"\"\" num_points = kwargs . pop ( \"num_points\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) points = Point_Array1 ( _np . zeros ( num_points ), unit = unit ) if issubclass ( magnet . __class__ , Cylinder ): mag_boundary = magnet . length / 2 points . z = _np . linspace ( - 2 * magnet . length + magnet . center [ 2 ], 2 * magnet . length + magnet . center [ 2 ], num_points , ) field = magnetic_field_cylinder_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , Prism ): mag_boundary = magnet . height / 2 points . z = _np . linspace ( - 2 * magnet . height + magnet . center [ 2 ], 2 * magnet . height + magnet . center [ 2 ], num_points , ) field = magnetic_field_prism_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN else : print ( \"Error\" ) return None _ , _ = _plt . subplots () unit_length = \"(\" + points . unit + \")\" field_unit = \"(\" + field . unit + \")\" _plt . xlabel ( r \"$z$ \" + unit_length ) _plt . ylabel ( r \"$B_z$ \" + field_unit ) _plt . plot ( points . z , field . z ) _plt . axvline ( x =- mag_boundary + magnet . center [ 2 ], c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary + magnet . center [ 2 ], c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return points , field Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and arrow Encodes magnetisation vector for drawing on plots __init__ ( self , x , y , dx , dy , transform , width = 3 ) special Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width magnet_patch Magnet drawing class Parameters: Name Type Description Default object [type] [description] required patch Encodes magnet dimensions for drawing on plots Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required __init__ ( self , x , y , width , height , transform , type ) special Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type contour_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [type] [description] required Source code in pymagnet/plots/_plot2D.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet ([type]): [description] \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (m)\" ylab = \"z (m)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , ) line_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [magnet object] required Source code in pymagnet/plots/_plot2D.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet ([magnet object]): \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) _ , _ = _plt . subplots () _plt . plot ( rho * 1 , Bz , label = r \"$B_z$\" ) _plt . plot ( rho * 1 , Br , label = r \"$B_r$\" ) _plt . legend ( loc = \"best\" ) _plt . show () param_test_2D ( width , height ) Example plots while varying the size of a permanent magnet This is an example helper function. Parameters: Name Type Description Default width [type] [description] required height [type] [description] required Source code in pymagnet/plots/_plot2D.py def param_test_2D ( width , height ): \"\"\"Example plots while varying the size of a permanent magnet This is an example helper function. Args: width ([type]): [description] height ([type]): [description] \"\"\" x = _np . linspace ( - 2 * width , 2 * width , 100 ) y = 1 + height B = _mag . _routines2 . B_calc_2D ( x , y ) plot_2D_line ( x , B ) x , y = _mag . _routines2 . grid2D ( 1.5 * width , height ) B = _mag . _routines2 . B_calc_2D ( x , y ) cmap = \"viridis\" plot_2D_contour ( x , y , B , cmax = 1 , num_levels = 11 , cmap = cmap ) plot_2D_contour ( point_array , field , ** kwargs ) Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_2D_contour ( point_array , field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] field ([field vector_2D]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._polygon2D import PolyMagnet show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"y ( { point_array . unit } )\" ) clab = kwargs . pop ( \"clab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) _ , ax = _plt . subplots () if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"magma\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = field . x elif field_component == \"y\" : field_chosen = field . y else : field_chosen = field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( point_array . x , point_array . y , field_chosen , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( point_array . x , point_array . y , field_chosen , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( point_array , field , NQ , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = point_array . x [:, 0 ] ypl = point_array . y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : field . x . T , \"vertical\" : field . y . T , } CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ), ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) plot_2D_line ( point_array , field , ** kwargs ) Line Plot of field from 2D magnet Parameters: Name Type Description Default x [array] [assumes in m] required field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_2D_line ( point_array , field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: x ([array]): [assumes in m] field ([field vector_2D]): [field vector object] \"\"\" xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) _ , ax = _plt . subplots () _plt . plot ( point_array . x , field . n , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( point_array . x , field . x , label = r \"$B_x$\" ) _plt . plot ( point_array . x , field . y , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 ) # _plt.savefig('contour_plot.pdf', dpi=300) plot_3D_contour ( points , field , plane , ** kwargs ) Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required field [field vector] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_3D_contour ( points , field , plane , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] field ([field vector]): [field vector object] \"\"\" # import matplotlib.cm as _cm axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , \"x (\" + points . unit + \")\" ) ylab = kwargs . pop ( \"ylab\" , \"y (\" + points . unit + \")\" ) zlab = kwargs . pop ( \"zlab\" , \"z (\" + points . unit + \")\" ) clab = kwargs . pop ( \"clab\" , \"B (\" + field . unit + \")\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = field . n [ _np . isfinite ( field . n )] cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if plane . lower () == \"xy\" : plot_x = points . x plot_y = points . y plot_xlab = xlab plot_ylab = ylab stream_x = field . x stream_y = field . z elif plane . lower () == \"xz\" : stream_x = field . x stream_y = field . z plot_x = points . x plot_y = points . z plot_xlab = xlab plot_ylab = zlab else : stream_x = field . y stream_y = field . z plot_x = points . y plot_y = points . z plot_xlab = ylab plot_ylab = zlab _ , ax = _plt . subplots () # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"magma\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , field . n , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , field . n , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Field2 ( stream_x , stream_y , unit = field . unit ) B_2D . calc_norm () points_2D = Point_Array2 ( plot_x , plot_y , unit = points . unit ) _vector_plot2 ( points_2D , B_2D , NQ , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ) Contour plot of 3D simulation Parameters: Name Type Description Default plot_x [type] [description] required plot_y [type] [description] required plot_B [type] [description] required Source code in pymagnet/plots/_plot2D.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of 3D simulation Args: plot_x ([type]): [description] plot_y ([type]): [description] plot_B ([type]): [description] \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (m)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (m)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) _ , _ = _plt . subplots () CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () 2D plotting routines using Plotly as the backend This module contains all functions needed to plot lines and contours for 2D magnetic sources. plotly_2D_contour ( x , y , Field , ** kwargs ) Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plotly2D.py def plotly_2D_contour ( x , y , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector_2D]): [field vector object] \"\"\" scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) cmin = kwargs . pop ( \"cmin\" , 0.0 ) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( Field . n [:]) * 2 , 1 )) cstep = kwargs . pop ( \"cstep\" , 0.1 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) title = kwargs . pop ( \"title\" , None ) xlab = kwargs . pop ( \"xlab\" , \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , \"B (T)\" ) # field_component = kwargs.pop(\"field_component\", \"n\") # plot_type = kwargs.pop(\"plot_type\", \"contour\") plot_objects = [] # cache = {} plot_objects . append ( _plotly_contour2 ( x , y , Field . n , cmin = cmin , cmax = cmax , cstep = cstep , colorscale = colorscale , ) ) plot_objects . append ( _plotly_draw_circle ( p1 = ( - 10 , - 10 ), p2 = ( 10 , 10 ))) plot_objects . append ( _plotly_draw_arrow ( head = ( 6 , - 6 ), tail = ( - 6 , 6 ))) fig = _go . Figure ( data = plot_objects ) fig . update_layout ( title = title , xaxis_title = xlab , yaxis_title = ylab , ) fig . update_yaxes ( scaleanchor = \"x\" , scaleratio = 1 , ) fig . update_xaxes ( range = [ x . min () * 1 , x . max () * 1 ]) fig . update_yaxes ( range = [ y . min () * 1 , y . max () * 1 ]) # fig.update_yaxes(automargin=True) fig . update_layout ( autosize = False , width = 500 , height = 500 , margin = dict ( l = 50 , r = 50 , b = 50 , t = 100 , pad = 0 ), ) fig . show () 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2D module, here plotly is used as the backend. Todo Update str and repr for polyhedra Graphic_Cuboid Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size tuple [description]. Defaults to (1, 1, 1). (1, 1, 1) Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords Graphic_Cylinder Generates vertices for a Cylinder Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required length float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords Graphic_Mesh Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs color (float): __init__ ( self , mesh_vectors , start , stop , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required size tuple [description]. Defaults to (1, 1, 1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , mesh_vectors , start , stop , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" self . color = kwargs . pop ( \"color\" , \"white\" ) self . mesh_vectors = mesh_vectors [ start : stop ] generate_vertices ( self ) Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = self . color ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace Graphic_Sphere Generates vertices for a sphere Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float): __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords Polyhedron Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere Mesh __init__ ( self , center , size , ** kwargs ) special Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"white\" ) generate_vertices ( self ) Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass list_polyhedra () Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plotly3D.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances () reset_polyhedra () Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plotly3D.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset () surface_slice3 ( ** kwargs ) Calculates and plots magnetic field slices a Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def surface_slice3 ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices a Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" reset_polyhedra () max1 = kwargs . pop ( \"max1\" , 30 ) max2 = kwargs . pop ( \"max\" , 30 ) slice_value = kwargs . pop ( \"slice_value\" , 0.0 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in planes : points = slice3D ( plane = plane , max1 = max1 , max2 = max2 , slice_value = slice_value , unit = unit , num_points = num_points , ) field = B_calc_3D ( points ) cache [ plane ] = { \"points\" : points , \"field\" : field } data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return fig , cache , data_objects volume_calculate_plot ( ** kwargs ) Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def volume_calculate_plot ( ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" num_points = kwargs . pop ( \"num_points\" , 30 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) xmax = kwargs . pop ( \"xmax\" , 30 ) ymax = kwargs . pop ( \"ymax\" , 30 ) zmax = kwargs . pop ( \"zmax\" , 30 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) points = grid3D ( xmax , ymax , zmax , num_points = num_points , xmin = xmin , ymin = ymin , zmin = zmin , unit = unit , ) field = B_calc_3D ( points ) data_objects , fig = volume_plot ( points , field , num_points = num_points , ** kwargs ) return fig , data_objects , points , field volume_plot ( points , field , ** kwargs ) Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def volume_plot ( points , field , ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) opacityscale = kwargs . pop ( \"opacityscale\" , None ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , None ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) # kernel_size = 1 # kernel = np.ones([kernel_size, kernel_size, kernel_size]) / kernel_size # B.n = ndimage.convolve(B.n, kernel) data_objects . append ( _generate_volume_data ( points , field , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , opacityscale = opacityscale , ) ) if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return data_objects , fig","title":"plots"},{"location":"plots/#plots-module","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of cubes, cuboids, and cylinders","title":"Plots module"},{"location":"plots/#pymagnet.plots._plot1D.plot_1D_field","text":"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet magnet object Must be a Magnet_3D type of magnet, either Prism, Cube, required Kwargs num_points (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). Source code in pymagnet/plots/_plot1D.py def plot_1D_field ( magnet , unit = \"mm\" , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (magnet object): Must be a Magnet_3D type of magnet, either Prism, Cube, or Cylinder. Kwargs: num_points (int): Number of points to calculate. Defaults to 101. Returns: tuple: Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). \"\"\" num_points = kwargs . pop ( \"num_points\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) points = Point_Array1 ( _np . zeros ( num_points ), unit = unit ) if issubclass ( magnet . __class__ , Cylinder ): mag_boundary = magnet . length / 2 points . z = _np . linspace ( - 2 * magnet . length + magnet . center [ 2 ], 2 * magnet . length + magnet . center [ 2 ], num_points , ) field = magnetic_field_cylinder_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , Prism ): mag_boundary = magnet . height / 2 points . z = _np . linspace ( - 2 * magnet . height + magnet . center [ 2 ], 2 * magnet . height + magnet . center [ 2 ], num_points , ) field = magnetic_field_prism_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN else : print ( \"Error\" ) return None _ , _ = _plt . subplots () unit_length = \"(\" + points . unit + \")\" field_unit = \"(\" + field . unit + \")\" _plt . xlabel ( r \"$z$ \" + unit_length ) _plt . ylabel ( r \"$B_z$ \" + field_unit ) _plt . plot ( points . z , field . z ) _plt . axvline ( x =- mag_boundary + magnet . center [ 2 ], c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary + magnet . center [ 2 ], c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return points , field Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and","title":"plot_1D_field()"},{"location":"plots/#pymagnet.plots._plot2D.arrow","text":"Encodes magnetisation vector for drawing on plots","title":"arrow"},{"location":"plots/#pymagnet.plots._plot2D.arrow.__init__","text":"Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot2D.magnet_patch","text":"Magnet drawing class Parameters: Name Type Description Default object [type] [description] required","title":"magnet_patch"},{"location":"plots/#pymagnet.plots._plot2D.patch","text":"Encodes magnet dimensions for drawing on plots Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required","title":"patch"},{"location":"plots/#pymagnet.plots._plot2D.patch.__init__","text":"Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type","title":"__init__()"},{"location":"plots/#pymagnet.plots._plot2D.contour_plot_cylinder","text":"Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [type] [description] required Source code in pymagnet/plots/_plot2D.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet ([type]): [description] \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (m)\" ylab = \"z (m)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , )","title":"contour_plot_cylinder()"},{"location":"plots/#pymagnet.plots._plot2D.line_plot_cylinder","text":"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet [magnet object] required Source code in pymagnet/plots/_plot2D.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet ([magnet object]): \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) _ , _ = _plt . subplots () _plt . plot ( rho * 1 , Bz , label = r \"$B_z$\" ) _plt . plot ( rho * 1 , Br , label = r \"$B_r$\" ) _plt . legend ( loc = \"best\" ) _plt . show ()","title":"line_plot_cylinder()"},{"location":"plots/#pymagnet.plots._plot2D.param_test_2D","text":"Example plots while varying the size of a permanent magnet This is an example helper function. Parameters: Name Type Description Default width [type] [description] required height [type] [description] required Source code in pymagnet/plots/_plot2D.py def param_test_2D ( width , height ): \"\"\"Example plots while varying the size of a permanent magnet This is an example helper function. Args: width ([type]): [description] height ([type]): [description] \"\"\" x = _np . linspace ( - 2 * width , 2 * width , 100 ) y = 1 + height B = _mag . _routines2 . B_calc_2D ( x , y ) plot_2D_line ( x , B ) x , y = _mag . _routines2 . grid2D ( 1.5 * width , height ) B = _mag . _routines2 . B_calc_2D ( x , y ) cmap = \"viridis\" plot_2D_contour ( x , y , B , cmax = 1 , num_levels = 11 , cmap = cmap )","title":"param_test_2D()"},{"location":"plots/#pymagnet.plots._plot2D.plot_2D_contour","text":"Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_2D_contour ( point_array , field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] field ([field vector_2D]): [field vector object] \"\"\" import matplotlib.cm as _cm from ..magnets._polygon2D import PolyMagnet show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"y ( { point_array . unit } )\" ) clab = kwargs . pop ( \"clab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) _ , ax = _plt . subplots () if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"magma\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = field . x elif field_component == \"y\" : field_chosen = field . y else : field_chosen = field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( point_array . x , point_array . y , field_chosen , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( point_array . x , point_array . y , field_chosen , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( point_array , field , NQ , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = point_array . x [:, 0 ] ypl = point_array . y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : field . x . T , \"vertical\" : field . y . T , } CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ), ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 )","title":"plot_2D_contour()"},{"location":"plots/#pymagnet.plots._plot2D.plot_2D_line","text":"Line Plot of field from 2D magnet Parameters: Name Type Description Default x [array] [assumes in m] required field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_2D_line ( point_array , field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: x ([array]): [assumes in m] field ([field vector_2D]): [field vector object] \"\"\" xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) _ , ax = _plt . subplots () _plt . plot ( point_array . x , field . n , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( point_array . x , field . x , label = r \"$B_x$\" ) _plt . plot ( point_array . x , field . y , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 ) # _plt.savefig('contour_plot.pdf', dpi=300)","title":"plot_2D_line()"},{"location":"plots/#pymagnet.plots._plot2D.plot_3D_contour","text":"Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required field [field vector] [field vector object] required Source code in pymagnet/plots/_plot2D.py def plot_3D_contour ( points , field , plane , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] field ([field vector]): [field vector object] \"\"\" # import matplotlib.cm as _cm axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , \"x (\" + points . unit + \")\" ) ylab = kwargs . pop ( \"ylab\" , \"y (\" + points . unit + \")\" ) zlab = kwargs . pop ( \"zlab\" , \"z (\" + points . unit + \")\" ) clab = kwargs . pop ( \"clab\" , \"B (\" + field . unit + \")\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = field . n [ _np . isfinite ( field . n )] cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if plane . lower () == \"xy\" : plot_x = points . x plot_y = points . y plot_xlab = xlab plot_ylab = ylab stream_x = field . x stream_y = field . z elif plane . lower () == \"xz\" : stream_x = field . x stream_y = field . z plot_x = points . x plot_y = points . z plot_xlab = xlab plot_ylab = zlab else : stream_x = field . y stream_y = field . z plot_x = points . y plot_y = points . z plot_xlab = ylab plot_ylab = zlab _ , ax = _plt . subplots () # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"magma\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , field . n , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , field . n , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Field2 ( stream_x , stream_y , unit = field . unit ) B_2D . calc_norm () points_2D = Point_Array2 ( plot_x , plot_y , unit = points . unit ) _vector_plot2 ( points_2D , B_2D , NQ , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 )","title":"plot_3D_contour()"},{"location":"plots/#pymagnet.plots._plot2D.plot_sub_contour_3D","text":"Contour plot of 3D simulation Parameters: Name Type Description Default plot_x [type] [description] required plot_y [type] [description] required plot_B [type] [description] required Source code in pymagnet/plots/_plot2D.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of 3D simulation Args: plot_x ([type]): [description] plot_y ([type]): [description] plot_B ([type]): [description] \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (m)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (m)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) _ , _ = _plt . subplots () CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () 2D plotting routines using Plotly as the backend This module contains all functions needed to plot lines and contours for 2D magnetic sources.","title":"plot_sub_contour_3D()"},{"location":"plots/#pymagnet.plots._plotly2D.plotly_2D_contour","text":"Contour Plot of field Parameters: Name Type Description Default x [array] [assumes in \u00b5m] required y [array] [assumes in nm] required Field [field vector_2D] [field vector object] required Source code in pymagnet/plots/_plotly2D.py def plotly_2D_contour ( x , y , Field , ** kwargs ): \"\"\"Contour Plot of field Args: x ([array]): [assumes in \u00b5m] y ([array]): [assumes in nm] Field ([field vector_2D]): [field vector object] \"\"\" scale_x = kwargs . pop ( \"scale_x\" , 1 ) scale_y = kwargs . pop ( \"scale_y\" , 1 ) scale_cb = kwargs . pop ( \"scale_cb\" , 1 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) cmin = kwargs . pop ( \"cmin\" , 0.0 ) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( Field . n [:]) * 2 , 1 )) cstep = kwargs . pop ( \"cstep\" , 0.1 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) title = kwargs . pop ( \"title\" , None ) xlab = kwargs . pop ( \"xlab\" , \"x (mm)\" ) ylab = kwargs . pop ( \"ylab\" , \"y (mm)\" ) clab = kwargs . pop ( \"clab\" , \"B (T)\" ) # field_component = kwargs.pop(\"field_component\", \"n\") # plot_type = kwargs.pop(\"plot_type\", \"contour\") plot_objects = [] # cache = {} plot_objects . append ( _plotly_contour2 ( x , y , Field . n , cmin = cmin , cmax = cmax , cstep = cstep , colorscale = colorscale , ) ) plot_objects . append ( _plotly_draw_circle ( p1 = ( - 10 , - 10 ), p2 = ( 10 , 10 ))) plot_objects . append ( _plotly_draw_arrow ( head = ( 6 , - 6 ), tail = ( - 6 , 6 ))) fig = _go . Figure ( data = plot_objects ) fig . update_layout ( title = title , xaxis_title = xlab , yaxis_title = ylab , ) fig . update_yaxes ( scaleanchor = \"x\" , scaleratio = 1 , ) fig . update_xaxes ( range = [ x . min () * 1 , x . max () * 1 ]) fig . update_yaxes ( range = [ y . min () * 1 , y . max () * 1 ]) # fig.update_yaxes(automargin=True) fig . update_layout ( autosize = False , width = 500 , height = 500 , margin = dict ( l = 50 , r = 50 , b = 50 , t = 100 , pad = 0 ), ) fig . show () 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2D module, here plotly is used as the backend. Todo Update str and repr for polyhedra","title":"plotly_2D_contour()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cuboid","text":"Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Cuboid"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cuboid.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size tuple [description]. Defaults to (1, 1, 1). (1, 1, 1) Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cuboid.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cylinder","text":"Generates vertices for a Cylinder Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required length float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Cylinder"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cylinder.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Cylinder.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Mesh","text":"Generates Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). required size tuple Size of cuboid. Defaults to (1, 1, 1). required Kwargs color (float):","title":"Graphic_Mesh"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Mesh.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required size tuple [description]. Defaults to (1, 1, 1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , mesh_vectors , start , stop , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (tuple, optional): [description]. Defaults to (1, 1, 1). \"\"\" self . color = kwargs . pop ( \"color\" , \"white\" ) self . mesh_vectors = mesh_vectors [ start : stop ]","title":"__init__()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Mesh.generate_vertices","text":"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = self . color ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Sphere","text":"Generates vertices for a sphere Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). required radius float [description]. Defaults to 1. required Kwargs alpha (float): beta (float): gamma (float): color (float):","title":"Graphic_Sphere"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Sphere.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) size float [description]. Defaults to (1). required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). size (float, optional): [description]. Defaults to (1). \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"plots/#pymagnet.plots._plotly3D.Graphic_Sphere.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plotly3D.Polyhedron","text":"Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere Mesh","title":"Polyhedron"},{"location":"plots/#pymagnet.plots._plotly3D.Polyhedron.__init__","text":"Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"white\" )","title":"__init__()"},{"location":"plots/#pymagnet.plots._plotly3D.Polyhedron.generate_vertices","text":"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass","title":"generate_vertices()"},{"location":"plots/#pymagnet.plots._plotly3D.list_polyhedra","text":"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plotly3D.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances ()","title":"list_polyhedra()"},{"location":"plots/#pymagnet.plots._plotly3D.reset_polyhedra","text":"Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plotly3D.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset ()","title":"reset_polyhedra()"},{"location":"plots/#pymagnet.plots._plotly3D.surface_slice3","text":"Calculates and plots magnetic field slices a Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def surface_slice3 ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices a Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" reset_polyhedra () max1 = kwargs . pop ( \"max1\" , 30 ) max2 = kwargs . pop ( \"max\" , 30 ) slice_value = kwargs . pop ( \"slice_value\" , 0.0 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in planes : points = slice3D ( plane = plane , max1 = max1 , max2 = max2 , slice_value = slice_value , unit = unit , num_points = num_points , ) field = B_calc_3D ( points ) cache [ plane ] = { \"points\" : points , \"field\" : field } data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return fig , cache , data_objects","title":"surface_slice3()"},{"location":"plots/#pymagnet.plots._plotly3D.volume_calculate_plot","text":"Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def volume_calculate_plot ( ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" num_points = kwargs . pop ( \"num_points\" , 30 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) xmax = kwargs . pop ( \"xmax\" , 30 ) ymax = kwargs . pop ( \"ymax\" , 30 ) zmax = kwargs . pop ( \"zmax\" , 30 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) points = grid3D ( xmax , ymax , zmax , num_points = num_points , xmin = xmin , ymin = ymin , zmin = zmin , unit = unit , ) field = B_calc_3D ( points ) data_objects , fig = volume_plot ( points , field , num_points = num_points , ** kwargs ) return fig , data_objects , points , field","title":"volume_calculate_plot()"},{"location":"plots/#pymagnet.plots._plotly3D.volume_plot","text":"Calculates and plots magnetic field vol Returns: Type Description dictionary cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. Source code in pymagnet/plots/_plotly3D.py def volume_plot ( points , field , ** kwargs ): \"\"\"Calculates and plots magnetic field vol Returns: dictionary: cached data for each plane with potential keys: 'xy', 'xz', 'yz' containing subdictionaries, whose keys are 'x','y', 'z', 'B'. \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) opacityscale = kwargs . pop ( \"opacityscale\" , None ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , None ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) # kernel_size = 1 # kernel = np.ones([kernel_size, kernel_size, kernel_size]) / kernel_size # B.n = ndimage.convolve(B.n, kernel) data_objects . append ( _generate_volume_data ( points , field , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , opacityscale = opacityscale , ) ) if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . show () return data_objects , fig","title":"volume_plot()"},{"location":"pymagnet/","text":"Main module pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules __main__ special Example plots magnets special pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. plots special pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. utils special pymagnets.utils global_const Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"pymagnet"},{"location":"pymagnet/#main-module","text":"pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules","title":"Main module"},{"location":"pymagnet/#pymagnet.__main__","text":"Example plots","title":"__main__"},{"location":"pymagnet/#pymagnet.magnets","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API.","title":"magnets"},{"location":"pymagnet/#pymagnet.plots","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly.","title":"plots"},{"location":"pymagnet/#pymagnet.utils","text":"pymagnets.utils","title":"utils"},{"location":"pymagnet/#pymagnet.utils.global_const","text":"Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"global_const"},{"location":"transforms/","text":"Transforms Coordinate System Transforms Scalar Transforms Vector Transforms For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) . Polar to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\] Cylindrical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\] Spherical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\] Misc Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Transforms"},{"location":"transforms/#transforms","text":"","title":"Transforms"},{"location":"transforms/#coordinate-system-transforms","text":"","title":"Coordinate System Transforms"},{"location":"transforms/#scalar-transforms","text":"","title":"Scalar Transforms"},{"location":"transforms/#vector-transforms","text":"For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) .","title":"Vector Transforms"},{"location":"transforms/#polar-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\]","title":"Polar to Cartesian"},{"location":"transforms/#cylindrical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\]","title":"Cylindrical to Cartesian"},{"location":"transforms/#spherical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\]","title":"Spherical to Cartesian"},{"location":"transforms/#misc","text":"Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Misc"},{"location":"utils/","text":"Utils Module pymagnets.utils global_const Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4 Routines for converting between coordinate systems, between 2D cartesian and polar, as well as 3D cartesian, cylindrical, and spherical. cart2pol ( x , y ) Converts from cartesian to polar coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/utils/_conversions.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi ) cart2sph ( x , y , z ) Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required z float/array z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/utils/_conversions.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (float/array): x coordinates y (float/array): y coordinates z (float/array): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi ) get_unit_value_meter ( unit ) Returns a queried metre unit as a number Examples: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_meter ( unit ): \"\"\"Returns a queried metre unit as a number Example: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"Ym\" : 1e24 , \"Zm\" : 1e21 , \"Em\" : 1e18 , \"Pm\" : 1e15 , \"Tm\" : 1e12 , \"Gm\" : 1e9 , \"Mm\" : 1e6 , \"km\" : 1e3 , \"hm\" : 1e2 , \"dam\" : 1e1 , \"m\" : 1 , \"dm\" : 1e-1 , \"cm\" : 1e-2 , \"mm\" : 1e-3 , \"\u00b5m\" : 1e-6 , \"um\" : 1e-6 , \"nm\" : 1e-9 , \"Ang\" : 1e-10 , \"pm\" : 1e-12 , \"fm\" : 1e-15 , \"am\" : 1e-18 , \"zm\" : 1e-21 , \"ym\" : 1e-24 , } return si_prefixes . get ( unit , None ) get_unit_value_tesla ( unit ) Returns a queried magnetic flux density unit as a number Examples: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_tesla ( unit ): \"\"\"Returns a queried magnetic flux density unit as a number Example: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"YT\" : 1e24 , \"ZT\" : 1e21 , \"ET\" : 1e18 , \"PT\" : 1e15 , \"TT\" : 1e12 , \"GT\" : 1e9 , \"MT\" : 1e6 , \"kT\" : 1e3 , \"hT\" : 1e2 , \"daT\" : 1e1 , \"T\" : 1 , \"dT\" : 1e-1 , \"cT\" : 1e-2 , \"mT\" : 1e-3 , \"\u00b5T\" : 1e-6 , \"uT\" : 1e-6 , \"nT\" : 1e-9 , \"pT\" : 1e-12 , \"fT\" : 1e-15 , \"aT\" : 1e-18 , \"zT\" : 1e-21 , \"yT\" : 1e-24 , } return si_prefixes . get ( unit , None ) pol2cart ( rho , phi ) Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho float/array radial coordinates required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/utils/_conversions.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (float/array): radial coordinates phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y ) sph2cart ( r , theta , phi ) Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r float/array radial coordinates required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/utils/_conversions.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (float/array): radial coordinates theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z sphere_sph2cart ( Br , Btheta , theta , phi ) Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz vector_pol2cart ( Brho , Bphi , phi ) Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho float/array radial vector component required Bphi float/array azimuthal vector component required phi float/array azimuthal coordinates required Returns: Type Description tuple Bx, By Source code in pymagnet/utils/_conversions.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (float/array): radial vector component Bphi (float/array): azimuthal vector component phi (float/array): azimuthal coordinates Returns: tuple: Bx, By \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By vector_sph2cart ( Br , Btheta , Bphi , theta , phi ) Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required Bphi float/array azimuthal vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component Bphi (float/array): azimuthal vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz pymagnets.utils._point_structs Private module consiting of point classes and their methods. Point2 2D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Point3 3D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1 Quaternion Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ) special Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/utils/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z ) as_tuple ( self ) Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/utils/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z euler_to_quaternion ( alpha , beta , gamma ) staticmethod Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/utils/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz ) gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ) staticmethod Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > MAG_TOL : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > MAG_TOL : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > MAG_TOL : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation get_conjugate ( self ) Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/utils/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z ) q_angle_from_axis ( theta , vec ) Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion vec_norm ( x , y , z ) staticmethod Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/utils/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Routines for Two Dimensional Magnet Classes B_calc_2D ( Point_Array2 , unit = 'mm' ) Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M Source code in pymagnet/utils/_routines2D.py def B_calc_2D ( Point_Array2 , unit = \"mm\" ): \"\"\"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M \"\"\" from ..magnets import Magnet_2D # Empty data structure B = _allocate_field_array2 ( Point_Array2 . x , Point_Array2 . y ) for magnet in Magnet_2D . instances : Bx , By = magnet . calcB ( Point_Array2 . x , Point_Array2 . y ) B . x += Bx B . y += By B . calc_norm () return B FgradB_2D ( B , x , y , chi_m , c ) Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Field2 Magnetic field gradient force vector Source code in pymagnet/utils/_routines2D.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Field2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Field2: Magnetic field gradient force vector \"\"\" BgB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / u0 ) * chi_m * c * BgB . n FB . x = ( 1 / u0 ) * chi_m * c * BgB . x FB . y = ( 1 / u0 ) * chi_m * c * BgB . y return FB gradB_2D ( B , x , y ) Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Field2 Magnetic field gradient vector Source code in pymagnet/utils/_routines2D.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Field2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Field2: Magnetic field gradient vector \"\"\" dB = Field2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB grid2D ( xmax , ymax , ** kwargs ) Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines2D.py def grid2D ( xmax , ymax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j x , y = _np . mgrid [ xmin : xmax : NPJ , ymin : ymax : NPJ ] return Point_Array2 ( x , y , unit = unit ) rotate_points_2D ( x , y , alpha ) Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x float/array array of x coordinates required y float/array array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/utils/_routines2D.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (float/array): array of x coordinates y (float/array): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes B_calc_3D ( points ) Calculates the magnetic field at a series of points due to all Magnet_3D instances. Parameters: Name Type Description Default points Point_Array3 array of x,y,z points and associated unit required Returns: Type Description Field3 array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines3D.py def B_calc_3D ( points ): \"\"\"Calculates the magnetic field at a series of points due to all `Magnet_3D` instances. Args: points (Point_Array3): array of x,y,z points and associated unit Returns: Field3: array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet_3D B = _allocate_field_array3 ( points . x , points . y , points . z ) for magnet in Magnet_3D . instances : Bx , By , Bz = magnet . calcB ( points . x , points . y , points . z ) B . x += Bx . reshape ( B . x . shape ) B . y += By . reshape ( B . y . shape ) B . z += Bz . reshape ( B . z . shape ) B . calc_norm () return B grid3D ( xmax , ymax , zmax , ** kwargs ) Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required zmax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def grid3D ( xmax , ymax , zmax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value zmax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , None ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j if num_points is None : num_points_x = kwargs . pop ( \"num_points_x\" , 100 ) num_points_y = kwargs . pop ( \"num_points_y\" , 100 ) num_points_z = kwargs . pop ( \"num_points_z\" , 100 ) else : num_points_x = num_points num_points_y = num_points num_points_z = num_points xmin = kwargs . pop ( \"lx\" , - 1 * xmax ) ymin = kwargs . pop ( \"ly\" , - 1 * ymax ) zmin = kwargs . pop ( \"lz\" , - 1 * zmax ) x , y , z = _np . mgrid [ xmin : xmax : num_points_x * 1 j , ymin : ymax : num_points_y * 1 j , zmin : zmax : num_points_z * 1 j , ] return Point_Array3 ( x , y , z , unit = unit ) slice3D ( plane = 'xy' , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = 'mm' , ** kwargs ) Generates a planar slice of values Parameters: Name Type Description Default plane str plane. Defaults to \"xy\". 'xy' max1 float maximum along axis 1. Defaults to 1.0. 1.0 max2 float maximum along axis 2. Defaults to 1.0. 1.0 slice_value float constant value for third axis. Defaults to 0.0. 0.0 unit str length scale units. Defaults to \"mm\". 'mm' Kwargs num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Exceptions: Type Description Exception plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Type Description Point_Array3 array of x, y, and z values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def slice3D ( plane = \"xy\" , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = \"mm\" , ** kwargs ): \"\"\"Generates a planar slice of values Args: plane (str, optional): plane. Defaults to \"xy\". max1 (float, optional): maximum along axis 1. Defaults to 1.0. max2 (float, optional): maximum along axis 2. Defaults to 1.0. slice_value (float, optional): constant value for third axis. Defaults to 0.0. unit (str, optional): length scale units. Defaults to \"mm\". Kwargs: num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Raises: Exception: plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Point_Array3: array of x, y, and z values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) min1 = kwargs . pop ( \"xmin\" , - 1 * max1 ) min2 = kwargs . pop ( \"ymin\" , - 1 * max2 ) NPj = num_points * 1 j if plane . lower () == \"xy\" : x , y = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] z = _np . asarray ([ slice_value ]) z = _np . tile ( z , x . shape ) elif plane . lower () == \"xz\" : x , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] y = _np . asarray ([ slice_value ]) y = _np . tile ( y , x . shape ) elif plane . lower () == \"yz\" : y , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] x = _np . asarray ([ slice_value ]) x = _np . tile ( x , y . shape ) elif plane . lower () == \"custom\" : x = kwargs . pop ( \"custom_x\" , _np . array ([ 0.0 ])) y = kwargs . pop ( \"custom_y\" , _np . array ([ 0.0 ])) z = kwargs . pop ( \"custom_z\" , _np . array ([ 0.0 ])) else : raise Exception ( \"plane must be one of 'xy', 'xz, 'yz', or 'custom'\" ) return Point_Array3 ( x , y , z , unit = unit ) Contains functions needed to rotate and translate a triangle to lie in the xz plane and to divide it into two right angled triangles align_triangle_to_y ( triangle , rot_axis , norm_vec ) Rotates and translates a triangle in lie in the xz plane Parameters: Name Type Description Default triangle ndarray vertices of a triangle required rot_axis ndarray axis about which to rotate triangle required norm_vec ndarray normal to triangle required Returns: Type Description tuple aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_to_y ( triangle , rot_axis , norm_vec ): \"\"\"Rotates and translates a triangle in lie in the xz plane Args: triangle (ndarray): vertices of a triangle rot_axis (ndarray): axis about which to rotate triangle norm_vec (ndarray): normal to triangle Returns: tuple: aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) \"\"\" y_axis = _np . array ([ 0 , 1 , 0 ]) if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( y_axis , norm_vec ): # Parallel first_rotation = Quaternion () aligned_triangle = triangle else : # Anti-parallel first_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) else : angle = - _np . arccos ( _np . dot ( y_axis , norm_vec )) first_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) return aligned_triangle , first_rotation align_triangle_xz ( triangle , longest_side ) Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Parameters: Name Type Description Default triangle ndarray vertices of triangle required longest_side int index of the longest side of triangle required Returns: Type Description tuple second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_xz ( triangle , longest_side ): \"\"\"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Args: triangle (ndarray): vertices of triangle longest_side (int): index of the longest side of triangle Returns: tuple: second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): \"\"\" x_axis = _np . array ([ 1 , 0 , 0 ]) y_axis = _np . array ([ 0 , 1 , 0 ]) z_axis = _np . array ([ 0 , 0 , 1 ]) # side_list = [0, 1, 2] # side_list.pop(longest_side) vec_x = return_axis_vector ( triangle , longest_side ) rot_axis = _np . cross ( x_axis , vec_x ) # Check aligment of base of triangle with x-axis if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( x_axis , vec_x ): # Parallel second_rotation = Quaternion () tri_x = triangle else : # Anti-parallel second_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) tri_x = rotate_points ( triangle , second_rotation ) else : angle = - _np . arccos ( _np . dot ( x_axis , vec_x )) second_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) tri_x = rotate_points ( triangle , second_rotation ) vec_z = return_z_vector ( tri_x , longest_side ) rot_axis = _np . cross ( z_axis , vec_z ) # Check aligment of triangle altitude with z-axis if _np . all ( _np . fabs ([ rot_axis ]) < ALIGN_CUTOFF ): # Check if parallel anti-parallel if check_sign ( z_axis , vec_z ): # Parallel third_rotation = Quaternion () else : # Anti-parallel third_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) else : angle = - _np . arccos ( _np . dot ( z_axis , vec_z )) third_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) return second_rotation , third_rotation altitude ( a , b , c ) Gets altitude to side a of a triangle. Parameters: Name Type Description Default a float longest side required b float triangle side required c float triangle side required Returns: Type Description float altitude to side a Source code in pymagnet/utils/_trigonometry3D.py def altitude ( a , b , c ): \"\"\"Gets altitude to side `a` of a triangle. Args: a (float): longest side b (float): triangle side c (float): triangle side Returns: float: altitude to side `a` \"\"\" s = ( a + b + c ) / 2 return 2 * _np . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )) / a check_sign ( vector_1 , vector_2 ) Returns true if the signs of all elements of two arrays are the same Parameters: Name Type Description Default vector_1 ndarray input array 2 required vector_2 ndarray input array 2 required Returns: Type Description boolean True if elements in two arrays have the same sign Source code in pymagnet/utils/_trigonometry3D.py def check_sign ( vector_1 , vector_2 ): \"\"\"Returns true if the signs of all elements of two arrays are the same Args: vector_1 (ndarray): input array 2 vector_2 (ndarray): input array 2 Returns: boolean: True if elements in two arrays have the same sign \"\"\" sign_comp_1 = _np . fabs ( vector_1 + vector_2 ) sign_comp_2 = _np . fabs ( vector_1 ) + _np . fabs ( vector_2 ) return _np . allclose ( sign_comp_1 , sign_comp_2 , atol = 1e-6 ) norm_plane ( vec ) Calculates the normal to a triangular plane Parameters: Name Type Description Default vec ndarray/list/tuple (N,1) array required Returns: Type Description ndarray normal vector (N,) Source code in pymagnet/utils/_trigonometry3D.py def norm_plane ( vec ): \"\"\"Calculates the normal to a triangular plane Args: vec (ndarray/list/tuple): (N,1) array Returns: ndarray: normal vector (N,) \"\"\" norm = _np . cross ( vec [ 1 ] - vec [ 0 ], vec [ 2 ] - vec [ 0 ]) norm = norm / _np . linalg . norm ( norm ) return norm return_axis_vector ( triangle , longest_side ) Returns vector collinear to the longest side of a triangle Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray vector corresponding to longest side Source code in pymagnet/utils/_trigonometry3D.py def return_axis_vector ( triangle , longest_side ): \"\"\"Returns vector collinear to the longest side of a triangle Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: vector corresponding to longest side \"\"\" vector_A = triangle [ 1 ] - triangle [ 0 ] vector_A = vector_A / _np . linalg . norm ( vector_A ) vector_B = triangle [ 2 ] - triangle [ 1 ] vector_B = vector_B / _np . linalg . norm ( vector_B ) vector_C = triangle [ 2 ] - triangle [ 0 ] vector_C = vector_C / _np . linalg . norm ( vector_C ) vec_dict = { 0 : vector_A , 1 : vector_B , 2 : vector_C , } vec = vec_dict [ longest_side ] return vec return_z_vector ( triangle , longest_side ) Returns altitude vector from longest side Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray altitude vector Source code in pymagnet/utils/_trigonometry3D.py def return_z_vector ( triangle , longest_side ): \"\"\"Returns altitude vector from longest side Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: altitude vector \"\"\" new_vertex_dict = { 0 : [ triangle [ 2 , 0 ], triangle [ 0 , 1 ], triangle [ 0 , 2 ]], 1 : [ triangle [ 0 , 0 ], triangle [ 0 , 1 ], triangle [ 1 , 2 ]], 2 : [ triangle [ 1 , 0 ], triangle [ 2 , 1 ], triangle [ 2 , 2 ]], } new_vertex = _np . array ( new_vertex_dict [ longest_side ]) vec_z_dict = { 0 : triangle [ 2 ] - new_vertex , 1 : triangle [ 0 ] - new_vertex , 2 : triangle [ 1 ] - new_vertex , } vec_z = vec_z_dict [ longest_side ] vec_z = vec_z / _np . linalg . norm ( vec_z ) return vec_z rotate_points ( points , rotation_quaternion ) Rotates a set of points Parameters: Name Type Description Default points [type] [description] required rotation_quaternion [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/utils/_trigonometry3D.py def rotate_points ( points , rotation_quaternion ): \"\"\"Rotates a set of points Args: points ([type]): [description] rotation_quaternion ([type]): [description] Returns: [type]: [description] \"\"\" x_rot , y_rot , z_rot = rotation_quaternion * points . T rotate_points = _np . vstack ([ x_rot , y_rot , z_rot ]) . T return rotate_points signed_area ( triangle ) Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Parameters: Name Type Description Default triangle ndarray 3x3 array of vertices required Returns: Type Description float signed area Source code in pymagnet/utils/_trigonometry3D.py @jit def signed_area ( triangle ): \"\"\"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Args: triangle (ndarray): 3x3 array of vertices Returns: float: signed area \"\"\" j = 1 NP = 3 area = 0.0 for i in range ( NP ): j = j % NP area += ( triangle [ j ][ 0 ] - triangle [ i ][ 0 ]) * ( triangle [ j ][ 2 ] + triangle [ i ][ 2 ]) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points area /= 2.0 return area pymagnets.utils._vector_structs Private module consiting of vector and point array classes and their methods. Field1 1D Field vector class consisting of numpy arrays of z values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f8099c42670 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value ) Field2 2D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f8099c42670 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value ) Field3 3D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required z required Methods calculates the magnitude of the fields at every point and stores in self.n change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f8099c42670 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value ) Point_Array1 2D vector class consisting of numpy arrays of x and y coordinates Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f8099c425e0 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Prism , Cylinder current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . depth = magnet . depth * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val Point_Array2 2D vector class consisting of numpy arrays of x and y coordinates Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f8099c425e0 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Rectangle , Square , Circle , PolyMagnet current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Rectangle ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Square ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Circle ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , PolyMagnet ): magnet . polygon . vertices = ( scale_val * _np . array ( magnet . polygon . vertices ) ) . tolist () Point_Array3 change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f8099c425e0 > ) Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Prism , Cube , Cylinder , Sphere , Mesh current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val magnet . depth = magnet . depth * scale_val elif issubclass ( magnet . __class__ , Cube ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val elif issubclass ( magnet . __class__ , Sphere ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , Mesh ): magnet . mesh_vectors = magnet . mesh_vectors * scale_val Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"utils"},{"location":"utils/#utils-module","text":"pymagnets.utils","title":"Utils Module"},{"location":"utils/#pymagnet.utils.global_const","text":"Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4 Routines for converting between coordinate systems, between 2D cartesian and polar, as well as 3D cartesian, cylindrical, and spherical.","title":"global_const"},{"location":"utils/#pymagnet.utils._conversions.cart2pol","text":"Converts from cartesian to polar coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/utils/_conversions.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (float/array): x coordinates y (float/array): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi )","title":"cart2pol()"},{"location":"utils/#pymagnet.utils._conversions.cart2sph","text":"Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x float/array x coordinates required y float/array y coordinates required z float/array z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/utils/_conversions.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (float/array): x coordinates y (float/array): y coordinates z (float/array): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi )","title":"cart2sph()"},{"location":"utils/#pymagnet.utils._conversions.get_unit_value_meter","text":"Returns a queried metre unit as a number Examples: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_meter ( unit ): \"\"\"Returns a queried metre unit as a number Example: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"Ym\" : 1e24 , \"Zm\" : 1e21 , \"Em\" : 1e18 , \"Pm\" : 1e15 , \"Tm\" : 1e12 , \"Gm\" : 1e9 , \"Mm\" : 1e6 , \"km\" : 1e3 , \"hm\" : 1e2 , \"dam\" : 1e1 , \"m\" : 1 , \"dm\" : 1e-1 , \"cm\" : 1e-2 , \"mm\" : 1e-3 , \"\u00b5m\" : 1e-6 , \"um\" : 1e-6 , \"nm\" : 1e-9 , \"Ang\" : 1e-10 , \"pm\" : 1e-12 , \"fm\" : 1e-15 , \"am\" : 1e-18 , \"zm\" : 1e-21 , \"ym\" : 1e-24 , } return si_prefixes . get ( unit , None )","title":"get_unit_value_meter()"},{"location":"utils/#pymagnet.utils._conversions.get_unit_value_tesla","text":"Returns a queried magnetic flux density unit as a number Examples: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_tesla ( unit ): \"\"\"Returns a queried magnetic flux density unit as a number Example: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"YT\" : 1e24 , \"ZT\" : 1e21 , \"ET\" : 1e18 , \"PT\" : 1e15 , \"TT\" : 1e12 , \"GT\" : 1e9 , \"MT\" : 1e6 , \"kT\" : 1e3 , \"hT\" : 1e2 , \"daT\" : 1e1 , \"T\" : 1 , \"dT\" : 1e-1 , \"cT\" : 1e-2 , \"mT\" : 1e-3 , \"\u00b5T\" : 1e-6 , \"uT\" : 1e-6 , \"nT\" : 1e-9 , \"pT\" : 1e-12 , \"fT\" : 1e-15 , \"aT\" : 1e-18 , \"zT\" : 1e-21 , \"yT\" : 1e-24 , } return si_prefixes . get ( unit , None )","title":"get_unit_value_tesla()"},{"location":"utils/#pymagnet.utils._conversions.pol2cart","text":"Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho float/array radial coordinates required phi float/array azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/utils/_conversions.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (float/array): radial coordinates phi (float/array): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y )","title":"pol2cart()"},{"location":"utils/#pymagnet.utils._conversions.sph2cart","text":"Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r float/array radial coordinates required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/utils/_conversions.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (float/array): radial coordinates theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z","title":"sph2cart()"},{"location":"utils/#pymagnet.utils._conversions.sphere_sph2cart","text":"Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz","title":"sphere_sph2cart()"},{"location":"utils/#pymagnet.utils._conversions.vector_pol2cart","text":"Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho float/array radial vector component required Bphi float/array azimuthal vector component required phi float/array azimuthal coordinates required Returns: Type Description tuple Bx, By Source code in pymagnet/utils/_conversions.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (float/array): radial vector component Bphi (float/array): azimuthal vector component phi (float/array): azimuthal coordinates Returns: tuple: Bx, By \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By","title":"vector_pol2cart()"},{"location":"utils/#pymagnet.utils._conversions.vector_sph2cart","text":"Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br float/array radial vector component required Btheta float/array polar vector component required Bphi float/array azimuthal vector component required theta float/array azimuthal angles required phi float/array polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (float/array): radial vector component Btheta (float/array): polar vector component Bphi (float/array): azimuthal vector component theta (float/array): azimuthal angles phi (float/array): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz pymagnets.utils._point_structs Private module consiting of point classes and their methods.","title":"vector_sph2cart()"},{"location":"utils/#pymagnet.utils._point_structs.Point2","text":"2D point class Note that multiplication of two points is done elementwise, dot product is a separate method.","title":"Point2"},{"location":"utils/#pymagnet.utils._point_structs.Point3","text":"3D point class Note that multiplication of two points is done elementwise, dot product is a separate method. Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1","title":"Point3"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion","text":"Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications","title":"Quaternion"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.__init__","text":"Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w float/array scalar quaternion. Defaults to 1.0. 1.0 x float/array vector component. Defaults to 0.0. 0.0 y float/array vector component. Defaults to 0.0. 0.0 z float/array vector component. Defaults to 0.0. 0.0 Source code in pymagnet/utils/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (float/array, optional): scalar quaternion. Defaults to 1.0. x (float/array, optional): vector component. Defaults to 0.0. y (float/array, optional): vector component. Defaults to 0.0. z (float/array, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z )","title":"__init__()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.as_tuple","text":"Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/utils/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z","title":"as_tuple()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.euler_to_quaternion","text":"Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float X angle required beta float XX angle required gamma float angle required Returns: Type Description [type] [description] Source code in pymagnet/utils/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): X angle beta (float): XX angle gamma (float): angle Returns: [type]: [description] \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz )","title":"euler_to_quaternion()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.gen_rotation_quaternion","text":"Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > MAG_TOL : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > MAG_TOL : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > MAG_TOL : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation","title":"gen_rotation_quaternion()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.get_conjugate","text":"Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/utils/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z )","title":"get_conjugate()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.q_angle_from_axis","text":"Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion","title":"q_angle_from_axis()"},{"location":"utils/#pymagnet.utils._quaternion.Quaternion.vec_norm","text":"Normalises each x,y,z vector Parameters: Name Type Description Default x float/array x array required y float/array y array required z float/array z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/utils/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (float/array): x array y (float/array): y array z (float/array): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Routines for Two Dimensional Magnet Classes","title":"vec_norm()"},{"location":"utils/#pymagnet.utils._routines2D.B_calc_2D","text":"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M Source code in pymagnet/utils/_routines2D.py def B_calc_2D ( Point_Array2 , unit = \"mm\" ): \"\"\"Function to calculate magnetic field due to any array of points It sums the magnetic field B over each component of the magnetisation J = mu_0 M \"\"\" from ..magnets import Magnet_2D # Empty data structure B = _allocate_field_array2 ( Point_Array2 . x , Point_Array2 . y ) for magnet in Magnet_2D . instances : Bx , By = magnet . calcB ( Point_Array2 . x , Point_Array2 . y ) B . x += Bx B . y += By B . calc_norm () return B","title":"B_calc_2D()"},{"location":"utils/#pymagnet.utils._routines2D.FgradB_2D","text":"Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Field2 Magnetic field gradient force vector Source code in pymagnet/utils/_routines2D.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Field2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Field2: Magnetic field gradient force vector \"\"\" BgB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / u0 ) * chi_m * c * BgB . n FB . x = ( 1 / u0 ) * chi_m * c * BgB . x FB . y = ( 1 / u0 ) * chi_m * c * BgB . y return FB","title":"FgradB_2D()"},{"location":"utils/#pymagnet.utils._routines2D.gradB_2D","text":"Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x float/array x coordinates required y float/array y coordinates required Returns: Type Description Field2 Magnetic field gradient vector Source code in pymagnet/utils/_routines2D.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Field2): Magnetic field vector x (float/array): x coordinates y (float/array): y coordinates Returns: Field2: Magnetic field gradient vector \"\"\" dB = Field2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB","title":"gradB_2D()"},{"location":"utils/#pymagnet.utils._routines2D.grid2D","text":"Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines2D.py def grid2D ( xmax , ymax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j x , y = _np . mgrid [ xmin : xmax : NPJ , ymin : ymax : NPJ ] return Point_Array2 ( x , y , unit = unit )","title":"grid2D()"},{"location":"utils/#pymagnet.utils._routines2D.rotate_points_2D","text":"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x float/array array of x coordinates required y float/array array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/utils/_routines2D.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (float/array): array of x coordinates y (float/array): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes","title":"rotate_points_2D()"},{"location":"utils/#pymagnet.utils._routines3D.B_calc_3D","text":"Calculates the magnetic field at a series of points due to all Magnet_3D instances. Parameters: Name Type Description Default points Point_Array3 array of x,y,z points and associated unit required Returns: Type Description Field3 array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines3D.py def B_calc_3D ( points ): \"\"\"Calculates the magnetic field at a series of points due to all `Magnet_3D` instances. Args: points (Point_Array3): array of x,y,z points and associated unit Returns: Field3: array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet_3D B = _allocate_field_array3 ( points . x , points . y , points . z ) for magnet in Magnet_3D . instances : Bx , By , Bz = magnet . calcB ( points . x , points . y , points . z ) B . x += Bx . reshape ( B . x . shape ) B . y += By . reshape ( B . y . shape ) B . z += Bz . reshape ( B . z . shape ) B . calc_norm () return B","title":"B_calc_3D()"},{"location":"utils/#pymagnet.utils._routines3D.grid3D","text":"Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required zmax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def grid3D ( xmax , ymax , zmax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value zmax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , None ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j if num_points is None : num_points_x = kwargs . pop ( \"num_points_x\" , 100 ) num_points_y = kwargs . pop ( \"num_points_y\" , 100 ) num_points_z = kwargs . pop ( \"num_points_z\" , 100 ) else : num_points_x = num_points num_points_y = num_points num_points_z = num_points xmin = kwargs . pop ( \"lx\" , - 1 * xmax ) ymin = kwargs . pop ( \"ly\" , - 1 * ymax ) zmin = kwargs . pop ( \"lz\" , - 1 * zmax ) x , y , z = _np . mgrid [ xmin : xmax : num_points_x * 1 j , ymin : ymax : num_points_y * 1 j , zmin : zmax : num_points_z * 1 j , ] return Point_Array3 ( x , y , z , unit = unit )","title":"grid3D()"},{"location":"utils/#pymagnet.utils._routines3D.slice3D","text":"Generates a planar slice of values Parameters: Name Type Description Default plane str plane. Defaults to \"xy\". 'xy' max1 float maximum along axis 1. Defaults to 1.0. 1.0 max2 float maximum along axis 2. Defaults to 1.0. 1.0 slice_value float constant value for third axis. Defaults to 0.0. 0.0 unit str length scale units. Defaults to \"mm\". 'mm' Kwargs num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Exceptions: Type Description Exception plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Type Description Point_Array3 array of x, y, and z values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def slice3D ( plane = \"xy\" , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = \"mm\" , ** kwargs ): \"\"\"Generates a planar slice of values Args: plane (str, optional): plane. Defaults to \"xy\". max1 (float, optional): maximum along axis 1. Defaults to 1.0. max2 (float, optional): maximum along axis 2. Defaults to 1.0. slice_value (float, optional): constant value for third axis. Defaults to 0.0. unit (str, optional): length scale units. Defaults to \"mm\". Kwargs: num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Raises: Exception: plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Point_Array3: array of x, y, and z values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) min1 = kwargs . pop ( \"xmin\" , - 1 * max1 ) min2 = kwargs . pop ( \"ymin\" , - 1 * max2 ) NPj = num_points * 1 j if plane . lower () == \"xy\" : x , y = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] z = _np . asarray ([ slice_value ]) z = _np . tile ( z , x . shape ) elif plane . lower () == \"xz\" : x , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] y = _np . asarray ([ slice_value ]) y = _np . tile ( y , x . shape ) elif plane . lower () == \"yz\" : y , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] x = _np . asarray ([ slice_value ]) x = _np . tile ( x , y . shape ) elif plane . lower () == \"custom\" : x = kwargs . pop ( \"custom_x\" , _np . array ([ 0.0 ])) y = kwargs . pop ( \"custom_y\" , _np . array ([ 0.0 ])) z = kwargs . pop ( \"custom_z\" , _np . array ([ 0.0 ])) else : raise Exception ( \"plane must be one of 'xy', 'xz, 'yz', or 'custom'\" ) return Point_Array3 ( x , y , z , unit = unit ) Contains functions needed to rotate and translate a triangle to lie in the xz plane and to divide it into two right angled triangles","title":"slice3D()"},{"location":"utils/#pymagnet.utils._trigonometry3D.align_triangle_to_y","text":"Rotates and translates a triangle in lie in the xz plane Parameters: Name Type Description Default triangle ndarray vertices of a triangle required rot_axis ndarray axis about which to rotate triangle required norm_vec ndarray normal to triangle required Returns: Type Description tuple aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_to_y ( triangle , rot_axis , norm_vec ): \"\"\"Rotates and translates a triangle in lie in the xz plane Args: triangle (ndarray): vertices of a triangle rot_axis (ndarray): axis about which to rotate triangle norm_vec (ndarray): normal to triangle Returns: tuple: aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) \"\"\" y_axis = _np . array ([ 0 , 1 , 0 ]) if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( y_axis , norm_vec ): # Parallel first_rotation = Quaternion () aligned_triangle = triangle else : # Anti-parallel first_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) else : angle = - _np . arccos ( _np . dot ( y_axis , norm_vec )) first_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) return aligned_triangle , first_rotation","title":"align_triangle_to_y()"},{"location":"utils/#pymagnet.utils._trigonometry3D.align_triangle_xz","text":"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Parameters: Name Type Description Default triangle ndarray vertices of triangle required longest_side int index of the longest side of triangle required Returns: Type Description tuple second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_xz ( triangle , longest_side ): \"\"\"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Args: triangle (ndarray): vertices of triangle longest_side (int): index of the longest side of triangle Returns: tuple: second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): \"\"\" x_axis = _np . array ([ 1 , 0 , 0 ]) y_axis = _np . array ([ 0 , 1 , 0 ]) z_axis = _np . array ([ 0 , 0 , 1 ]) # side_list = [0, 1, 2] # side_list.pop(longest_side) vec_x = return_axis_vector ( triangle , longest_side ) rot_axis = _np . cross ( x_axis , vec_x ) # Check aligment of base of triangle with x-axis if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( x_axis , vec_x ): # Parallel second_rotation = Quaternion () tri_x = triangle else : # Anti-parallel second_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) tri_x = rotate_points ( triangle , second_rotation ) else : angle = - _np . arccos ( _np . dot ( x_axis , vec_x )) second_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) tri_x = rotate_points ( triangle , second_rotation ) vec_z = return_z_vector ( tri_x , longest_side ) rot_axis = _np . cross ( z_axis , vec_z ) # Check aligment of triangle altitude with z-axis if _np . all ( _np . fabs ([ rot_axis ]) < ALIGN_CUTOFF ): # Check if parallel anti-parallel if check_sign ( z_axis , vec_z ): # Parallel third_rotation = Quaternion () else : # Anti-parallel third_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) else : angle = - _np . arccos ( _np . dot ( z_axis , vec_z )) third_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) return second_rotation , third_rotation","title":"align_triangle_xz()"},{"location":"utils/#pymagnet.utils._trigonometry3D.altitude","text":"Gets altitude to side a of a triangle. Parameters: Name Type Description Default a float longest side required b float triangle side required c float triangle side required Returns: Type Description float altitude to side a Source code in pymagnet/utils/_trigonometry3D.py def altitude ( a , b , c ): \"\"\"Gets altitude to side `a` of a triangle. Args: a (float): longest side b (float): triangle side c (float): triangle side Returns: float: altitude to side `a` \"\"\" s = ( a + b + c ) / 2 return 2 * _np . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )) / a","title":"altitude()"},{"location":"utils/#pymagnet.utils._trigonometry3D.check_sign","text":"Returns true if the signs of all elements of two arrays are the same Parameters: Name Type Description Default vector_1 ndarray input array 2 required vector_2 ndarray input array 2 required Returns: Type Description boolean True if elements in two arrays have the same sign Source code in pymagnet/utils/_trigonometry3D.py def check_sign ( vector_1 , vector_2 ): \"\"\"Returns true if the signs of all elements of two arrays are the same Args: vector_1 (ndarray): input array 2 vector_2 (ndarray): input array 2 Returns: boolean: True if elements in two arrays have the same sign \"\"\" sign_comp_1 = _np . fabs ( vector_1 + vector_2 ) sign_comp_2 = _np . fabs ( vector_1 ) + _np . fabs ( vector_2 ) return _np . allclose ( sign_comp_1 , sign_comp_2 , atol = 1e-6 )","title":"check_sign()"},{"location":"utils/#pymagnet.utils._trigonometry3D.norm_plane","text":"Calculates the normal to a triangular plane Parameters: Name Type Description Default vec ndarray/list/tuple (N,1) array required Returns: Type Description ndarray normal vector (N,) Source code in pymagnet/utils/_trigonometry3D.py def norm_plane ( vec ): \"\"\"Calculates the normal to a triangular plane Args: vec (ndarray/list/tuple): (N,1) array Returns: ndarray: normal vector (N,) \"\"\" norm = _np . cross ( vec [ 1 ] - vec [ 0 ], vec [ 2 ] - vec [ 0 ]) norm = norm / _np . linalg . norm ( norm ) return norm","title":"norm_plane()"},{"location":"utils/#pymagnet.utils._trigonometry3D.return_axis_vector","text":"Returns vector collinear to the longest side of a triangle Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray vector corresponding to longest side Source code in pymagnet/utils/_trigonometry3D.py def return_axis_vector ( triangle , longest_side ): \"\"\"Returns vector collinear to the longest side of a triangle Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: vector corresponding to longest side \"\"\" vector_A = triangle [ 1 ] - triangle [ 0 ] vector_A = vector_A / _np . linalg . norm ( vector_A ) vector_B = triangle [ 2 ] - triangle [ 1 ] vector_B = vector_B / _np . linalg . norm ( vector_B ) vector_C = triangle [ 2 ] - triangle [ 0 ] vector_C = vector_C / _np . linalg . norm ( vector_C ) vec_dict = { 0 : vector_A , 1 : vector_B , 2 : vector_C , } vec = vec_dict [ longest_side ] return vec","title":"return_axis_vector()"},{"location":"utils/#pymagnet.utils._trigonometry3D.return_z_vector","text":"Returns altitude vector from longest side Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray altitude vector Source code in pymagnet/utils/_trigonometry3D.py def return_z_vector ( triangle , longest_side ): \"\"\"Returns altitude vector from longest side Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: altitude vector \"\"\" new_vertex_dict = { 0 : [ triangle [ 2 , 0 ], triangle [ 0 , 1 ], triangle [ 0 , 2 ]], 1 : [ triangle [ 0 , 0 ], triangle [ 0 , 1 ], triangle [ 1 , 2 ]], 2 : [ triangle [ 1 , 0 ], triangle [ 2 , 1 ], triangle [ 2 , 2 ]], } new_vertex = _np . array ( new_vertex_dict [ longest_side ]) vec_z_dict = { 0 : triangle [ 2 ] - new_vertex , 1 : triangle [ 0 ] - new_vertex , 2 : triangle [ 1 ] - new_vertex , } vec_z = vec_z_dict [ longest_side ] vec_z = vec_z / _np . linalg . norm ( vec_z ) return vec_z","title":"return_z_vector()"},{"location":"utils/#pymagnet.utils._trigonometry3D.rotate_points","text":"Rotates a set of points Parameters: Name Type Description Default points [type] [description] required rotation_quaternion [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/utils/_trigonometry3D.py def rotate_points ( points , rotation_quaternion ): \"\"\"Rotates a set of points Args: points ([type]): [description] rotation_quaternion ([type]): [description] Returns: [type]: [description] \"\"\" x_rot , y_rot , z_rot = rotation_quaternion * points . T rotate_points = _np . vstack ([ x_rot , y_rot , z_rot ]) . T return rotate_points","title":"rotate_points()"},{"location":"utils/#pymagnet.utils._trigonometry3D.signed_area","text":"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Parameters: Name Type Description Default triangle ndarray 3x3 array of vertices required Returns: Type Description float signed area Source code in pymagnet/utils/_trigonometry3D.py @jit def signed_area ( triangle ): \"\"\"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Args: triangle (ndarray): 3x3 array of vertices Returns: float: signed area \"\"\" j = 1 NP = 3 area = 0.0 for i in range ( NP ): j = j % NP area += ( triangle [ j ][ 0 ] - triangle [ i ][ 0 ]) * ( triangle [ j ][ 2 ] + triangle [ i ][ 2 ]) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points area /= 2.0 return area pymagnets.utils._vector_structs Private module consiting of vector and point array classes and their methods.","title":"signed_area()"},{"location":"utils/#pymagnet.utils._vector_structs.Field1","text":"1D Field vector class consisting of numpy arrays of z values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Field1"},{"location":"utils/#pymagnet.utils._vector_structs.Field1.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"utils/#pymagnet.utils._vector_structs.Field2","text":"2D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Field2"},{"location":"utils/#pymagnet.utils._vector_structs.Field2.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"utils/#pymagnet.utils._vector_structs.Field3","text":"3D Field vector class consisting of numpy arrays of x and y values Parameters: Name Type Description Default x required y required z required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Field3"},{"location":"utils/#pymagnet.utils._vector_structs.Field3.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array1","text":"2D vector class consisting of numpy arrays of x and y coordinates Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Point_Array1"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array1.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Prism , Cylinder current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . depth = magnet . depth * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val","title":"change_unit()"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array2","text":"2D vector class consisting of numpy arrays of x and y coordinates Parameters: Name Type Description Default x required y required Methods calculates the magnitude of the fields at every point and stores in self.n","title":"Point_Array2"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array2.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Rectangle , Square , Circle , PolyMagnet current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Rectangle ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Square ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Circle ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , PolyMagnet ): magnet . polygon . vertices = ( scale_val * _np . array ( magnet . polygon . vertices ) ) . tolist ()","title":"change_unit()"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array3","text":"","title":"Point_Array3"},{"location":"utils/#pymagnet.utils._vector_structs.Point_Array3.change_unit","text":"Converts vector from one unit scale to another Parameters: Name Type Description Default new_unit string SI prefix, eg cm, mm required Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts vector from one unit scale to another Args: new_unit (string): SI prefix, eg cm, mm \"\"\" from ..magnets import Magnet , Prism , Cube , Cylinder , Sphere , Mesh current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val magnet . depth = magnet . depth * scale_val elif issubclass ( magnet . __class__ , Cube ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val elif issubclass ( magnet . __class__ , Sphere ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , Mesh ): magnet . mesh_vectors = magnet . mesh_vectors * scale_val Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"change_unit()"}]}