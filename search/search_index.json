{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pymagnet User friendly magnetic field calculations in Python Getting Started Installing pymagnet can be done using python -m pip install pymagnet Pymagnet is a collection of routines to calculate and plot the magnetic field due to arbitrary 2D and 3D objects, like cubes or cylinders, as well as complex non-convex structures stored in STL files. The library can also calculate the magnetic forces and torques on one magnet due to all other magnets in the system. The approach assumes the magnets are uniformly magnetised, and fully transparent to magnetic fields. There are some drawbacks to this compared to Finite Element Methods (FEM), but with the advantage of significantly faster calculations. The current version is written in Python with some speed up using Numpy and Numba , but the backend is being ported to Rust for improved performance. Features This code uses analytical expressions to calculate the magnetic field due to simple magnets: 3D: cubes, prisms (cuboids), cylinders, spheres Cylinder Plots 2D: rectangles, squares, circles 2D contour plot and streamplot of a long bipolar rod and complex compound objects: 3D: Polyhedra stored as STL meshes 2D: Polygons constructed from collections of line elements There are helper functions to plot the data as line, contour, slice, and volume plots, but the underlying data is also accessible. Prerequisites Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy numpy-stl numba matplotlib plotly Warning Rotate spheres using \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , as the magnetisation is always along \\(z\\) , the magnetisation angles \\(\\theta\\) and \\(\\phi\\) , do not exist. Examples Examples can be found in the repository . Usage Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 . Licensing Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits. Contribution Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Home"},{"location":"#pymagnet","text":"User friendly magnetic field calculations in Python","title":"Pymagnet"},{"location":"#getting-started","text":"Installing pymagnet can be done using python -m pip install pymagnet Pymagnet is a collection of routines to calculate and plot the magnetic field due to arbitrary 2D and 3D objects, like cubes or cylinders, as well as complex non-convex structures stored in STL files. The library can also calculate the magnetic forces and torques on one magnet due to all other magnets in the system. The approach assumes the magnets are uniformly magnetised, and fully transparent to magnetic fields. There are some drawbacks to this compared to Finite Element Methods (FEM), but with the advantage of significantly faster calculations. The current version is written in Python with some speed up using Numpy and Numba , but the backend is being ported to Rust for improved performance.","title":"Getting Started"},{"location":"#features","text":"This code uses analytical expressions to calculate the magnetic field due to simple magnets: 3D: cubes, prisms (cuboids), cylinders, spheres Cylinder Plots 2D: rectangles, squares, circles 2D contour plot and streamplot of a long bipolar rod and complex compound objects: 3D: Polyhedra stored as STL meshes 2D: Polygons constructed from collections of line elements There are helper functions to plot the data as line, contour, slice, and volume plots, but the underlying data is also accessible.","title":"Features"},{"location":"#prerequisites","text":"Ensure you have Python version >= 3.6 (to use f-strings), and the following packages: numpy numpy-stl numba matplotlib plotly Warning Rotate spheres using \\(\\alpha\\) , \\(\\beta\\) , \\(\\gamma\\) , as the magnetisation is always along \\(z\\) , the magnetisation angles \\(\\theta\\) and \\(\\phi\\) , do not exist.","title":"Prerequisites"},{"location":"#examples","text":"Examples can be found in the repository .","title":"Examples"},{"location":"#usage","text":"Forms of this library have been used in a number of projects including Liquid flow and control without solid walls, Nature 2020 .","title":"Usage"},{"location":"#licensing","text":"Source code licensed under the Mozilla Public License Version 2.0 Documentation is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license. This is a human-readable summary of (and not a substitute for) the license, adapted from CS50x . Official translations of this license are available in other languages. You are free to: Share \u2014 copy and redistribute the material in any medium or format. Adapt \u2014 remix, transform, and build upon the material. Under the following terms: Attribution \u2014 You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. ShareAlike \u2014 If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original No additional restrictions \u2014 You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.","title":"Licensing"},{"location":"#contribution","text":"Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you shall be licensed as above, without any additional terms or conditions.","title":"Contribution"},{"location":"examples/","text":"Examples Examples can be found in the repository . Or run on Colab: 2D Examples Getting Started 1D Simple Plots 2D Standard Shapes 2D Arbitrary Polygons Misc. Examples 3D Examples Analytical Shapes Spheres 3D STL Meshes 3D Stanford Bunny Forces and Torques Cubes Cylinders Spheres STL Cubes STL Pentagonal Prisms Binder You can test out the libraries on Binder, but performance is not as good:","title":"Examples"},{"location":"examples/#examples","text":"Examples can be found in the repository . Or run on Colab:","title":"Examples"},{"location":"examples/#2d-examples","text":"Getting Started 1D Simple Plots 2D Standard Shapes 2D Arbitrary Polygons Misc. Examples","title":"2D Examples"},{"location":"examples/#3d-examples","text":"Analytical Shapes Spheres 3D STL Meshes 3D Stanford Bunny","title":"3D Examples"},{"location":"examples/#forces-and-torques","text":"Cubes Cylinders Spheres STL Cubes STL Pentagonal Prisms","title":"Forces and Torques"},{"location":"examples/#binder","text":"You can test out the libraries on Binder, but performance is not as good:","title":"Binder"},{"location":"forces_torques/","text":"Forces and Torques Total force: \\[ \\mathbf{F} = -\\int_V (\\nabla \\cdot \\mathbf{M}) \\mathbf{B'} \\: dv + \\int_S (\\mathbf{M} \\cdot \\mathbf{n}) \\mathbf{B'} \\: ds \\] which can be written as \\[ \\mathbf{F} = \\int_V \\rho_m \\mathbf{B'} \\: dv + \\int_S \\sigma_m \\mathbf{B'} \\: ds \\] where \\(\\rho_m = -\\nabla \\cdot \\mathbf{M}\\) and \\(\\sigma_m = \\mathbf{M} \\cdot \\mathbf{n}\\) are the volume and surface charge densities. For a uniformly magnetised body, \\(\\rho_m = -\\nabla \\cdot \\mathbf{M} = 0\\) , so the total magnetic force acting on a magnet due to an external field \\(\\mathbf{B'}\\) can be deduced using the surface charge model: \\[ \\mathbf{F} = \\int_S \\sigma_m \\mathbf{B'} \\: ds \\] Similarly, the torque on a uniformly magnetised body can be determined using \\[ \\mathbf{T} = \\int_S \\sigma_m (\\mathbf{r} \\times \\mathbf{B'}) \\: ds \\] where \\(\\mathbf{r}\\) is the vector from the point about which the torque is computed.","title":"Forces & Torques"},{"location":"forces_torques/#forces-and-torques","text":"Total force: \\[ \\mathbf{F} = -\\int_V (\\nabla \\cdot \\mathbf{M}) \\mathbf{B'} \\: dv + \\int_S (\\mathbf{M} \\cdot \\mathbf{n}) \\mathbf{B'} \\: ds \\] which can be written as \\[ \\mathbf{F} = \\int_V \\rho_m \\mathbf{B'} \\: dv + \\int_S \\sigma_m \\mathbf{B'} \\: ds \\] where \\(\\rho_m = -\\nabla \\cdot \\mathbf{M}\\) and \\(\\sigma_m = \\mathbf{M} \\cdot \\mathbf{n}\\) are the volume and surface charge densities. For a uniformly magnetised body, \\(\\rho_m = -\\nabla \\cdot \\mathbf{M} = 0\\) , so the total magnetic force acting on a magnet due to an external field \\(\\mathbf{B'}\\) can be deduced using the surface charge model: \\[ \\mathbf{F} = \\int_S \\sigma_m \\mathbf{B'} \\: ds \\] Similarly, the torque on a uniformly magnetised body can be determined using \\[ \\mathbf{T} = \\int_S \\sigma_m (\\mathbf{r} \\times \\mathbf{B'}) \\: ds \\] where \\(\\mathbf{r}\\) is the vector from the point about which the torque is computed.","title":"Forces and Torques"},{"location":"code_reference/magnets/","text":"Magnets module pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Magnet Base class This private module implements the registry and base magnet classes Magnet Magnet base class Returns: Type Description Magnet magnet base class Registry Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset() __init_subclass__ () classmethod special This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet_base.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = [] __new__ ( cls , * args , ** kwargs ) special staticmethod Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet_base.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o get_instances () classmethod Gets lists of instances Returns: Type Description set all class instances Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_instances ( cls ): \"\"\"Gets lists of instances Returns: set: all class instances \"\"\" return cls . instances get_num_instances ( Print_Val = False ) classmethod Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances ) print_instances () classmethod Prints class instantiations Source code in pymagnet/magnets/_magnet_base.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance ) reset () classmethod Removes all instances from registry. Source code in pymagnet/magnets/_magnet_base.py @classmethod def reset ( cls ): \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = [] list_magnets () Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet_base.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances () reset_magnets () Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet_base.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2D import Magnet2D , Rectangle , Square , Circle from ._polygon2D import PolyMagnet from ._magnet3D import Magnet3D , Prism , Cube , Cylinder , Sphere from ._polygon3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet2D , Rectangle , Square , Circle , PolyMagnet , Magnet3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet. magnetic_field_cylinder_1D ( magnet , z ) Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, Cylinder required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, Cylinder z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . center [ 2 ] zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) Bz = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) Bz *= Jr / 2 data = Field1 ( Bz ) return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None magnetic_field_prism_1D ( magnet , z ) Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, one of Prism, or Cube required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, one of Prism, or Cube z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr z_local = _np . asarray ( z ) - c - magnet . center [ 2 ] ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) Bz = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) Bz *= Jr / PI field = Field1 ( Bz ) return field else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None 2D Magnet Classes This private module implements the Rectangle and Square and Circle 2D magnet classes. The parent class Magnet2D implements the location and orientation methods, i.e. magnet center and quaternion methods for rotating the magnet with respect to each principal axis. Circle Circle 2D Magnet Class __init__ ( self , radius = 10 , Jr = 1.0 , ** kwargs ) special Init Method Parameters: Name Type Description Default radius float Radius. Defaults to 10.0. 10 Jr float Remnant magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Unused. For rotations use phi instead center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0) phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , radius = 10 , Jr = 1.0 , # local magnetisation ** kwargs , ): \"\"\"Init Method Args: radius (float, optional): Radius. Defaults to 10.0. Jr (float, optional): Remnant magnetisation. Defaults to 1.0. Kwargs: alpha (float): Unused. For rotations use phi instead center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0) phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( Jr , ** kwargs ) self . radius = radius self . phi = kwargs . pop ( \"phi\" , 0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 ])) self . center = _np . asarray ( self . center ) get_field ( self , x , y ) Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x ndarray x coordinates required y narray y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (ndarray): x coordinates y (narray): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ..utils._conversions import cart2pol , vector_pol2cart from ..utils._routines2D import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) rho , phi = cart2pol ( xi , yi ) Brho , Bphi = self . _calcB_polar ( rho , phi - self . phi_rad ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . center [ 0 ], y - self . center [ 1 ]) Brho , Bphi = self . _calcB_polar ( rho , phi - self . phi_rad ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By get_Jr ( self ) Returns signed remnant magnetisation Returns: Type Description ndarray remnant magnetisation Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns signed remnant magnetisation Returns: ndarray: remnant magnetisation \"\"\" return _np . array ([ self . Jx , self . Jy ]) get_size ( self ) Returns radius Returns: Type Description ndarray radius Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns radius Returns: ndarray: radius \"\"\" return _np . array ([ self . radius ]) Magnet2D 2D Magnet Base Class __init__ ( self , Jr , ** kwargs ) special Init Method Parameters: Name Type Description Default Jr float signed magnetised of remnant magnetisationnega required Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , Jr , ** kwargs ) -> None : \"\"\"Init Method Args: Jr (float): signed magnetised of remnant magnetisationnega Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). \"\"\" super () . __init__ () self . Jr = Jr # Magnet rotation w.r.t. x-axis self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_radians = _np . deg2rad ( self . alpha ) self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 ])) self . center = _np . asarray ( self . center ) get_center ( self ) Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center get_field ( self ) Calculates the magnetic field. This is a template that needs to be implemented for each magnet Source code in pymagnet/magnets/_magnet2D.py def get_field ( self ): \"\"\"Calculates the magnetic field. This is a template that needs to be implemented for each magnet \"\"\" pass get_force_torque ( self ) Calculates the force and torque on a magnet due to all other magnets. This is a template that needs to be implemented for each magnet. Source code in pymagnet/magnets/_magnet2D.py def get_force_torque ( self ): \"\"\"Calculates the force and torque on a magnet due to all other magnets. This is a template that needs to be implemented for each magnet. \"\"\" pass get_orientation ( self ) Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha Rectangle Rectangular 2D Magnet Class __init__ ( self , width = 20.0 , height = 40.0 , Jr = 1.0 , ** kwargs ) special Init Method Parameters: Name Type Description Default width float Magnet Width. Defaults to 20.0. 20.0 height float Magnet Height. Defaults to 40.0. 40.0 Jr float Remnant Magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , width = 20.0 , height = 40.0 , Jr = 1.0 , ** kwargs ): \"\"\"Init Method Args: width (float, optional): Magnet Width. Defaults to 20.0. height (float, optional): Magnet Height. Defaults to 40.0. Jr (float, optional): Remnant Magnetisation. Defaults to 1.0. Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( Jr , ** kwargs ) self . width = width self . height = height self . a = width / 2 self . b = height / 2 self . phi = kwargs . pop ( \"phi\" , 90 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy get_field ( self , x , y ) Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x ndarray x co-ordinates required y ndarray y co-ordinates required Returns: Type Description tuple magnetic field vector Bx (ndarray), By (ndarray) Source code in pymagnet/magnets/_magnet2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (ndarray): x co-ordinates y (ndarray): y co-ordinates Returns: tuple: magnetic field vector Bx (ndarray), By (ndarray) \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx / self . Jr ) > Magnet2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi , yi ) Bty = self . _calcBy_mag_x ( xi , yi ) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) By = self . _calcBy_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy / self . Jr ) > Magnet2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : Btx = self . _calcBx_mag_y ( xi , yi ) Bty = self . _calcBy_mag_y ( xi , yi ) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) By += self . _calcBy_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) return Bx , By get_Jr ( self ) Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ]) get_size ( self ) Returns magnet dimesions Returns: Type Description ndarray numpy array [width, height] Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns magnet dimesions Returns: ndarray: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ]) Square Square 2D Magnet Class __init__ ( self , width = 20 , Jr = 1.0 , ** kwargs ) special Init Method Parameters: Name Type Description Default width float Sqaure side length. Defaults to 20.0. 20 Jr float Remnant Magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , width = 20 , Jr = 1.0 , ** kwargs ): \"\"\"Init Method Args: width (float, optional): Sqaure side length. Defaults to 20.0. Jr (float, optional): Remnant Magnetisation. Defaults to 1.0. Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( width = width , height = width , Jr = Jr , ** kwargs ) 2D Polygon Magnet class Line Line Class for storing properties of a sheet manget __init__ ( self , length , center , beta , K ) special Init Method Parameters: Name Type Description Default length float side length required center ndarray magnet center (x, y) required beta float Orientation w.r.t. z-axis in degrees required K float Sheet current density in tesla required Source code in pymagnet/magnets/_polygon2D.py def __init__ ( self , length , center , beta , K ): \"\"\"Init Method Args: length (float): side length center (ndarray): magnet center (x, y) beta (float): Orientation w.r.t. z-axis in degrees K (float): Sheet current density in tesla \"\"\" self . length = length self . center = center self . beta = beta self . beta_rad = _np . deg2rad ( beta ) self . xc = center [ 0 ] self . yc = center [ 1 ] self . K = K self . tol = MAG_TOL get_center ( self ) Returns line center Returns: Type Description ndarray center (x,y) Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns line center Returns: ndarray: center (x,y) \"\"\" return self . center get_field ( self , x , y ) Calculates the magnetic field due to a sheet magnet First a transformation into the local coordinates is made, the field calculated and then the magnetic field it rotated out to the global coordinates Parameters: Name Type Description Default x ndarray x-coordinates required y ndarray y-coordinates required Returns: Type Description tuple Bx (ndarray), By (ndarray) magnetic field vector Source code in pymagnet/magnets/_polygon2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field due to a sheet magnet First a transformation into the local coordinates is made, the field calculated and then the magnetic field it rotated out to the global coordinates Args: x (ndarray): x-coordinates y (ndarray): y-coordinates Returns: tuple: Bx (ndarray), By (ndarray) magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . beta_rad ) > self . tol : xt , yt = rotate_points_2D ( x - self . xc , y - self . yc , 2 * PI - self . beta_rad ) Btx , Bty = _sheet_field ( xt , yt , self . length / 2 , self . K ) Bx , By = rotate_points_2D ( Btx , Bty , self . beta_rad ) else : Bx , By = _sheet_field ( x - self . xc , y - self . yc , self . length / 2 , self . K ) return Bx , By LineUtils Utility class consisting of rountines for 2D line elements line_center ( vertex_1 , vertex_2 ) staticmethod Gets midpoint of two vertices Parameters: Name Type Description Default vertex_1 ndarray vertex 1 required vertex_2 ndarray vertex 2 required Returns: Type Description ndarray midpoint Source code in pymagnet/magnets/_polygon2D.py @staticmethod def line_center ( vertex_1 , vertex_2 ): \"\"\"Gets midpoint of two vertices Args: vertex_1 (ndarray): vertex 1 vertex_2 (ndarray): vertex 2 Returns: ndarray: midpoint \"\"\" xc = ( vertex_1 [ 0 ] + vertex_2 [ 0 ]) / 2 yc = ( vertex_1 [ 1 ] + vertex_2 [ 1 ]) / 2 return _np . array ([ xc , yc ]) signed_area ( polygon ) staticmethod Calculates signed area of a polygon Parameters: Name Type Description Default polygon Polygon Polygon instance required Returns: Type Description float signed area Source code in pymagnet/magnets/_polygon2D.py @staticmethod def signed_area ( polygon ): \"\"\"Calculates signed area of a polygon Args: polygon (Polygon): Polygon instance Returns: float: signed area \"\"\" j = 1 NP = polygon . num_vertices () area = 0 norm = _np . empty ([ NP , 2 ]) center = _np . empty ([ NP , 2 ]) beta = _np . empty ( NP ) # angle w.r.t. y axis length = _np . empty ( NP ) for i in range ( NP ): j = j % NP area += ( polygon . vertices [ j ][ 0 ] - polygon . vertices [ i ][ 0 ]) * ( polygon . vertices [ j ][ 1 ] + polygon . vertices [ i ][ 1 ] ) norm [ i , :], length [ i ] = LineUtils . unit_norm ( polygon . vertices [ i ], polygon . vertices [ j ] ) center [ i , :] = LineUtils . line_center ( polygon . vertices [ i ], polygon . vertices [ j ] ) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points if area < 0 : norm *= - 1 beta [:] = _np . rad2deg ( _np . arctan2 ( norm [:, 1 ], norm [:, 0 ])) return area / 2.0 , norm , beta , length , center unit_norm ( vertex_1 , vertex_2 , clockwise = True ) staticmethod Get unit normal to vertex Parameters: Name Type Description Default vertex_1 ndarray vertex 1 required vertex_2 ndarray vertex 2 required clockwise bool Clockwise orientation of points. Defaults to True. True Returns: Type Description tuple normal vector (ndarray), length i.e. distance between vertices (float) Source code in pymagnet/magnets/_polygon2D.py @staticmethod def unit_norm ( vertex_1 , vertex_2 , clockwise = True ): \"\"\"Get unit normal to vertex Args: vertex_1 (ndarray): vertex 1 vertex_2 (ndarray): vertex 2 clockwise (bool, optional): Clockwise orientation of points. Defaults to True. Returns: tuple: normal vector (ndarray), length i.e. distance between vertices (float) \"\"\" dx = vertex_1 [ 0 ] - vertex_2 [ 0 ] dy = vertex_1 [ 1 ] - vertex_2 [ 1 ] # Clockwise winding of points: if clockwise : norm = _np . array ([ dy , - dx ]) else : norm = _np . array ([ - dy , dx ]) length = _np . linalg . norm ( norm ) norm = norm / length return norm , length Polygon Polygon class for generating list of vertices append ( self , vertex ) Appends vertex to list of vertices Parameters: Name Type Description Default vertex list list of vertices required Source code in pymagnet/magnets/_polygon2D.py def append ( self , vertex ): \"\"\"Appends vertex to list of vertices Args: vertex (list): list of vertices \"\"\" if len ( vertex ) != 2 : print ( \"Error\" ) if type ( vertex ) == tuple : self . vertices . append ( vertex ) elif len ( vertex ) == 2 : self . vertices . append ( tuple ( vertex )) self . set_center () check_radius ( N , apothem , length , radius ) staticmethod Checks which of apothem, side length, or radius has been passed as kwargs to gen_polygon() . Order of precendence is apothem, length, radius. Parameters: Name Type Description Default N int Number of sides required apothem float polygon apothem required length float side length required radius float outcircle radius required Exceptions: Type Description Exception One of apothem, length, or raduis must be defined Returns: Type Description float returns radius Source code in pymagnet/magnets/_polygon2D.py @staticmethod def check_radius ( N , apothem , length , radius ): \"\"\"Checks which of apothem, side length, or radius has been passed as kwargs to `gen_polygon()`. Order of precendence is apothem, length, radius. Args: N (int): Number of sides apothem (float): polygon apothem length (float): side length radius (float): outcircle radius Raises: Exception: One of apothem, length, or raduis must be defined Returns: float: returns radius \"\"\" if apothem is not None : return apothem / _np . around ( _np . cos ( PI / N ), 4 ) elif length is not None : return length / _np . around ( 2 * _np . sin ( PI / N ), 4 ) elif radius is not None : return radius else : raise Exception ( \"Error, one of apothem, length, or radius must be defined.\" ) gen_polygon ( N = 6 , center = ( 0.0 , 0.0 ), alpha = 0.0 , ** kwargs ) staticmethod Generates regular polygon. One of apothem, side length or radius must be defined. Parameters: Name Type Description Default N int Number of sides. Defaults to 6. 6 center tuple Polygon center. Defaults to (0.0, 0.0). (0.0, 0.0) alpha float Orientration with respect to x-axis. Defaults to 0.0. 0.0 Exceptions: Type Description Exception N must be > 2 Returns: Type Description ndarray polygon vertices Source code in pymagnet/magnets/_polygon2D.py @staticmethod def gen_polygon ( N = 6 , center = ( 0.0 , 0.0 ), alpha = 0.0 , ** kwargs ): \"\"\"Generates regular polygon. One of apothem, side length or radius must be defined. Args: N (int, optional): Number of sides. Defaults to 6. center (tuple, optional): Polygon center. Defaults to (0.0, 0.0). alpha (float, optional): Orientration with respect to x-axis. Defaults to 0.0. Raises: Exception: N must be > 2 Returns: ndarray: polygon vertices \"\"\" N = int ( N ) if N < 3 : raise Exception ( \"Error, N must be > 2.\" ) apothem = kwargs . pop ( \"apothem\" , None ) length = kwargs . pop ( \"length\" , None ) radius = kwargs . pop ( \"radius\" , None ) radius = Polygon . check_radius ( N , apothem , length , radius ) k = _np . arange ( 0 , N , 1 ) xc = center [ 0 ] yc = center [ 1 ] def f ( N ): if N % 2 == 0 : return PI / N + _np . deg2rad ( alpha ) else : return PI / N + PI + _np . deg2rad ( alpha ) xv = xc + radius * _np . sin ( 2 * PI * k / N + f ( N )) yv = yc + radius * _np . cos ( 2 * PI * k / N + f ( N )) poly_verts = _np . vstack (( xv , yv )) . T . tolist () return poly_verts num_vertices ( self ) Gets number of vertices Returns: Type Description int number of vertices Source code in pymagnet/magnets/_polygon2D.py def num_vertices ( self ): \"\"\"Gets number of vertices Returns: int: number of vertices \"\"\" return len ( self . vertices ) set_center ( self ) Sets center of polygon to be centroid Source code in pymagnet/magnets/_polygon2D.py def set_center ( self ): \"\"\"Sets center of polygon to be centroid\"\"\" self . center = _np . mean ( _np . asarray ( self . vertices ), axis = 0 ) PolyMagnet 2D Magnet Polygon class. __init__ ( self , Jr , ** kwargs ) special Init method Note When creating a regular polygon, one of apothem, radius, or length must be defined as a kwarg or an exception will be raised. When creating a regular polygon, the number of sides num_sides must be at least 3 or an exception will be raised. When creating a custom polygon at least one vertex pair must be defined with vertices or an exception will be raised. Parameters: Name Type Description Default Jr float signed magnitude of remnant magnetisation required Kwargs alpha (float): Not used theta (float): Orientation of magnet w.r.t x-axis of magnet phi (float): Orientation of magnetisation w.r.t x-axis of magnet in degrees. Defaults to 90.0. center (ndarray): magnet center (x, y). Defaults to (0.0, 0.0) length (float): side length if creating a regular polygon apothem (float): apothem (incircle radius) if creating a regular polygon radius (float): radius (circumcircle radius) if creating a regular polygon num_sides (int): number of sides of a regular polygon. Defaults to 6. custom_polygon (bool): Flag to define a custom polygon. Defaults to False. vertices (ndarray, list): List of custom vertices. Defaults to None. Exceptions: Type Description Exception If creating a custom polygon, vertices must not be None. Source code in pymagnet/magnets/_polygon2D.py def __init__ ( self , Jr , ** kwargs ) -> None : \"\"\"Init method NOTE: * When creating a regular polygon, one of apothem, radius, or length must be defined as a kwarg or an exception will be raised. * When creating a regular polygon, the number of sides `num_sides` must be at least 3 or an exception will be raised. * When creating a custom polygon at least one vertex pair must be defined with `vertices` or an exception will be raised. Args: Jr (float): signed magnitude of remnant magnetisation Kwargs: alpha (float): Not used theta (float): Orientation of magnet w.r.t x-axis of magnet phi (float): Orientation of magnetisation w.r.t x-axis of magnet in degrees. Defaults to 90.0. center (ndarray): magnet center (x, y). Defaults to (0.0, 0.0) length (float): side length if creating a regular polygon apothem (float): apothem (incircle radius) if creating a regular polygon radius (float): radius (circumcircle radius) if creating a regular polygon num_sides (int): number of sides of a regular polygon. Defaults to 6. custom_polygon (bool): Flag to define a custom polygon. Defaults to False. vertices (ndarray, list): List of custom vertices. Defaults to None. Raises: Exception: If creating a custom polygon, `vertices` must not be None. \"\"\" from ..utils._routines2D import rotate_points_2D super () . __init__ ( Jr , ** kwargs ) # Magnet rotation w.r.t. x-axis self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_radians = _np . deg2rad ( self . alpha ) self . theta = kwargs . pop ( \"theta\" , 0.0 ) self . theta_radians = _np . deg2rad ( self . theta ) self . phi = kwargs . pop ( \"phi\" , 90.0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL self . area = None self . custom_polygon = kwargs . pop ( \"custom_polygon\" , False ) self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 , 0.0 ])) self . center = _np . asarray ( self . center ) if self . custom_polygon : vertices = kwargs . pop ( \"vertices\" , None ) if vertices is None : raise Exception ( \"Error, no vertices were defined.\" ) vertices = _np . atleast_2d ( vertices ) x_rot , y_rot = rotate_points_2D ( vertices [:, 0 ], vertices [:, 1 ], self . theta_radians , # + self.alpha_radians, ) vertices = _np . stack ([ x_rot , y_rot ]) . T + self . center self . polygon = Polygon ( vertices = vertices . tolist ()) else : self . length = kwargs . pop ( \"length\" , None ) self . apothem = kwargs . pop ( \"apothem\" , None ) self . radius = kwargs . pop ( \"radius\" , None ) self . num_sides = kwargs . pop ( \"num_sides\" , 6 ) self . radius = Polygon . check_radius ( self . num_sides , self . apothem , self . length , self . radius , ) # Generate Polygon self . polygon = Polygon ( vertices = Polygon . gen_polygon ( self . num_sides , self . center , self . theta , # + self.alpha, length = self . length , apothem = self . apothem , radius = self . radius , ), center = self . center , ) get_center ( self ) Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center get_field ( self , x , y ) Calculates the magnetic field of a polygon due to each face Parameters: Name Type Description Default x ndarray x-coordinates required y ndarray y-coordinates required Returns: Type Description tuple Bx (ndarray), By (ndarray) magnetic field vector Source code in pymagnet/magnets/_polygon2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field of a polygon due to each face Args: x (ndarray): x-coordinates y (ndarray): y-coordinates Returns: tuple: Bx (ndarray), By (ndarray) magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) beta , length , center , K = self . _gen_sheet_magnets () if _np . fabs ( self . alpha_radians ) > self . tol : pass print ( \"Arbitrary rotation with alpha not yet implemented!!\" ) # FIXME: rotate centres # xt, yt = rotate_points_2D(x - self.xc, y - self.yc, self.alpha_radians) # beta += self.alpha # xc_rot, yc_rot = rotate_points_2D( # center[:, 0] - self.xc, # center[:, 1] - self.yc, # self.alpha_radians, # ) # center[:, 0] = xc_rot # center[:, 1] = yc_rot # # # for i in range(len(K)): # sheet = Line(length[i], center[i], beta[i], K[i]) # Btx, Bty = sheet.get_field(xt, yt) # Btx, Bty = rotate_points_2D(Btx, Bty, 2 * PI - self.alpha_radians) # Bx += Btx # By += Bty for i in range ( len ( K )): sheet = Line ( length [ i ], center [ i ], beta [ i ], K [ i ]) Btx , Bty = sheet . get_field ( x , y ) Bx += Btx By += Bty return Bx , By get_orientation ( self ) Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_polygon2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha Mesh Mesh Magnet Class. __init__ ( self , filename , Jr = 1.0 , ** kwargs ) special Init Method Parameters: Name Type Description Default filename string path to stl file to be imported required Jr float Signed remnant magnetisation. Defaults to 1.0. 1.0 Kwargs phi (float): theta (float): mesh_scale (float): scaling factor if mesh needs to be resized. Defaults to 1.0 Source code in pymagnet/magnets/_polygon3D.py def __init__ ( self , filename , Jr = 1.0 , # local magnetisation ** kwargs , ): \"\"\"Init Method Args: filename (string): path to stl file to be imported Jr (float, optional): Signed remnant magnetisation. Defaults to 1.0. Kwargs: phi (float): theta (float): mesh_scale (float): scaling factor if mesh needs to be resized. Defaults to 1.0 \"\"\" super () . __init__ ( Jr , ** kwargs ) self . phi = kwargs . pop ( \"theta\" , 90.0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . theta = kwargs . pop ( \"phi\" , 0.0 ) self . theta_rad = _np . deg2rad ( self . theta ) self . mesh_scale = kwargs . pop ( \"mesh_scale\" , 1.0 ) self . _filename = filename ( self . mesh_vectors , self . mesh_normals , self . volume , self . centroid , ) = self . _import_mesh () self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ) * _np . sin ( self . theta_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ) * _np . sin ( self . theta_rad ), decimals = 6 ) self . Jz = _np . around ( Jr * _np . cos ( self . theta_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy self . J = _np . array ([ self . Jx , self . Jy , self . Jz ]) # FIXME: Sort out rotation of magnetisation with rotation of mesh # if _np.any( # _np.fabs([self.alpha_rad, self.beta_rad, self.gamma_rad]) > ALIGN_CUTOFF # ): # mag_rotation = Quaternion.gen_rotation_quaternion( # self.alpha_rad, self.beta_rad, self.gamma_rad # ) # Jrot = mag_rotation * self.J # self.Jx = Jrot[0] # self.Jy = Jrot[1] # self.Jz = Jrot[2] # self.J = _np.array([self.Jx, self.Jy, self.Jz]) self . Jnorm = _np . dot ( self . J , self . mesh_normals . T ) calcB_triangle ( self , triangle , Jr , x , y , z , i ) Calculates the magnetic field due to a triangle Parameters: Name Type Description Default triangle ndarray Vertices of a triangle required Jr float Remnant magnetisation component normal to triangle required x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple Bx, By, Bz magnetic field components Source code in pymagnet/magnets/_polygon3D.py def calcB_triangle ( self , triangle , Jr , x , y , z , i ): \"\"\"Calculates the magnetic field due to a triangle Args: triangle (ndarray): Vertices of a triangle Jr (float): Remnant magnetisation component normal to triangle x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: Bx, By, Bz magnetic field components \"\"\" ( total_rotation , rotated_triangle , offset , RA_triangle1 , RA_triangle2 , ) = _rotate_triangle ( triangle , Jr ) # Prepare points and quaternion pos_vec = Quaternion . _prepare_vector ( x , y , z ) # Rotate points x_rot , y_rot , z_rot = total_rotation * pos_vec norm1 = norm_plane ( triangle ) if _np . allclose ( norm1 , [ 0 , - 1 , 0 ], atol = ALIGN_CUTOFF ) and Jr < 0 : RA_triangle1 , RA_triangle2 = RA_triangle2 , RA_triangle1 Btx , Bty , Btz = self . _calcB_2_triangles ( RA_triangle1 , RA_triangle2 , Jr , x_rot - offset [ 0 ], y_rot - offset [ 1 ], z_rot - offset [ 2 ], ) Bvec = Quaternion . _prepare_vector ( Btx , Bty , Btz ) Bx , By , Bz = total_rotation . get_conjugate () * Bvec return Bx , By , Bz , rotated_triangle , offset , total_rotation get_center ( self ) Returns magnet center Returns: Type Description ndarray magnet center Source code in pymagnet/magnets/_polygon3D.py def get_center ( self ): \"\"\"Returns magnet center Returns: ndarray: magnet center \"\"\" return self . center get_field ( self , x , y , z ) Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_polygon3D.py def get_field ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" B = self . _get_field_internal ( x , y , z ) return B . x , B . y , B . z get_force_torque ( self , depth = 4 , unit = 'mm' ) Calculates the force and torque on a prism magnet due to all other magnets. Parameters: Name Type Description Default depth int Number of recursions of division by 4 per simplex 4 unit str Length scale. Defaults to 'mm'. 'mm' Returns: Type Description tuple force (ndarray (3,) ) and torque (ndarray (3,) ) Source code in pymagnet/magnets/_polygon3D.py def get_force_torque ( self , depth = 4 , unit = \"mm\" ): \"\"\"Calculates the force and torque on a prism magnet due to all other magnets. Args: depth (int, optional): Number of recursions of division by 4 per simplex unit (str, optional): Length scale. Defaults to 'mm'. Returns: tuple: force (ndarray (3,) ) and torque (ndarray (3,) ) \"\"\" from ..forces._mesh_force import calc_force_mesh force , torque = calc_force_mesh ( self , depth , unit ) return force , torque get_Jr ( self ) Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy, Jz] Source code in pymagnet/magnets/_polygon3D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy, Jz] \"\"\" return self . J size ( self ) Returns magnet dimesions Returns: Type Description size (ndarray) numpy array [width, depth, height] Source code in pymagnet/magnets/_polygon3D.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size (ndarray): numpy array [width, depth, height] \"\"\" pass","title":"magnets"},{"location":"code_reference/magnets/#magnets-module","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. Magnet Base class This private module implements the registry and base magnet classes","title":"Magnets module"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Magnet","text":"Magnet base class Returns: Type Description Magnet magnet base class","title":"Magnet"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry","text":"Registry class for tracking instances Instances are tracked in class.instances using weak references. This also includes any instances that are deleted manually or go out of scope. Class methods: `print_instances()` `get_instances()` `get_num_instances()` `reset()","title":"Registry"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.__init_subclass__","text":"This method is called when a class is subclassed. The default implementation does nothing. It may be overridden to extend subclasses. Source code in pymagnet/magnets/_magnet_base.py def __init_subclass__ ( cls ): cls . instances = WeakSet () cls . _class_instances = []","title":"__init_subclass__()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in pymagnet/magnets/_magnet_base.py def __new__ ( cls , * args , ** kwargs ): o = object . __new__ ( cls ) cls . _register_instance ( o ) return o","title":"__new__()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.get_instances","text":"Gets lists of instances Returns: Type Description set all class instances Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_instances ( cls ): \"\"\"Gets lists of instances Returns: set: all class instances \"\"\" return cls . instances","title":"get_instances()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.get_num_instances","text":"Return number of instances of class Parameters: Name Type Description Default Print_Val bool [Print to screen]. Defaults to False. False Returns: Type Description num_instances [int] Source code in pymagnet/magnets/_magnet_base.py @classmethod def get_num_instances ( cls , Print_Val = False ): \"\"\"Return number of instances of class Args: Print_Val (bool, optional): [Print to screen]. Defaults to False. Returns: num_instances [int]: \"\"\" if Print_Val : print ( len ( cls . instances )) return len ( cls . instances )","title":"get_num_instances()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.print_instances","text":"Prints class instantiations Source code in pymagnet/magnets/_magnet_base.py @classmethod def print_instances ( cls ): \"\"\"Prints class instantiations\"\"\" if len ( cls . instances ) < 1 : print ( \"No Instances\" ) else : for instance in cls . instances : print ( instance )","title":"print_instances()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.Registry.reset","text":"Removes all instances from registry. Source code in pymagnet/magnets/_magnet_base.py @classmethod def reset ( cls ): \"\"\"Removes all instances from registry.\"\"\" for magnet in cls . _class_instances : del magnet cls . instances = WeakSet () cls . _class_instances = []","title":"reset()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.list_magnets","text":"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/magnets/_magnet_base.py def list_magnets (): \"\"\"Returns a list of all instantiated magnets. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Magnet . print_instances ()","title":"list_magnets()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet_base.reset_magnets","text":"Returns a list of all instantiated magnets. Source code in pymagnet/magnets/_magnet_base.py def reset_magnets (): \"\"\"Returns a list of all instantiated magnets.\"\"\" from ._magnet2D import Magnet2D , Rectangle , Square , Circle from ._polygon2D import PolyMagnet from ._magnet3D import Magnet3D , Prism , Cube , Cylinder , Sphere from ._polygon3D import Mesh magnet_classes = [ # Registry, Magnet , Magnet2D , Rectangle , Square , Circle , PolyMagnet , Magnet3D , Prism , Cube , Cylinder , Sphere , Mesh , ] for cls in magnet_classes : cls . reset () 1D High symmetry methods This private module implements magnetic field calculations in z along the symmetry centre of a cylindrical or cuboidal magnet.","title":"reset_magnets()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet1D.magnetic_field_cylinder_1D","text":"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, Cylinder required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_cylinder_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, Cylinder z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Cylinder if issubclass ( magnet . __class__ , Cylinder ): L = magnet . length R = magnet . radius Jr = magnet . Jr z_local = _np . asarray ( z ) - magnet . length / 2 - magnet . center [ 2 ] zL = z_local + L R_sq = _np . power ( R , 2 ) z_sq = _np . power ( z_local , 2 ) zL_sq = _np . power ( zL , 2 ) Bz = ( zL / _np . sqrt ( zL_sq + R_sq )) - ( z_local / _np . sqrt ( z_sq + R_sq )) Bz *= Jr / 2 data = Field1 ( Bz ) return data else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None","title":"magnetic_field_cylinder_1D()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet1D.magnetic_field_prism_1D","text":"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Parameters: Name Type Description Default magnet Magnet3D magnet object, one of Prism, or Cube required z ndarray Array of points along the symmetry axis required Returns: Type Description Field1 z-component of the magnetic field and associated unit ('T') Source code in pymagnet/magnets/_magnet1D.py def magnetic_field_prism_1D ( magnet , z ): \"\"\"Calculates the magnetic field z-component due to a cuboid along its axial symmetry center. Args: magnet (Magnet3D): magnet object, one of Prism, or Cube z (ndarray): Array of points along the symmetry axis Returns: Field1: z-component of the magnetic field and associated unit ('T') \"\"\" from ._magnet3D import Prism if issubclass ( magnet . __class__ , Prism ): a = magnet . a b = magnet . b c = magnet . c Jr = magnet . Jr z_local = _np . asarray ( z ) - c - magnet . center [ 2 ] ab = a * b a_sq = _np . power ( a , 2 ) b_sq = _np . power ( b , 2 ) z_sq = _np . power ( z_local , 2 ) zc = z_local + 2 * c zc_sq = _np . power ( zc , 2 ) Bz = _np . arctan2 ( zc * _np . sqrt ( a_sq + b_sq + zc_sq ), ab ) - _np . arctan2 ( z_local * _np . sqrt ( a_sq + b_sq + z_sq ), ab ) Bz *= Jr / PI field = Field1 ( Bz ) return field else : print ( f \"Error, the magnet should be a 3D magnet not { magnet . __class__ } \" ) return None 2D Magnet Classes This private module implements the Rectangle and Square and Circle 2D magnet classes. The parent class Magnet2D implements the location and orientation methods, i.e. magnet center and quaternion methods for rotating the magnet with respect to each principal axis.","title":"magnetic_field_prism_1D()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Circle","text":"Circle 2D Magnet Class","title":"Circle"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Circle.__init__","text":"Init Method Parameters: Name Type Description Default radius float Radius. Defaults to 10.0. 10 Jr float Remnant magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Unused. For rotations use phi instead center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0) phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , radius = 10 , Jr = 1.0 , # local magnetisation ** kwargs , ): \"\"\"Init Method Args: radius (float, optional): Radius. Defaults to 10.0. Jr (float, optional): Remnant magnetisation. Defaults to 1.0. Kwargs: alpha (float): Unused. For rotations use phi instead center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0) phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( Jr , ** kwargs ) self . radius = radius self . phi = kwargs . pop ( \"phi\" , 0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 ])) self . center = _np . asarray ( self . center )","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Circle.get_field","text":"Calculates the magnetic field due to long bipolar cylinder Parameters: Name Type Description Default x ndarray x coordinates required y narray y coordinates required Returns: Type Description tuple Bx, By magnetic field in cartesian coordinates Source code in pymagnet/magnets/_magnet2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field due to long bipolar cylinder Args: x (ndarray): x coordinates y (narray): y coordinates Returns: tuple: Bx, By magnetic field in cartesian coordinates \"\"\" from ..utils._conversions import cart2pol , vector_pol2cart from ..utils._routines2D import rotate_points_2D if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) rho , phi = cart2pol ( xi , yi ) Brho , Bphi = self . _calcB_polar ( rho , phi - self . phi_rad ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) Bx , By = rotate_points_2D ( Bx , By , 2 * PI - self . alpha_radians ) return Bx , By rho , phi = cart2pol ( x - self . center [ 0 ], y - self . center [ 1 ]) Brho , Bphi = self . _calcB_polar ( rho , phi - self . phi_rad ) # Convert magnetic fields from cylindrical to cartesian Bx , By = vector_pol2cart ( Brho , Bphi , phi ) return Bx , By","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Circle.get_Jr","text":"Returns signed remnant magnetisation Returns: Type Description ndarray remnant magnetisation Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns signed remnant magnetisation Returns: ndarray: remnant magnetisation \"\"\" return _np . array ([ self . Jx , self . Jy ])","title":"get_Jr()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Circle.get_size","text":"Returns radius Returns: Type Description ndarray radius Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns radius Returns: ndarray: radius \"\"\" return _np . array ([ self . radius ])","title":"get_size()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D","text":"2D Magnet Base Class","title":"Magnet2D"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D.__init__","text":"Init Method Parameters: Name Type Description Default Jr float signed magnetised of remnant magnetisationnega required Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , Jr , ** kwargs ) -> None : \"\"\"Init Method Args: Jr (float): signed magnetised of remnant magnetisationnega Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). \"\"\" super () . __init__ () self . Jr = Jr # Magnet rotation w.r.t. x-axis self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_radians = _np . deg2rad ( self . alpha ) self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 ])) self . center = _np . asarray ( self . center )","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D.get_center","text":"Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_magnet2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center","title":"get_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D.get_field","text":"Calculates the magnetic field. This is a template that needs to be implemented for each magnet Source code in pymagnet/magnets/_magnet2D.py def get_field ( self ): \"\"\"Calculates the magnetic field. This is a template that needs to be implemented for each magnet \"\"\" pass","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D.get_force_torque","text":"Calculates the force and torque on a magnet due to all other magnets. This is a template that needs to be implemented for each magnet. Source code in pymagnet/magnets/_magnet2D.py def get_force_torque ( self ): \"\"\"Calculates the force and torque on a magnet due to all other magnets. This is a template that needs to be implemented for each magnet. \"\"\" pass","title":"get_force_torque()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Magnet2D.get_orientation","text":"Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_magnet2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha","title":"get_orientation()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Rectangle","text":"Rectangular 2D Magnet Class","title":"Rectangle"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Rectangle.__init__","text":"Init Method Parameters: Name Type Description Default width float Magnet Width. Defaults to 20.0. 20.0 height float Magnet Height. Defaults to 40.0. 40.0 Jr float Remnant Magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , width = 20.0 , height = 40.0 , Jr = 1.0 , ** kwargs ): \"\"\"Init Method Args: width (float, optional): Magnet Width. Defaults to 20.0. height (float, optional): Magnet Height. Defaults to 40.0. Jr (float, optional): Remnant Magnetisation. Defaults to 1.0. Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( Jr , ** kwargs ) self . width = width self . height = height self . a = width / 2 self . b = height / 2 self . phi = kwargs . pop ( \"phi\" , 90 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Rectangle.get_field","text":"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Parameters: Name Type Description Default x ndarray x co-ordinates required y ndarray y co-ordinates required Returns: Type Description tuple magnetic field vector Bx (ndarray), By (ndarray) Source code in pymagnet/magnets/_magnet2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field at point(s) x,y due to a rectangular magnet Args: x (ndarray): x co-ordinates y (ndarray): y co-ordinates Returns: tuple: magnetic field vector Bx (ndarray), By (ndarray) \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : xi , yi = rotate_points_2D ( x - self . center [ 0 ], y - self . center [ 1 ], self . alpha_radians ) # Calculate field due to x-component of magnetisation if _np . fabs ( self . Jx / self . Jr ) > Magnet2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : # Calculate fields in local frame Btx = self . _calcBx_mag_x ( xi , yi ) Bty = self . _calcBy_mag_x ( xi , yi ) # Rotate fields to global frame Bx , By = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) else : Bx = self . _calcBx_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) By = self . _calcBy_mag_x ( x - self . center [ 0 ], y - self . center [ 1 ]) # Calculate field due to y-component of magnetisation if _np . fabs ( self . Jy / self . Jr ) > Magnet2D . tol : if _np . fabs ( self . alpha_radians ) > Magnet2D . tol : Btx = self . _calcBx_mag_y ( xi , yi ) Bty = self . _calcBy_mag_y ( xi , yi ) Bxt , Byt = rotate_points_2D ( Btx , Bty , 2 * PI - self . alpha_radians ) Bx += Bxt By += Byt else : Bx += self . _calcBx_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) By += self . _calcBy_mag_y ( x - self . center [ 0 ], y - self . center [ 1 ]) return Bx , By","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Rectangle.get_Jr","text":"Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy] Source code in pymagnet/magnets/_magnet2D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy] \"\"\" return _np . array ([ self . Jx , self . Jy ])","title":"get_Jr()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Rectangle.get_size","text":"Returns magnet dimesions Returns: Type Description ndarray numpy array [width, height] Source code in pymagnet/magnets/_magnet2D.py def get_size ( self ): \"\"\"Returns magnet dimesions Returns: ndarray: numpy array [width, height] \"\"\" return _np . array ([ self . width , self . height ])","title":"get_size()"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Square","text":"Square 2D Magnet Class","title":"Square"},{"location":"code_reference/magnets/#pymagnet.magnets._magnet2D.Square.__init__","text":"Init Method Parameters: Name Type Description Default width float Sqaure side length. Defaults to 20.0. 20 Jr float Remnant Magnetisation. Defaults to 1.0. 1.0 Kwargs alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. Source code in pymagnet/magnets/_magnet2D.py def __init__ ( self , width = 20 , Jr = 1.0 , ** kwargs ): \"\"\"Init Method Args: width (float, optional): Sqaure side length. Defaults to 20.0. Jr (float, optional): Remnant Magnetisation. Defaults to 1.0. Kwargs: alpha (float): Magnetisation orientation angle (in degrees). Defaults to 0. center (tuple or ndarrray): magnet center (x, y). Defaults to (0,0). phi (float): Rotation Angle (in degrees) of magnet w.r.t x-axis. Defaults to 90. \"\"\" super () . __init__ ( width = width , height = width , Jr = Jr , ** kwargs ) 2D Polygon Magnet class","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Line","text":"Line Class for storing properties of a sheet manget","title":"Line"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Line.__init__","text":"Init Method Parameters: Name Type Description Default length float side length required center ndarray magnet center (x, y) required beta float Orientation w.r.t. z-axis in degrees required K float Sheet current density in tesla required Source code in pymagnet/magnets/_polygon2D.py def __init__ ( self , length , center , beta , K ): \"\"\"Init Method Args: length (float): side length center (ndarray): magnet center (x, y) beta (float): Orientation w.r.t. z-axis in degrees K (float): Sheet current density in tesla \"\"\" self . length = length self . center = center self . beta = beta self . beta_rad = _np . deg2rad ( beta ) self . xc = center [ 0 ] self . yc = center [ 1 ] self . K = K self . tol = MAG_TOL","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Line.get_center","text":"Returns line center Returns: Type Description ndarray center (x,y) Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns line center Returns: ndarray: center (x,y) \"\"\" return self . center","title":"get_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Line.get_field","text":"Calculates the magnetic field due to a sheet magnet First a transformation into the local coordinates is made, the field calculated and then the magnetic field it rotated out to the global coordinates Parameters: Name Type Description Default x ndarray x-coordinates required y ndarray y-coordinates required Returns: Type Description tuple Bx (ndarray), By (ndarray) magnetic field vector Source code in pymagnet/magnets/_polygon2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field due to a sheet magnet First a transformation into the local coordinates is made, the field calculated and then the magnetic field it rotated out to the global coordinates Args: x (ndarray): x-coordinates y (ndarray): y-coordinates Returns: tuple: Bx (ndarray), By (ndarray) magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) if _np . fabs ( self . beta_rad ) > self . tol : xt , yt = rotate_points_2D ( x - self . xc , y - self . yc , 2 * PI - self . beta_rad ) Btx , Bty = _sheet_field ( xt , yt , self . length / 2 , self . K ) Bx , By = rotate_points_2D ( Btx , Bty , self . beta_rad ) else : Bx , By = _sheet_field ( x - self . xc , y - self . yc , self . length / 2 , self . K ) return Bx , By","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.LineUtils","text":"Utility class consisting of rountines for 2D line elements","title":"LineUtils"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.LineUtils.line_center","text":"Gets midpoint of two vertices Parameters: Name Type Description Default vertex_1 ndarray vertex 1 required vertex_2 ndarray vertex 2 required Returns: Type Description ndarray midpoint Source code in pymagnet/magnets/_polygon2D.py @staticmethod def line_center ( vertex_1 , vertex_2 ): \"\"\"Gets midpoint of two vertices Args: vertex_1 (ndarray): vertex 1 vertex_2 (ndarray): vertex 2 Returns: ndarray: midpoint \"\"\" xc = ( vertex_1 [ 0 ] + vertex_2 [ 0 ]) / 2 yc = ( vertex_1 [ 1 ] + vertex_2 [ 1 ]) / 2 return _np . array ([ xc , yc ])","title":"line_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.LineUtils.signed_area","text":"Calculates signed area of a polygon Parameters: Name Type Description Default polygon Polygon Polygon instance required Returns: Type Description float signed area Source code in pymagnet/magnets/_polygon2D.py @staticmethod def signed_area ( polygon ): \"\"\"Calculates signed area of a polygon Args: polygon (Polygon): Polygon instance Returns: float: signed area \"\"\" j = 1 NP = polygon . num_vertices () area = 0 norm = _np . empty ([ NP , 2 ]) center = _np . empty ([ NP , 2 ]) beta = _np . empty ( NP ) # angle w.r.t. y axis length = _np . empty ( NP ) for i in range ( NP ): j = j % NP area += ( polygon . vertices [ j ][ 0 ] - polygon . vertices [ i ][ 0 ]) * ( polygon . vertices [ j ][ 1 ] + polygon . vertices [ i ][ 1 ] ) norm [ i , :], length [ i ] = LineUtils . unit_norm ( polygon . vertices [ i ], polygon . vertices [ j ] ) center [ i , :] = LineUtils . line_center ( polygon . vertices [ i ], polygon . vertices [ j ] ) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points if area < 0 : norm *= - 1 beta [:] = _np . rad2deg ( _np . arctan2 ( norm [:, 1 ], norm [:, 0 ])) return area / 2.0 , norm , beta , length , center","title":"signed_area()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.LineUtils.unit_norm","text":"Get unit normal to vertex Parameters: Name Type Description Default vertex_1 ndarray vertex 1 required vertex_2 ndarray vertex 2 required clockwise bool Clockwise orientation of points. Defaults to True. True Returns: Type Description tuple normal vector (ndarray), length i.e. distance between vertices (float) Source code in pymagnet/magnets/_polygon2D.py @staticmethod def unit_norm ( vertex_1 , vertex_2 , clockwise = True ): \"\"\"Get unit normal to vertex Args: vertex_1 (ndarray): vertex 1 vertex_2 (ndarray): vertex 2 clockwise (bool, optional): Clockwise orientation of points. Defaults to True. Returns: tuple: normal vector (ndarray), length i.e. distance between vertices (float) \"\"\" dx = vertex_1 [ 0 ] - vertex_2 [ 0 ] dy = vertex_1 [ 1 ] - vertex_2 [ 1 ] # Clockwise winding of points: if clockwise : norm = _np . array ([ dy , - dx ]) else : norm = _np . array ([ - dy , dx ]) length = _np . linalg . norm ( norm ) norm = norm / length return norm , length","title":"unit_norm()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon","text":"Polygon class for generating list of vertices","title":"Polygon"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon.append","text":"Appends vertex to list of vertices Parameters: Name Type Description Default vertex list list of vertices required Source code in pymagnet/magnets/_polygon2D.py def append ( self , vertex ): \"\"\"Appends vertex to list of vertices Args: vertex (list): list of vertices \"\"\" if len ( vertex ) != 2 : print ( \"Error\" ) if type ( vertex ) == tuple : self . vertices . append ( vertex ) elif len ( vertex ) == 2 : self . vertices . append ( tuple ( vertex )) self . set_center ()","title":"append()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon.check_radius","text":"Checks which of apothem, side length, or radius has been passed as kwargs to gen_polygon() . Order of precendence is apothem, length, radius. Parameters: Name Type Description Default N int Number of sides required apothem float polygon apothem required length float side length required radius float outcircle radius required Exceptions: Type Description Exception One of apothem, length, or raduis must be defined Returns: Type Description float returns radius Source code in pymagnet/magnets/_polygon2D.py @staticmethod def check_radius ( N , apothem , length , radius ): \"\"\"Checks which of apothem, side length, or radius has been passed as kwargs to `gen_polygon()`. Order of precendence is apothem, length, radius. Args: N (int): Number of sides apothem (float): polygon apothem length (float): side length radius (float): outcircle radius Raises: Exception: One of apothem, length, or raduis must be defined Returns: float: returns radius \"\"\" if apothem is not None : return apothem / _np . around ( _np . cos ( PI / N ), 4 ) elif length is not None : return length / _np . around ( 2 * _np . sin ( PI / N ), 4 ) elif radius is not None : return radius else : raise Exception ( \"Error, one of apothem, length, or radius must be defined.\" )","title":"check_radius()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon.gen_polygon","text":"Generates regular polygon. One of apothem, side length or radius must be defined. Parameters: Name Type Description Default N int Number of sides. Defaults to 6. 6 center tuple Polygon center. Defaults to (0.0, 0.0). (0.0, 0.0) alpha float Orientration with respect to x-axis. Defaults to 0.0. 0.0 Exceptions: Type Description Exception N must be > 2 Returns: Type Description ndarray polygon vertices Source code in pymagnet/magnets/_polygon2D.py @staticmethod def gen_polygon ( N = 6 , center = ( 0.0 , 0.0 ), alpha = 0.0 , ** kwargs ): \"\"\"Generates regular polygon. One of apothem, side length or radius must be defined. Args: N (int, optional): Number of sides. Defaults to 6. center (tuple, optional): Polygon center. Defaults to (0.0, 0.0). alpha (float, optional): Orientration with respect to x-axis. Defaults to 0.0. Raises: Exception: N must be > 2 Returns: ndarray: polygon vertices \"\"\" N = int ( N ) if N < 3 : raise Exception ( \"Error, N must be > 2.\" ) apothem = kwargs . pop ( \"apothem\" , None ) length = kwargs . pop ( \"length\" , None ) radius = kwargs . pop ( \"radius\" , None ) radius = Polygon . check_radius ( N , apothem , length , radius ) k = _np . arange ( 0 , N , 1 ) xc = center [ 0 ] yc = center [ 1 ] def f ( N ): if N % 2 == 0 : return PI / N + _np . deg2rad ( alpha ) else : return PI / N + PI + _np . deg2rad ( alpha ) xv = xc + radius * _np . sin ( 2 * PI * k / N + f ( N )) yv = yc + radius * _np . cos ( 2 * PI * k / N + f ( N )) poly_verts = _np . vstack (( xv , yv )) . T . tolist () return poly_verts","title":"gen_polygon()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon.num_vertices","text":"Gets number of vertices Returns: Type Description int number of vertices Source code in pymagnet/magnets/_polygon2D.py def num_vertices ( self ): \"\"\"Gets number of vertices Returns: int: number of vertices \"\"\" return len ( self . vertices )","title":"num_vertices()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.Polygon.set_center","text":"Sets center of polygon to be centroid Source code in pymagnet/magnets/_polygon2D.py def set_center ( self ): \"\"\"Sets center of polygon to be centroid\"\"\" self . center = _np . mean ( _np . asarray ( self . vertices ), axis = 0 )","title":"set_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.PolyMagnet","text":"2D Magnet Polygon class.","title":"PolyMagnet"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.PolyMagnet.__init__","text":"Init method Note When creating a regular polygon, one of apothem, radius, or length must be defined as a kwarg or an exception will be raised. When creating a regular polygon, the number of sides num_sides must be at least 3 or an exception will be raised. When creating a custom polygon at least one vertex pair must be defined with vertices or an exception will be raised. Parameters: Name Type Description Default Jr float signed magnitude of remnant magnetisation required Kwargs alpha (float): Not used theta (float): Orientation of magnet w.r.t x-axis of magnet phi (float): Orientation of magnetisation w.r.t x-axis of magnet in degrees. Defaults to 90.0. center (ndarray): magnet center (x, y). Defaults to (0.0, 0.0) length (float): side length if creating a regular polygon apothem (float): apothem (incircle radius) if creating a regular polygon radius (float): radius (circumcircle radius) if creating a regular polygon num_sides (int): number of sides of a regular polygon. Defaults to 6. custom_polygon (bool): Flag to define a custom polygon. Defaults to False. vertices (ndarray, list): List of custom vertices. Defaults to None. Exceptions: Type Description Exception If creating a custom polygon, vertices must not be None. Source code in pymagnet/magnets/_polygon2D.py def __init__ ( self , Jr , ** kwargs ) -> None : \"\"\"Init method NOTE: * When creating a regular polygon, one of apothem, radius, or length must be defined as a kwarg or an exception will be raised. * When creating a regular polygon, the number of sides `num_sides` must be at least 3 or an exception will be raised. * When creating a custom polygon at least one vertex pair must be defined with `vertices` or an exception will be raised. Args: Jr (float): signed magnitude of remnant magnetisation Kwargs: alpha (float): Not used theta (float): Orientation of magnet w.r.t x-axis of magnet phi (float): Orientation of magnetisation w.r.t x-axis of magnet in degrees. Defaults to 90.0. center (ndarray): magnet center (x, y). Defaults to (0.0, 0.0) length (float): side length if creating a regular polygon apothem (float): apothem (incircle radius) if creating a regular polygon radius (float): radius (circumcircle radius) if creating a regular polygon num_sides (int): number of sides of a regular polygon. Defaults to 6. custom_polygon (bool): Flag to define a custom polygon. Defaults to False. vertices (ndarray, list): List of custom vertices. Defaults to None. Raises: Exception: If creating a custom polygon, `vertices` must not be None. \"\"\" from ..utils._routines2D import rotate_points_2D super () . __init__ ( Jr , ** kwargs ) # Magnet rotation w.r.t. x-axis self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_radians = _np . deg2rad ( self . alpha ) self . theta = kwargs . pop ( \"theta\" , 0.0 ) self . theta_radians = _np . deg2rad ( self . theta ) self . phi = kwargs . pop ( \"phi\" , 90.0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ), decimals = 6 ) self . tol = MAG_TOL self . area = None self . custom_polygon = kwargs . pop ( \"custom_polygon\" , False ) self . center = kwargs . pop ( \"center\" , _np . array ([ 0.0 , 0.0 , 0.0 ])) self . center = _np . asarray ( self . center ) if self . custom_polygon : vertices = kwargs . pop ( \"vertices\" , None ) if vertices is None : raise Exception ( \"Error, no vertices were defined.\" ) vertices = _np . atleast_2d ( vertices ) x_rot , y_rot = rotate_points_2D ( vertices [:, 0 ], vertices [:, 1 ], self . theta_radians , # + self.alpha_radians, ) vertices = _np . stack ([ x_rot , y_rot ]) . T + self . center self . polygon = Polygon ( vertices = vertices . tolist ()) else : self . length = kwargs . pop ( \"length\" , None ) self . apothem = kwargs . pop ( \"apothem\" , None ) self . radius = kwargs . pop ( \"radius\" , None ) self . num_sides = kwargs . pop ( \"num_sides\" , 6 ) self . radius = Polygon . check_radius ( self . num_sides , self . apothem , self . length , self . radius , ) # Generate Polygon self . polygon = Polygon ( vertices = Polygon . gen_polygon ( self . num_sides , self . center , self . theta , # + self.alpha, length = self . length , apothem = self . apothem , radius = self . radius , ), center = self . center , )","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.PolyMagnet.get_center","text":"Returns magnet centre Returns: Type Description center (ndarray) numpy array [xc, yc] Source code in pymagnet/magnets/_polygon2D.py def get_center ( self ): \"\"\"Returns magnet centre Returns: center (ndarray): numpy array [xc, yc] \"\"\" return self . center","title":"get_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.PolyMagnet.get_field","text":"Calculates the magnetic field of a polygon due to each face Parameters: Name Type Description Default x ndarray x-coordinates required y ndarray y-coordinates required Returns: Type Description tuple Bx (ndarray), By (ndarray) magnetic field vector Source code in pymagnet/magnets/_polygon2D.py def get_field ( self , x , y ): \"\"\"Calculates the magnetic field of a polygon due to each face Args: x (ndarray): x-coordinates y (ndarray): y-coordinates Returns: tuple: Bx (ndarray), By (ndarray) magnetic field vector \"\"\" from ..utils._routines2D import rotate_points_2D , _get_field_array_shape2 array_shape = _get_field_array_shape2 ( x , y ) Bx , By = _np . zeros ( array_shape ), _np . zeros ( array_shape ) beta , length , center , K = self . _gen_sheet_magnets () if _np . fabs ( self . alpha_radians ) > self . tol : pass print ( \"Arbitrary rotation with alpha not yet implemented!!\" ) # FIXME: rotate centres # xt, yt = rotate_points_2D(x - self.xc, y - self.yc, self.alpha_radians) # beta += self.alpha # xc_rot, yc_rot = rotate_points_2D( # center[:, 0] - self.xc, # center[:, 1] - self.yc, # self.alpha_radians, # ) # center[:, 0] = xc_rot # center[:, 1] = yc_rot # # # for i in range(len(K)): # sheet = Line(length[i], center[i], beta[i], K[i]) # Btx, Bty = sheet.get_field(xt, yt) # Btx, Bty = rotate_points_2D(Btx, Bty, 2 * PI - self.alpha_radians) # Bx += Btx # By += Bty for i in range ( len ( K )): sheet = Line ( length [ i ], center [ i ], beta [ i ], K [ i ]) Btx , Bty = sheet . get_field ( x , y ) Bx += Btx By += Bty return Bx , By","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon2D.PolyMagnet.get_orientation","text":"Returns magnet orientation, alpha in degrees Returns: Type Description float alpha, rotation angle w.r.t x-axis. Source code in pymagnet/magnets/_polygon2D.py def get_orientation ( self ): \"\"\"Returns magnet orientation, `alpha` in degrees Returns: float: alpha, rotation angle w.r.t x-axis. \"\"\" return self . alpha","title":"get_orientation()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh","text":"Mesh Magnet Class.","title":"Mesh"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.__init__","text":"Init Method Parameters: Name Type Description Default filename string path to stl file to be imported required Jr float Signed remnant magnetisation. Defaults to 1.0. 1.0 Kwargs phi (float): theta (float): mesh_scale (float): scaling factor if mesh needs to be resized. Defaults to 1.0 Source code in pymagnet/magnets/_polygon3D.py def __init__ ( self , filename , Jr = 1.0 , # local magnetisation ** kwargs , ): \"\"\"Init Method Args: filename (string): path to stl file to be imported Jr (float, optional): Signed remnant magnetisation. Defaults to 1.0. Kwargs: phi (float): theta (float): mesh_scale (float): scaling factor if mesh needs to be resized. Defaults to 1.0 \"\"\" super () . __init__ ( Jr , ** kwargs ) self . phi = kwargs . pop ( \"theta\" , 90.0 ) self . phi_rad = _np . deg2rad ( self . phi ) self . theta = kwargs . pop ( \"phi\" , 0.0 ) self . theta_rad = _np . deg2rad ( self . theta ) self . mesh_scale = kwargs . pop ( \"mesh_scale\" , 1.0 ) self . _filename = filename ( self . mesh_vectors , self . mesh_normals , self . volume , self . centroid , ) = self . _import_mesh () self . Jx = _np . around ( Jr * _np . cos ( self . phi_rad ) * _np . sin ( self . theta_rad ), decimals = 6 ) self . Jy = _np . around ( Jr * _np . sin ( self . phi_rad ) * _np . sin ( self . theta_rad ), decimals = 6 ) self . Jz = _np . around ( Jr * _np . cos ( self . theta_rad ), decimals = 6 ) self . tol = MAG_TOL # sufficient for 0.01 degree accuracy self . J = _np . array ([ self . Jx , self . Jy , self . Jz ]) # FIXME: Sort out rotation of magnetisation with rotation of mesh # if _np.any( # _np.fabs([self.alpha_rad, self.beta_rad, self.gamma_rad]) > ALIGN_CUTOFF # ): # mag_rotation = Quaternion.gen_rotation_quaternion( # self.alpha_rad, self.beta_rad, self.gamma_rad # ) # Jrot = mag_rotation * self.J # self.Jx = Jrot[0] # self.Jy = Jrot[1] # self.Jz = Jrot[2] # self.J = _np.array([self.Jx, self.Jy, self.Jz]) self . Jnorm = _np . dot ( self . J , self . mesh_normals . T )","title":"__init__()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.calcB_triangle","text":"Calculates the magnetic field due to a triangle Parameters: Name Type Description Default triangle ndarray Vertices of a triangle required Jr float Remnant magnetisation component normal to triangle required x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple Bx, By, Bz magnetic field components Source code in pymagnet/magnets/_polygon3D.py def calcB_triangle ( self , triangle , Jr , x , y , z , i ): \"\"\"Calculates the magnetic field due to a triangle Args: triangle (ndarray): Vertices of a triangle Jr (float): Remnant magnetisation component normal to triangle x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: Bx, By, Bz magnetic field components \"\"\" ( total_rotation , rotated_triangle , offset , RA_triangle1 , RA_triangle2 , ) = _rotate_triangle ( triangle , Jr ) # Prepare points and quaternion pos_vec = Quaternion . _prepare_vector ( x , y , z ) # Rotate points x_rot , y_rot , z_rot = total_rotation * pos_vec norm1 = norm_plane ( triangle ) if _np . allclose ( norm1 , [ 0 , - 1 , 0 ], atol = ALIGN_CUTOFF ) and Jr < 0 : RA_triangle1 , RA_triangle2 = RA_triangle2 , RA_triangle1 Btx , Bty , Btz = self . _calcB_2_triangles ( RA_triangle1 , RA_triangle2 , Jr , x_rot - offset [ 0 ], y_rot - offset [ 1 ], z_rot - offset [ 2 ], ) Bvec = Quaternion . _prepare_vector ( Btx , Bty , Btz ) Bx , By , Bz = total_rotation . get_conjugate () * Bvec return Bx , By , Bz , rotated_triangle , offset , total_rotation","title":"calcB_triangle()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.get_center","text":"Returns magnet center Returns: Type Description ndarray magnet center Source code in pymagnet/magnets/_polygon3D.py def get_center ( self ): \"\"\"Returns magnet center Returns: ndarray: magnet center \"\"\" return self . center","title":"get_center()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.get_field","text":"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Parameters: Name Type Description Default x float/array x co-ordinates required y float/array y co-ordinates required z float/array z co-ordinates required Returns: Type Description tuple Bx(ndarray), By(ndarray), Bz(ndarray) field vector Source code in pymagnet/magnets/_polygon3D.py def get_field ( self , x , y , z ): \"\"\"Calculates the magnetic field at point(s) x,y,z due to a 3D magnet The calculations are always performed in local coordinates with the centre of the magnet at origin and z magnetisation pointing along the local z' axis. The rotations and translations are performed first, and the internal field calculation functions are called. Args: x (float/array): x co-ordinates y (float/array): y co-ordinates z (float/array): z co-ordinates Returns: tuple: Bx(ndarray), By(ndarray), Bz(ndarray) field vector \"\"\" B = self . _get_field_internal ( x , y , z ) return B . x , B . y , B . z","title":"get_field()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.get_force_torque","text":"Calculates the force and torque on a prism magnet due to all other magnets. Parameters: Name Type Description Default depth int Number of recursions of division by 4 per simplex 4 unit str Length scale. Defaults to 'mm'. 'mm' Returns: Type Description tuple force (ndarray (3,) ) and torque (ndarray (3,) ) Source code in pymagnet/magnets/_polygon3D.py def get_force_torque ( self , depth = 4 , unit = \"mm\" ): \"\"\"Calculates the force and torque on a prism magnet due to all other magnets. Args: depth (int, optional): Number of recursions of division by 4 per simplex unit (str, optional): Length scale. Defaults to 'mm'. Returns: tuple: force (ndarray (3,) ) and torque (ndarray (3,) ) \"\"\" from ..forces._mesh_force import calc_force_mesh force , torque = calc_force_mesh ( self , depth , unit ) return force , torque","title":"get_force_torque()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.get_Jr","text":"Returns Magnetisation vector Returns: Type Description ndarray [Jx, Jy, Jz] Source code in pymagnet/magnets/_polygon3D.py def get_Jr ( self ): \"\"\"Returns Magnetisation vector Returns: ndarray: [Jx, Jy, Jz] \"\"\" return self . J","title":"get_Jr()"},{"location":"code_reference/magnets/#pymagnet.magnets._polygon3D.Mesh.size","text":"Returns magnet dimesions Returns: Type Description size (ndarray) numpy array [width, depth, height] Source code in pymagnet/magnets/_polygon3D.py def size ( self ): \"\"\"Returns magnet dimesions Returns: size (ndarray): numpy array [width, depth, height] \"\"\" pass","title":"size()"},{"location":"code_reference/plots/","text":"Plots module pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of cubes, cuboids, and cylinders plot_1D_field ( magnet , unit = 'mm' , ** kwargs ) Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet Magnet3D Must be a Magnet3D type of magnet, either Prism, Cube,or Cylinder. required Kwargs num_points (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). Source code in pymagnet/plots/_plot1D.py def plot_1D_field ( magnet , unit = \"mm\" , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (Magnet3D): Must be a Magnet3D type of magnet, either Prism, Cube,or Cylinder. Kwargs: num_points (int): Number of points to calculate. Defaults to 101. Returns: tuple: Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). \"\"\" num_points = kwargs . pop ( \"num_points\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) points = Point_Array1 ( _np . zeros ( num_points ), unit = unit ) if issubclass ( magnet . __class__ , Cylinder ): mag_boundary = magnet . length / 2 points . z = _np . linspace ( - 2 * magnet . length + magnet . center [ 2 ], 2 * magnet . length + magnet . center [ 2 ], num_points , ) field = magnetic_field_cylinder_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , Prism ): mag_boundary = magnet . height / 2 points . z = _np . linspace ( - 2 * magnet . height + magnet . center [ 2 ], 2 * magnet . height + magnet . center [ 2 ], num_points , ) field = magnetic_field_prism_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN else : print ( \"Error\" ) return None fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) unit_length = \"(\" + points . unit + \")\" field_unit = \"(\" + field . unit + \")\" _plt . xlabel ( r \"$z$ \" + unit_length ) _plt . ylabel ( r \"$B_z$ \" + field_unit ) _plt . plot ( points . z , field . z ) _plt . axvline ( x =- mag_boundary + magnet . center [ 2 ], c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary + magnet . center [ 2 ], c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return points , field Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and arrow Encodes magnetisation vector for drawing on plots __init__ ( self , x , y , dx , dy , transform , width = 3 ) special Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width magnet_patch Magnet drawing class patch Encodes magnet dimensions for drawing on plots __init__ ( self , x , y , width , height , transform , type ) special Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type contour_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet Cylinder instance of magnetic cylinder required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet (Cylinder): instance of magnetic cylinder Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (m)\" ylab = \"z (m)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" fig , ax = plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , ) return fig , ax line_plot_cylinder ( magnet , ** kwargs ) Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet Cylinder instance of magnetic cylinder required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet (Cylinder): instance of magnetic cylinder Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) _plt . plot ( rho * 1 , Bz , label = r \"$B_z$\" ) _plt . plot ( rho * 1 , Br , label = r \"$B_r$\" ) _plt . legend ( loc = \"best\" ) _plt . show () return fig , ax plot_2D_contour ( point_array , field , ** kwargs ) Contour plot of field Parameters: Name Type Description Default point_array Point_Array2 coordinates required field Field2 Magnetic Field required Kwargs save_fig (bool): Save to png file. Defaults to False xlab (str): x axis label ylab (str): y axis label clab (str): label for colorbar axis_scale (str): axis aspect ratio Defaults to 'equal'. show_magnets (bool): Draw magnets. Defaults to True field_component (str): Defaults to 'n'. plot_type (str): Draw contour or streamplot . Defaults to 'contour' cmap (str): Colormap. Defaults to viridis vector_plot (bool): Draw vectors as arrows. Defaults to False. vector_color (str): Arrow color. Defaults to 'w' cmin (float): Color scale minimum. Defaults to 0.0 cmax (float): Color scale minimum. Defaults to twice the mean field num_levels (int): Number of contour levels. Defaults to 11. Exceptions: Type Description Exception plot_type must be 'contour' or 'streamplot' Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_2D_contour ( point_array , field , ** kwargs ): \"\"\"Contour plot of field Args: point_array (Point_Array2): coordinates field (Field2): Magnetic Field Kwargs: save_fig (bool): Save to png file. Defaults to False xlab (str): x axis label ylab (str): y axis label clab (str): label for colorbar axis_scale (str): axis aspect ratio Defaults to 'equal'. show_magnets (bool): Draw magnets. Defaults to True field_component (str): Defaults to 'n'. plot_type (str): Draw `contour` or `streamplot`. Defaults to 'contour' cmap (str): Colormap. Defaults to `viridis` vector_plot (bool): Draw vectors as arrows. Defaults to False. vector_color (str): Arrow color. Defaults to 'w' cmin (float): Color scale minimum. Defaults to 0.0 cmax (float): Color scale minimum. Defaults to twice the mean field num_levels (int): Number of contour levels. Defaults to 11. Raises: Exception: plot_type must be 'contour' or 'streamplot' Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" import matplotlib.cm as _cm from ..magnets._polygon2D import PolyMagnet show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"y ( { point_array . unit } )\" ) clab = kwargs . pop ( \"clab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"viridis\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = field . x elif field_component == \"y\" : field_chosen = field . y else : field_chosen = field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( point_array . x , point_array . y , field_chosen , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( point_array . x , point_array . y , field_chosen , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( point_array , field , NQ , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = point_array . x [:, 0 ] ypl = point_array . y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : field . x . T , \"vertical\" : field . y . T , } CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ), ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () fig . tight_layout () ax . axis ( \"scaled\" ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) return fig , ax plot_2D_line ( point_array , field , ** kwargs ) Line Plot of field from 2D magnet Parameters: Name Type Description Default point_array Point_Array2 coordinates required field Field2 Magnetic Field required Kwargs xlab (str): xlabel ylab (str): ylabel axis_scale (str): unused save_fig (bool): Save to png file. Defaults to False Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_2D_line ( point_array , field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: point_array (Point_Array2): coordinates field (Field2): Magnetic Field Kwargs: xlab (str): xlabel ylab (str): ylabel axis_scale (str): unused save_fig (bool): Save to png file. Defaults to False Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) _plt . plot ( point_array . x , field . n , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( point_array . x , field . x , label = r \"$B_x$\" ) _plt . plot ( point_array . x , field . y , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 ) # _plt.savefig('contour_plot.pdf', dpi=300) return fig , ax plot_3D_contour ( points , field , plane , ** kwargs ) Contour plot of field Parameters: Name Type Description Default points Point_Array2 coordinates required field Field2 Magnetic field required plane str Plane to draw contour on. Can be 'xy', 'xz', or 'yz' required Exceptions: Type Description Exception plot_type must be 'contour' or 'streamplot Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_3D_contour ( points , field , plane , ** kwargs ): \"\"\"Contour plot of field Args: points (Point_Array2): coordinates field (Field2): Magnetic field plane (str): Plane to draw contour on. Can be 'xy', 'xz', or 'yz' Raises: Exception: plot_type must be 'contour' or 'streamplot Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , \"x (\" + points . unit + \")\" ) ylab = kwargs . pop ( \"ylab\" , \"y (\" + points . unit + \")\" ) zlab = kwargs . pop ( \"zlab\" , \"z (\" + points . unit + \")\" ) clab = kwargs . pop ( \"clab\" , \"B (\" + field . unit + \")\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = field . n [ _np . isfinite ( field . n )] cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if plane . lower () == \"xy\" : plot_x = points . x plot_y = points . y plot_xlab = xlab plot_ylab = ylab stream_x = field . x stream_y = field . z elif plane . lower () == \"xz\" : stream_x = field . x stream_y = field . z plot_x = points . x plot_y = points . z plot_xlab = xlab plot_ylab = zlab else : stream_x = field . y stream_y = field . z plot_x = points . y plot_y = points . z plot_xlab = ylab plot_ylab = zlab fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"viridis\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , field . n , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , field . n , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Field2 ( stream_x , stream_y , unit = field . unit ) B_2D . n = field . n points_2D = Point_Array2 ( plot_x , plot_y , unit = points . unit ) _vector_plot2 ( points_2D , B_2D , NQ , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) return fig , ax plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ) Contour plot of a single magnetic field component of a 3D simulation Parameters: Name Type Description Default plot_x ndarray coordinates for x-axis of plot required plot_y ndarray coordinates for y-axis of plot required plot_B ndarray Magnetic field component to plot required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of a single magnetic field component of a 3D simulation Args: plot_x (ndarray): coordinates for x-axis of plot plot_y (ndarray): coordinates for y-axis of plot plot_B (ndarray): Magnetic field component to plot Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (m)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (m)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () return fig , ax 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2D module, here plotly is used as the backend. Todo Update str and repr for polyhedra Graphic_Cuboid Generates Cuboid for plotly rendering __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ) special Init method Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). (0, 0, 0) size tuple Size of cuboid. Defaults to (1, 1, 1). (1, 1, 1) Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): Cuboid center. Defaults to (0, 0, 0). size (tuple, optional): Size of cuboid. Defaults to (1, 1, 1). Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords Graphic_Cylinder Generates vertices for a Cylinder for plotly rendering __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) radius float [description]. Defaults to 1. 1 length float [description]. Defaults to 1. 1 Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). radius (float, optional): [description]. Defaults to 1. length (float, optional): [description]. Defaults to 1. Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords Graphic_Mesh Generates Mesh from STL file for plotly rendering __init__ ( self , mesh_vectors , ** kwargs ) special Init Method Parameters: Name Type Description Default mesh_vectors ndarray array of mesh vectors required Kwargs color (str): magnet color. Defaults to 'w'. Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , mesh_vectors , ** kwargs ): \"\"\"Init Method Args: mesh_vectors (ndarray): array of mesh vectors Kwargs: color (str): magnet color. Defaults to 'w'. \"\"\" self . color = kwargs . pop ( \"color\" , \"white\" ) self . mesh_vectors = mesh_vectors generate_vertices ( self ) Generates vertices from STL file Returns: Type Description dict Dictionary of rendering properties for plotly Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices from STL file Returns: dict: Dictionary of rendering properties for plotly \"\"\" # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = self . color ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace Graphic_Sphere Generates vertices for a sphere for plotly rendering __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ) special Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) radius float [description]. Defaults to 1. 1 Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). radius (float, optional): [description]. Defaults to 1. Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices () generate_vertices ( self ) Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords Polyhedron Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere Mesh __init__ ( self , center , size , ** kwargs ) special Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"white\" ) generate_vertices ( self ) Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass list_polyhedra () Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plotly3D.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances () plot_magnet ( unit = 'mm' , ** kwargs ) Renders magnets Parameters: Name Type Description Default unit str unit scale. Defaults to 'mm'. 'mm' Returns: Type Description fig reference to figure Source code in pymagnet/plots/_plotly3D.py def plot_magnet ( unit = \"mm\" , ** kwargs ): \"\"\"Renders magnets Args: unit (str, optional): unit scale. Defaults to 'mm'. Returns: fig: reference to figure \"\"\" reset_polyhedra () magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) data_objects = [] data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + unit + \")\" , yaxis_title = \"y (\" + unit + \")\" , zaxis_title = \"z (\" + unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig reset_polyhedra () Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plotly3D.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset () slice_plot ( data_dict , ** kwargs ) Plots magnetic field slices. A convenience function. Returns: Type Description tuple fig (reference to figure), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def slice_plot ( data_dict , ** kwargs ): \"\"\"Plots magnetic field slices. A convenience function. Returns: tuple: fig (reference to figure), data_objects (plotly dict) \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) # planes = kwargs.pop(\"planes\", [\"xy\", \"xz\", \"yz\"]) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) data_objects = [] show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in data_dict . keys (): points = data_dict [ plane ][ \"points\" ] field = data_dict [ plane ][ \"field\" ] data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) num_points = field . x . shape [ 0 ] NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , data_objects slice_quickplot ( ** kwargs ) Calculates and plots magnetic field slices. A convenience function. Returns: Type Description tuple fig (reference to figure), cache (cached data for each plane with potential keys: 'xy', 'xz', 'yz'), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def slice_quickplot ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices. A convenience function. Returns: tuple: fig (reference to figure), cache (cached data for each plane with potential keys: 'xy', 'xz', 'yz'), data_objects (plotly dict) \"\"\" reset_polyhedra () max1 = kwargs . pop ( \"max1\" , 30 ) max2 = kwargs . pop ( \"max2\" , 30 ) min1 = kwargs . pop ( \"min1\" , - 1 * max1 ) min2 = kwargs . pop ( \"min2\" , - 1 * max2 ) slice_value = kwargs . pop ( \"slice_value\" , 0.0 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in planes : points = slice3D ( plane = plane , max1 = max1 , min1 = min1 , max2 = max2 , min2 = min2 , slice_value = slice_value , unit = unit , num_points = num_points , ) field = get_field_3D ( points ) cache [ plane ] = { \"points\" : points , \"field\" : field } data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , cache , data_objects volume_plot ( points , field , ** kwargs ) Plots magnetic field volume. Parameters: Name Type Description Default points Point_Array3 coordinates required field Field3 Magnetic field vector required Returns: Type Description tuple fig (reference to figure), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def volume_plot ( points , field , ** kwargs ): \"\"\"Plots magnetic field volume. Args: points (Point_Array3): coordinates field (Field3): Magnetic field vector Returns: tuple: fig (reference to figure), data_objects (plotly dict) \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) opacityscale = kwargs . pop ( \"opacityscale\" , None ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , None ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) # kernel_size = 1 # kernel = np.ones([kernel_size, kernel_size, kernel_size]) / kernel_size # B.n = ndimage.convolve(B.n, kernel) data_objects . append ( _generate_volume_data ( points , field , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , opacityscale = opacityscale , ) ) if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , data_objects volume_quickplot ( ** kwargs ) Calculates and plots magnetic field slices. A convenience function. Kwargs num_points (int): = kwargs.pop(\"num_points\", 30) unit (str): = kwargs.pop(\"unit\", \"mm\") xmax (float): Maximum x value. Defaults to 30.0. ymax (float): Maximum y value. Defaults to 30.0. zmax (float): Maximum z value. Defaults to 30.0. xmin (float): Minimum x value. Defaults to -xmax ymin (float): Minimum y value. Defaults to -ymax zmin (float): Minimum z value. Defaults to -zmax Returns: Type Description tuple fig (reference to figure), cache (cached data dict), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def volume_quickplot ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices. A convenience function. Kwargs: num_points (int): = kwargs.pop(\"num_points\", 30) unit (str): = kwargs.pop(\"unit\", \"mm\") xmax (float): Maximum x value. Defaults to 30.0. ymax (float): Maximum y value. Defaults to 30.0. zmax (float): Maximum z value. Defaults to 30.0. xmin (float): Minimum x value. Defaults to -xmax ymin (float): Minimum y value. Defaults to -ymax zmin (float): Minimum z value. Defaults to -zmax Returns: tuple: fig (reference to figure), cache (cached data dict), data_objects (plotly dict) \"\"\" num_points = kwargs . pop ( \"num_points\" , 30 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) xmax = kwargs . pop ( \"xmax\" , 30 ) ymax = kwargs . pop ( \"ymax\" , 30 ) zmax = kwargs . pop ( \"zmax\" , 30 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) points = grid3D ( xmax , ymax , zmax , num_points = num_points , xmin = xmin , ymin = ymin , zmin = zmin , unit = unit , ) field = get_field_3D ( points ) fig , data_objects = volume_plot ( points , field , num_points = num_points , ** kwargs ) cache = { \"points\" : points , \"field\" : field } return fig , cache , data_objects","title":"plots"},{"location":"code_reference/plots/#plots-module","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. Plotting routines for calculating along symmetry lines of cubes, cuboids, and cylinders","title":"Plots module"},{"location":"code_reference/plots/#pymagnet.plots._plot1D.plot_1D_field","text":"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Parameters: Name Type Description Default magnet Magnet3D Must be a Magnet3D type of magnet, either Prism, Cube,or Cylinder. required Kwargs num_points (int): Number of points to calculate. Defaults to 101. Returns: Type Description tuple Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). Source code in pymagnet/plots/_plot1D.py def plot_1D_field ( magnet , unit = \"mm\" , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central symmetry axis of a cylinder or cuboid magnet, assuming the magnetic field is collinear Args: magnet (Magnet3D): Must be a Magnet3D type of magnet, either Prism, Cube,or Cylinder. Kwargs: num_points (int): Number of points to calculate. Defaults to 101. Returns: tuple: Point_Array1, Field1: point array struct containing z and the unit (e/g. 'mm'), vector array containing Bz and the field unit (e.g. 'T'). \"\"\" num_points = kwargs . pop ( \"num_points\" , 101 ) return_data = kwargs . pop ( \"return_data\" , False ) points = Point_Array1 ( _np . zeros ( num_points ), unit = unit ) if issubclass ( magnet . __class__ , Cylinder ): mag_boundary = magnet . length / 2 points . z = _np . linspace ( - 2 * magnet . length + magnet . center [ 2 ], 2 * magnet . length + magnet . center [ 2 ], num_points , ) field = magnetic_field_cylinder_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN elif issubclass ( magnet . __class__ , Prism ): mag_boundary = magnet . height / 2 points . z = _np . linspace ( - 2 * magnet . height + magnet . center [ 2 ], 2 * magnet . height + magnet . center [ 2 ], num_points , ) field = magnetic_field_prism_1D ( magnet , points . z ) # if true, apply NaNs to inside the magnet if magnet . _mask_magnet : mask = _generate_mask_1D ( mag_boundary , magnet . center [ 2 ], points . z ) field . z [ mask ] = _np . NaN else : print ( \"Error\" ) return None fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) unit_length = \"(\" + points . unit + \")\" field_unit = \"(\" + field . unit + \")\" _plt . xlabel ( r \"$z$ \" + unit_length ) _plt . ylabel ( r \"$B_z$ \" + field_unit ) _plt . plot ( points . z , field . z ) _plt . axvline ( x =- mag_boundary + magnet . center [ 2 ], c = \"blue\" , ls = \"--\" ) _plt . axvline ( x = mag_boundary + magnet . center [ 2 ], c = \"red\" , ls = \"--\" ) _plt . axvline ( x = 0.0 , c = \"k\" , ls = \"-\" ) _plt . show () if return_data : return points , field Plotting routines This module contains all functions needed to plot lines and contours for 2D magnetic sources, and","title":"plot_1D_field()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.arrow","text":"Encodes magnetisation vector for drawing on plots","title":"arrow"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.arrow.__init__","text":"Init Arrow Parameters: Name Type Description Default x float arrow tail, x required y float arrow tail, y required dx float arrow head displacement, x required dy float arrow head displacement, y required transform matplotlib Affine2D transformation object, translate required width int Arrow width. Defaults to 3. 3 Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , dx , dy , transform , width = 3 ): \"\"\"Init Arrow Args: x (float): arrow tail, x y (float): arrow tail, y dx (float): arrow head displacement, x dy (float): arrow head displacement, y transform (matplotlib Affine2D): transformation object, `translate` width (int, optional): Arrow width. Defaults to 3. \"\"\" super () . __init__ () self . x = x self . y = y self . dx = dx self . dy = dy self . transform = transform self . width = width","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.magnet_patch","text":"Magnet drawing class","title":"magnet_patch"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.patch","text":"Encodes magnet dimensions for drawing on plots","title":"patch"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.patch.__init__","text":"Initialse a patch Parameters: Name Type Description Default x float centre, x required y float center, y required width float width required height float width required transform matplotlib Affine2D transform object, rotate_deg_around required Source code in pymagnet/plots/_plot2D.py def __init__ ( self , x , y , width , height , transform , type ): \"\"\"Initialse a patch Args: x (float): centre, x y (float): center, y width (float): width height (float): width transform (matplotlib Affine2D): transform object, `rotate_deg_around` \"\"\" super () . __init__ () self . x = x self . y = y self . width = width self . height = height self . transform = transform self . type = type","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.contour_plot_cylinder","text":"Calculates and plots the magnetic field of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet Cylinder instance of magnetic cylinder required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def contour_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field of a cylinder This is an example helper function. Args: magnet (Cylinder): instance of magnetic cylinder Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" NP = 101 NPJ = NP * 1 j rho , z = _np . mgrid [ - 3 * magnet . radius : 3 * magnet . radius : NPJ , - magnet . length : magnet . length : NPJ , ] Br , Bz = magnet . _calcB_cyl ( rho , z ) Bn = _np . sqrt ( Bz ** 2 + Br ** 2 ) xlab = f \"r (m)\" ylab = \"z (m)\" # plot_B = Bn clab = r \"$|B|$ (T)\" cmap = \"viridis\" fig , ax = plot_sub_contour_3D ( rho * 1 , z * 1 , Bn , xlab = xlab , ylab = ylab , clab = clab , cmap = cmap , cmin = 0 , cmax = 1.0 , ) return fig , ax","title":"contour_plot_cylinder()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.line_plot_cylinder","text":"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Parameters: Name Type Description Default magnet Cylinder instance of magnetic cylinder required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def line_plot_cylinder ( magnet , ** kwargs ): \"\"\"Calculates and plots the magnetic field along the central axis of a cylinder This is an example helper function. Args: magnet (Cylinder): instance of magnetic cylinder Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" rho = _np . linspace ( - 2 * magnet . radius , 2 * magnet . radius , 51 ) z = _np . array ([ magnet . length * 1.1 / 2 ]) Br , Bz = magnet . _calcB_cyl ( rho , z ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) _plt . plot ( rho * 1 , Bz , label = r \"$B_z$\" ) _plt . plot ( rho * 1 , Br , label = r \"$B_r$\" ) _plt . legend ( loc = \"best\" ) _plt . show () return fig , ax","title":"line_plot_cylinder()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.plot_2D_contour","text":"Contour plot of field Parameters: Name Type Description Default point_array Point_Array2 coordinates required field Field2 Magnetic Field required Kwargs save_fig (bool): Save to png file. Defaults to False xlab (str): x axis label ylab (str): y axis label clab (str): label for colorbar axis_scale (str): axis aspect ratio Defaults to 'equal'. show_magnets (bool): Draw magnets. Defaults to True field_component (str): Defaults to 'n'. plot_type (str): Draw contour or streamplot . Defaults to 'contour' cmap (str): Colormap. Defaults to viridis vector_plot (bool): Draw vectors as arrows. Defaults to False. vector_color (str): Arrow color. Defaults to 'w' cmin (float): Color scale minimum. Defaults to 0.0 cmax (float): Color scale minimum. Defaults to twice the mean field num_levels (int): Number of contour levels. Defaults to 11. Exceptions: Type Description Exception plot_type must be 'contour' or 'streamplot' Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_2D_contour ( point_array , field , ** kwargs ): \"\"\"Contour plot of field Args: point_array (Point_Array2): coordinates field (Field2): Magnetic Field Kwargs: save_fig (bool): Save to png file. Defaults to False xlab (str): x axis label ylab (str): y axis label clab (str): label for colorbar axis_scale (str): axis aspect ratio Defaults to 'equal'. show_magnets (bool): Draw magnets. Defaults to True field_component (str): Defaults to 'n'. plot_type (str): Draw `contour` or `streamplot`. Defaults to 'contour' cmap (str): Colormap. Defaults to `viridis` vector_plot (bool): Draw vectors as arrows. Defaults to False. vector_color (str): Arrow color. Defaults to 'w' cmin (float): Color scale minimum. Defaults to 0.0 cmax (float): Color scale minimum. Defaults to twice the mean field num_levels (int): Number of contour levels. Defaults to 11. Raises: Exception: plot_type must be 'contour' or 'streamplot' Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" import matplotlib.cm as _cm from ..magnets._polygon2D import PolyMagnet show_magnets = kwargs . pop ( \"show_magnets\" , True ) xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"y ( { point_array . unit } )\" ) clab = kwargs . pop ( \"clab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) field_component = kwargs . pop ( \"field_component\" , \"n\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) if plot_type . lower () == \"contour\" : cmap = kwargs . pop ( \"cmap\" , \"viridis\" ) vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) if field_component == \"x\" : field_chosen = field . x elif field_component == \"y\" : field_chosen = field . y else : field_chosen = field . n finite_field = field_chosen [ _np . isfinite ( field_chosen )] cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( point_array . x , point_array . y , field_chosen , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( point_array . x , point_array . y , field_chosen , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) # Draw field vectors if vector_plot : _vector_plot2 ( point_array , field , NQ , vector_color ) elif plot_type . lower () == \"streamplot\" : xpl = point_array . x [:, 0 ] ypl = point_array . y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( _np . nanmean ( field . n ), 1 )) cmax = kwargs . pop ( \"cmax\" , round ( _np . nanmean ( field . n ), 1 )) stream_shading = kwargs . pop ( \"stream_color\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : field . x . T , \"vertical\" : field . y . T , } CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , field . x . T / field . n . T , field . y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) # Draw magnets and magnetisation arrows if show_magnets : _draw_magnets2 ( ax ) if len ( PolyMagnet . instances ) > 0 : for magnet in PolyMagnet . instances : poly = _plt . Polygon ( _np . array ( magnet . polygon . vertices ), ec = \"k\" , fc = \"w\" , zorder = 5 , ) ax . add_patch ( poly ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . axis ( axis_scale ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () fig . tight_layout () ax . axis ( \"scaled\" ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) return fig , ax","title":"plot_2D_contour()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.plot_2D_line","text":"Line Plot of field from 2D magnet Parameters: Name Type Description Default point_array Point_Array2 coordinates required field Field2 Magnetic Field required Kwargs xlab (str): xlabel ylab (str): ylabel axis_scale (str): unused save_fig (bool): Save to png file. Defaults to False Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_2D_line ( point_array , field , ** kwargs ): \"\"\"Line Plot of field from 2D magnet Args: point_array (Point_Array2): coordinates field (Field2): Magnetic Field Kwargs: xlab (str): xlabel ylab (str): ylabel axis_scale (str): unused save_fig (bool): Save to png file. Defaults to False Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" xlab = kwargs . pop ( \"xlab\" , f \"x ( { point_array . unit } )\" ) ylab = kwargs . pop ( \"ylab\" , f \"B ( { field . unit } )\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) _plt . plot ( point_array . x , field . n , label = r \"$|\\mathbf {B} |$\" ) _plt . plot ( point_array . x , field . x , label = r \"$B_x$\" ) _plt . plot ( point_array . x , field . y , label = r \"$B_y$\" ) _plt . legend ( loc = \"best\" ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . show () if SAVE : _plt . savefig ( \"line_plot.png\" , dpi = 300 ) # _plt.savefig('contour_plot.pdf', dpi=300) return fig , ax","title":"plot_2D_line()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.plot_3D_contour","text":"Contour plot of field Parameters: Name Type Description Default points Point_Array2 coordinates required field Field2 Magnetic field required plane str Plane to draw contour on. Can be 'xy', 'xz', or 'yz' required Exceptions: Type Description Exception plot_type must be 'contour' or 'streamplot Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_3D_contour ( points , field , plane , ** kwargs ): \"\"\"Contour plot of field Args: points (Point_Array2): coordinates field (Field2): Magnetic field plane (str): Plane to draw contour on. Can be 'xy', 'xz', or 'yz' Raises: Exception: plot_type must be 'contour' or 'streamplot Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) plot_type = kwargs . pop ( \"plot_type\" , \"contour\" ) xlab = kwargs . pop ( \"xlab\" , \"x (\" + points . unit + \")\" ) ylab = kwargs . pop ( \"ylab\" , \"y (\" + points . unit + \")\" ) zlab = kwargs . pop ( \"zlab\" , \"z (\" + points . unit + \")\" ) clab = kwargs . pop ( \"clab\" , \"B (\" + field . unit + \")\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) finite_field = field . n [ _np . isfinite ( field . n )] cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) num_levels = kwargs . pop ( \"num_levels\" , 11 ) if plane . lower () == \"xy\" : plot_x = points . x plot_y = points . y plot_xlab = xlab plot_ylab = ylab stream_x = field . x stream_y = field . z elif plane . lower () == \"xz\" : stream_x = field . x stream_y = field . z plot_x = points . x plot_y = points . z plot_xlab = xlab plot_ylab = zlab else : stream_x = field . y stream_y = field . z plot_x = points . y plot_y = points . z plot_xlab = ylab plot_ylab = zlab fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) # Generate Contour Plot if plot_type . lower () == \"contour\" : vector_plot = kwargs . pop ( \"vector_plot\" , False ) vector_color = kwargs . pop ( \"vector_color\" , \"w\" ) NQ = kwargs . pop ( \"vector_arrows\" , 11 ) cmap = kwargs . pop ( \"cmap\" , \"viridis\" ) cmin = kwargs . pop ( \"cmin\" , 0 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) CS = _plt . contourf ( plot_x , plot_y , field . n , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"max\" , ) # Draw contour lines if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , field . n , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) if vector_plot : B_2D = Field2 ( stream_x , stream_y , unit = field . unit ) B_2D . n = field . n points_2D = Point_Array2 ( plot_x , plot_y , unit = points . unit ) _vector_plot2 ( points_2D , B_2D , NQ , vector_color ) # Generates streamplot elif plot_type . lower () == \"streamplot\" : xpl = plot_x [:, 0 ] ypl = plot_y [ 0 , :] cmap = kwargs . pop ( \"cmap\" , None ) if cmap is not None : cmin = kwargs . pop ( \"cmin\" , - round ( finite_field . mean () * 2 , 1 )) cmax = kwargs . pop ( \"cmax\" , round ( finite_field . mean () * 2 , 1 )) stream_shading = kwargs . pop ( \"stream_shading\" , \"vertical\" ) norm = _cm . colors . Normalize ( vmin = cmin , vmax = cmax ) stream_dict = { \"normal\" : field . n . T , \"horizontal\" : stream_x . T , \"vertical\" : stream_y . T , } CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , color = stream_dict . get ( stream_shading , \"normal\" ), density = 1.2 , norm = norm , cmap = cmap , linewidth = 0.5 , ) CB = _plt . colorbar ( CS . lines ) else : color = kwargs . pop ( \"color\" , \"k\" ) CS = _plt . streamplot ( xpl , ypl , stream_x . T / field . n . T , stream_y . T / field . n . T , density = 1.2 , linewidth = 0.5 , color = color , ) CB = None else : raise Exception ( \"plot_type must be 'contour' or 'streamplot'\" ) if CB is not None : CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( plot_xlab ) _plt . ylabel ( plot_ylab ) _plt . axis ( axis_scale ) if SAVE : _plt . savefig ( \"contour_plot.png\" , dpi = 300 ) return fig , ax","title":"plot_3D_contour()"},{"location":"code_reference/plots/#pymagnet.plots._plot2D.plot_sub_contour_3D","text":"Contour plot of a single magnetic field component of a 3D simulation Parameters: Name Type Description Default plot_x ndarray coordinates for x-axis of plot required plot_y ndarray coordinates for y-axis of plot required plot_B ndarray Magnetic field component to plot required Returns: Type Description tuple fig, ax reference to matplotlib figure and axis objects Source code in pymagnet/plots/_plot2D.py def plot_sub_contour_3D ( plot_x , plot_y , plot_B , ** kwargs ): \"\"\"Contour plot of a single magnetic field component of a 3D simulation Args: plot_x (ndarray): coordinates for x-axis of plot plot_y (ndarray): coordinates for y-axis of plot plot_B (ndarray): Magnetic field component to plot Returns: tuple: fig, ax reference to matplotlib figure and axis objects \"\"\" cmap = kwargs . pop ( \"cmap\" , \"seismic\" ) xlab = kwargs . pop ( \"xlab\" , f \"x (m)\" ) ylab = kwargs . pop ( \"ylab\" , f \"y (m)\" ) clab = kwargs . pop ( \"clab\" , f \"B (T)\" ) axis_scale = kwargs . pop ( \"axis_scale\" , \"equal\" ) SAVE = kwargs . pop ( \"save_fig\" , False ) cmin = kwargs . pop ( \"cmin\" , - 0.5 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 11 ) lev2 = _np . linspace ( cmin , cmax , 256 , endpoint = True ) fig , ax = _plt . subplots ( figsize = ( 8 , 8 )) CS = _plt . contourf ( plot_x , plot_y , plot_B , levels = lev2 , cmap = _plt . get_cmap ( cmap ), extend = \"both\" ) if num_levels > 1 : lev1 = _np . linspace ( cmin , cmax , num_levels , endpoint = True ) _ = _plt . contour ( plot_x , plot_y , plot_B , vmin = cmin , vmax = cmax , levels = lev1 , linewidths = 1.0 , colors = \"k\" , ) CB = _plt . colorbar ( CS , ticks = lev1 ) else : CB = _plt . colorbar ( CS ) CB . ax . get_yaxis () . labelpad = 15 CB . ax . set_ylabel ( clab , rotation = 270 ) _plt . xlabel ( xlab ) _plt . ylabel ( ylab ) _plt . axis ( \"equal\" ) _plt . show () return fig , ax 3D Plotting routines This module contains all functions needed to plot 3D contours for 3D magnetic sources. Unlike the plot2D module, here plotly is used as the backend. Todo Update str and repr for polyhedra","title":"plot_sub_contour_3D()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cuboid","text":"Generates Cuboid for plotly rendering","title":"Graphic_Cuboid"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cuboid.__init__","text":"Init method Parameters: Name Type Description Default center tuple Cuboid center. Defaults to (0, 0, 0). (0, 0, 0) size tuple Size of cuboid. Defaults to (1, 1, 1). (1, 1, 1) Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), size = ( 1 , 1 , 1 ), ** kwargs ): \"\"\"Init method Args: center (tuple, optional): Cuboid center. Defaults to (0, 0, 0). size (tuple, optional): Size of cuboid. Defaults to (1, 1, 1). Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size , ** kwargs ) self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cuboid.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), size = self . size ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . size ) return vertex_coords","title":"generate_vertices()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cylinder","text":"Generates vertices for a Cylinder for plotly rendering","title":"Graphic_Cylinder"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cylinder.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) radius float [description]. Defaults to 1. 1 length float [description]. Defaults to 1. 1 Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , length = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). radius (float, optional): [description]. Defaults to 1. length (float, optional): [description]. Defaults to 1. Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size = ( radius , radius , length ), ** kwargs ) self . radius = radius self . length = length self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Cylinder.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius , length = self . length ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius , self . length ) return vertex_coords","title":"generate_vertices()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Mesh","text":"Generates Mesh from STL file for plotly rendering","title":"Graphic_Mesh"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Mesh.__init__","text":"Init Method Parameters: Name Type Description Default mesh_vectors ndarray array of mesh vectors required Kwargs color (str): magnet color. Defaults to 'w'. Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , mesh_vectors , ** kwargs ): \"\"\"Init Method Args: mesh_vectors (ndarray): array of mesh vectors Kwargs: color (str): magnet color. Defaults to 'w'. \"\"\" self . color = kwargs . pop ( \"color\" , \"white\" ) self . mesh_vectors = mesh_vectors","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Mesh.generate_vertices","text":"Generates vertices from STL file Returns: Type Description dict Dictionary of rendering properties for plotly Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices from STL file Returns: dict: Dictionary of rendering properties for plotly \"\"\" # return super().generate_vertices() p , q , r = self . mesh_vectors . shape # (p, 3, 3) # the array stl_mesh.vectors.reshape(p*q, r) can contain multiple copies of the same vertex; # extract unique vertices from all mesh triangles vertices , ixr = _np . unique ( self . mesh_vectors . reshape ( p * q , r ), return_inverse = True , axis = 0 ) I = _np . take ( ixr , [ 3 * k for k in range ( p )]) J = _np . take ( ixr , [ 3 * k + 1 for k in range ( p )]) K = _np . take ( ixr , [ 3 * k + 2 for k in range ( p )]) x , y , z = vertices . T trace = _go . Mesh3d ( x = x , y = y , z = z , i = I , j = J , k = K , color = self . color ) # optional parameters to make it look nicer trace . update ( flatshading = True , lighting_facenormalsepsilon = 0 , lighting_ambient = 0.7 ) return trace","title":"generate_vertices()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Sphere","text":"Generates vertices for a sphere for plotly rendering","title":"Graphic_Sphere"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Sphere.__init__","text":"Init method Parameters: Name Type Description Default center tuple [description]. Defaults to (0, 0, 0). (0, 0, 0) radius float [description]. Defaults to 1. 1 Kwargs alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center = ( 0 , 0 , 0 ), radius = 1 , ** kwargs ): \"\"\"Init method Args: center (tuple, optional): [description]. Defaults to (0, 0, 0). radius (float, optional): [description]. Defaults to 1. Kwargs: alpha (float): rotation wit respect to ? axis. Defaults to 0.0. beta (float): rotation wit respect to ? axis. Defaults to 0.0. gamma (float): rotation wit respect to ? axis. Defaults to 0.0. color (str): color. Defaults to 'w' \"\"\" super () . __init__ ( center , size = ( radius , radius , radius ), ** kwargs ) self . radius = radius self . vertices = self . generate_vertices ()","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Graphic_Sphere.generate_vertices","text":"Generates and rotates vertices of a cuboid based on orientation angles Returns: Type Description ndarray 3xN array of vertex coordinates (columns are x, y, z) Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates and rotates vertices of a cuboid based on orientation angles Returns: ndarray: 3xN array of vertex coordinates (columns are x, y, z) \"\"\" # Generate and rotate the vertices if _np . any ( _np . fabs ( _np . array ( [ self . alpha_rad , self . beta_rad , self . gamma_rad , ] ) ) > Polyhedron . tol ): # _, reverse_rotation = self._generate_rotation_quaternions() forward_rotation = Quaternion . gen_rotation_quaternion ( self . alpha_rad , self . beta_rad , self . gamma_rad ) reverse_rotation = forward_rotation . get_conjugate () # Generate 3xN array for quaternion rotation vertex_coords = self . _gen_vertices ( center = ( 0 , 0 , 0 ), radius = self . radius ) # Rotate points x , y , z = reverse_rotation * vertex_coords # Reconstruct 3xN array and add center offset vertex_coords = _np . vstack ([ x , y , z ]) vertex_coords += _np . array ( self . center ) . reshape ( - 1 , 1 ) # finally return the coordinates return vertex_coords # Only generate else : vertex_coords = self . _gen_vertices ( self . center , self . radius ) return vertex_coords","title":"generate_vertices()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Polyhedron","text":"Encodes magnet dimensions for drawing a polyhedon on 3D plots Polyhedra Cuboid Cylinder Sphere Mesh","title":"Polyhedron"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Polyhedron.__init__","text":"Initialises a cuboid Parameters: Name Type Description Default center tuple x,y,z required size tuple x,y,z required Source code in pymagnet/plots/_plotly3D.py def __init__ ( self , center , size , ** kwargs ): \"\"\"Initialises a cuboid Args: center (tuple): x,y,z size (tuple): x,y,z \"\"\" super () . __init__ () self . center = _np . asarray ( center ) self . size = _np . asarray ( size ) self . alpha = kwargs . pop ( \"alpha\" , 0.0 ) self . alpha_rad = _np . deg2rad ( self . alpha ) self . beta = kwargs . pop ( \"beta\" , 0.0 ) self . beta_rad = _np . deg2rad ( self . beta ) self . gamma = kwargs . pop ( \"gamma\" , 0.0 ) self . gamma_rad = _np . deg2rad ( self . gamma ) self . color = kwargs . pop ( \"color\" , \"white\" )","title":"__init__()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.Polyhedron.generate_vertices","text":"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class Source code in pymagnet/plots/_plotly3D.py def generate_vertices ( self ): \"\"\"Generates vertices of a polyhedron This should be implemented for each Polyhedron child class \"\"\" pass","title":"generate_vertices()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.list_polyhedra","text":"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using pymagnet.reset_magnets() . Source code in pymagnet/plots/_plotly3D.py def list_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra. Assumes that the child class registries have not been modified outside of using `pymagnet.reset_magnets()`. \"\"\" return Polyhedron . print_instances ()","title":"list_polyhedra()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.plot_magnet","text":"Renders magnets Parameters: Name Type Description Default unit str unit scale. Defaults to 'mm'. 'mm' Returns: Type Description fig reference to figure Source code in pymagnet/plots/_plotly3D.py def plot_magnet ( unit = \"mm\" , ** kwargs ): \"\"\"Renders magnets Args: unit (str, optional): unit scale. Defaults to 'mm'. Returns: fig: reference to figure \"\"\" reset_polyhedra () magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) data_objects = [] data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + unit + \")\" , yaxis_title = \"y (\" + unit + \")\" , zaxis_title = \"z (\" + unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig","title":"plot_magnet()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.reset_polyhedra","text":"Returns a list of all instantiated polyhedra. Source code in pymagnet/plots/_plotly3D.py def reset_polyhedra (): \"\"\"Returns a list of all instantiated polyhedra.\"\"\" polyhedra_classes = [ Polyhedron , Graphic_Cuboid , Graphic_Sphere , Graphic_Cylinder , ] for cls in polyhedra_classes : cls . reset ()","title":"reset_polyhedra()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.slice_plot","text":"Plots magnetic field slices. A convenience function. Returns: Type Description tuple fig (reference to figure), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def slice_plot ( data_dict , ** kwargs ): \"\"\"Plots magnetic field slices. A convenience function. Returns: tuple: fig (reference to figure), data_objects (plotly dict) \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) # planes = kwargs.pop(\"planes\", [\"xy\", \"xz\", \"yz\"]) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) data_objects = [] show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in data_dict . keys (): points = data_dict [ plane ][ \"points\" ] field = data_dict [ plane ][ \"field\" ] data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) num_points = field . x . shape [ 0 ] NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , data_objects","title":"slice_plot()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.slice_quickplot","text":"Calculates and plots magnetic field slices. A convenience function. Returns: Type Description tuple fig (reference to figure), cache (cached data for each plane with potential keys: 'xy', 'xz', 'yz'), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def slice_quickplot ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices. A convenience function. Returns: tuple: fig (reference to figure), cache (cached data for each plane with potential keys: 'xy', 'xz', 'yz'), data_objects (plotly dict) \"\"\" reset_polyhedra () max1 = kwargs . pop ( \"max1\" , 30 ) max2 = kwargs . pop ( \"max2\" , 30 ) min1 = kwargs . pop ( \"min1\" , - 1 * max1 ) min2 = kwargs . pop ( \"min2\" , - 1 * max2 ) slice_value = kwargs . pop ( \"slice_value\" , 0.0 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) opacity = kwargs . pop ( \"opacity\" , 0.1 ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) planes = kwargs . pop ( \"planes\" , [ \"xy\" , \"xz\" , \"yz\" ]) num_arrows = kwargs . pop ( \"num_arrows\" , 20 ) num_points = kwargs . pop ( \"num_arrows\" , 100 ) NA = num_points // num_arrows if NA < 1 : NA = 1 cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) data_objects = [] cache = {} show_magnets = kwargs . pop ( \"show_magnets\" , True ) if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) for plane in planes : points = slice3D ( plane = plane , max1 = max1 , min1 = min1 , max2 = max2 , min2 = min2 , slice_value = slice_value , unit = unit , num_points = num_points , ) field = get_field_3D ( points ) cache [ plane ] = { \"points\" : points , \"field\" : field } data_objects . append ( _draw_surface_slice ( points , field , colorscale , opacity = opacity , cmin = cmin , cmax = cmax , showscale = True , ) ) data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , cache , data_objects","title":"slice_quickplot()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.volume_plot","text":"Plots magnetic field volume. Parameters: Name Type Description Default points Point_Array3 coordinates required field Field3 Magnetic field vector required Returns: Type Description tuple fig (reference to figure), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def volume_plot ( points , field , ** kwargs ): \"\"\"Plots magnetic field volume. Args: points (Point_Array3): coordinates field (Field3): Magnetic field vector Returns: tuple: fig (reference to figure), data_objects (plotly dict) \"\"\" reset_polyhedra () opacity = kwargs . pop ( \"opacity\" , 1 ) opacityscale = kwargs . pop ( \"opacityscale\" , None ) magnet_opacity = kwargs . pop ( \"magnet_opacity\" , 1.0 ) cone_opacity = kwargs . pop ( \"cone_opacity\" , 1.0 ) num_points = kwargs . pop ( \"num_points\" , None ) num_arrows = kwargs . pop ( \"num_arrows\" , None ) cmin = kwargs . pop ( \"cmin\" , 0 ) cmax = kwargs . pop ( \"cmax\" , 0.5 ) num_levels = kwargs . pop ( \"num_levels\" , 5 ) show_magnets = kwargs . pop ( \"show_magnets\" , True ) data_objects = [] if show_magnets : data_objects . extend ( _generate_all_meshes ( magnet_opacity = magnet_opacity )) colorscale = kwargs . pop ( \"colorscale\" , \"viridis\" ) # kernel_size = 1 # kernel = np.ones([kernel_size, kernel_size, kernel_size]) / kernel_size # B.n = ndimage.convolve(B.n, kernel) data_objects . append ( _generate_volume_data ( points , field , cmim = cmin , cmax = cmax , opacity = opacity , colorscale = colorscale , num_levels = num_levels , opacityscale = opacityscale , ) ) if num_arrows is not None : NA = num_points // num_arrows if NA < 1 : NA = 1 data_objects . append ( _draw_cones ( points , field , NA = NA , cone_opacity = cone_opacity ) ) fig = _go . Figure ( data = data_objects ) fig . update_layout ( scene = dict ( xaxis_title = \"x (\" + points . unit + \")\" , yaxis_title = \"y (\" + points . unit + \")\" , zaxis_title = \"z (\" + points . unit + \")\" , ), width = 700 , margin = dict ( r = 20 , b = 10 , l = 10 , t = 10 ), ) fig . update_layout ( scene_aspectmode = \"data\" ) fig . show () return fig , data_objects","title":"volume_plot()"},{"location":"code_reference/plots/#pymagnet.plots._plotly3D.volume_quickplot","text":"Calculates and plots magnetic field slices. A convenience function. Kwargs num_points (int): = kwargs.pop(\"num_points\", 30) unit (str): = kwargs.pop(\"unit\", \"mm\") xmax (float): Maximum x value. Defaults to 30.0. ymax (float): Maximum y value. Defaults to 30.0. zmax (float): Maximum z value. Defaults to 30.0. xmin (float): Minimum x value. Defaults to -xmax ymin (float): Minimum y value. Defaults to -ymax zmin (float): Minimum z value. Defaults to -zmax Returns: Type Description tuple fig (reference to figure), cache (cached data dict), data_objects (plotly dict) Source code in pymagnet/plots/_plotly3D.py def volume_quickplot ( ** kwargs ): \"\"\"Calculates and plots magnetic field slices. A convenience function. Kwargs: num_points (int): = kwargs.pop(\"num_points\", 30) unit (str): = kwargs.pop(\"unit\", \"mm\") xmax (float): Maximum x value. Defaults to 30.0. ymax (float): Maximum y value. Defaults to 30.0. zmax (float): Maximum z value. Defaults to 30.0. xmin (float): Minimum x value. Defaults to -xmax ymin (float): Minimum y value. Defaults to -ymax zmin (float): Minimum z value. Defaults to -zmax Returns: tuple: fig (reference to figure), cache (cached data dict), data_objects (plotly dict) \"\"\" num_points = kwargs . pop ( \"num_points\" , 30 ) unit = kwargs . pop ( \"unit\" , \"mm\" ) xmax = kwargs . pop ( \"xmax\" , 30 ) ymax = kwargs . pop ( \"ymax\" , 30 ) zmax = kwargs . pop ( \"zmax\" , 30 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) points = grid3D ( xmax , ymax , zmax , num_points = num_points , xmin = xmin , ymin = ymin , zmin = zmin , unit = unit , ) field = get_field_3D ( points ) fig , data_objects = volume_plot ( points , field , num_points = num_points , ** kwargs ) cache = { \"points\" : points , \"field\" : field } return fig , cache , data_objects","title":"volume_quickplot()"},{"location":"code_reference/pymagnet/","text":"Main module pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules __main__ special Example plots forces special pymagnets.forces Forcs and Torques This module imports the classes and functions in the private modules to create a public API. magnets special pymagnets.magnets This module imports the classes and functions in the private modules to create a public API. plots special pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly. utils special pymagnets.utils This module imports the classes and functions in the private modules to create a public API, including: Quaternion() Global Constants Point structures Vector structures global_const Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"pymagnet"},{"location":"code_reference/pymagnet/#main-module","text":"pymagnet User friendly magnetic field calculations Top level module for exposing the public API of usable modules","title":"Main module"},{"location":"code_reference/pymagnet/#pymagnet.__main__","text":"Example plots","title":"__main__"},{"location":"code_reference/pymagnet/#pymagnet.forces","text":"pymagnets.forces Forcs and Torques This module imports the classes and functions in the private modules to create a public API.","title":"forces"},{"location":"code_reference/pymagnet/#pymagnet.magnets","text":"pymagnets.magnets This module imports the classes and functions in the private modules to create a public API.","title":"magnets"},{"location":"code_reference/pymagnet/#pymagnet.plots","text":"pymagnets.plots This module imports the classes and functions in the private modules to create a public API. Lines and contour plots are drawn using matplotlib 3D surface and volume plots are rendered using plotly.","title":"plots"},{"location":"code_reference/pymagnet/#pymagnet.utils","text":"pymagnets.utils This module imports the classes and functions in the private modules to create a public API, including: Quaternion() Global Constants Point structures Vector structures","title":"utils"},{"location":"code_reference/pymagnet/#pymagnet.utils.global_const","text":"Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"global_const"},{"location":"code_reference/utils/","text":"Utils Module pymagnets.utils This module imports the classes and functions in the private modules to create a public API, including: Quaternion() Global Constants Point structures Vector structures global_const Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4 Routines for converting between coordinate systems, between 2D cartesian and polar, as well as 3D cartesian, cylindrical, and spherical. cart2pol ( x , y ) Converts from cartesian to polar coordinates Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/utils/_conversions.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (ndarray): x coordinates y (ndarray): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi ) cart2sph ( x , y , z ) Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/utils/_conversions.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi ) get_unit_value_meter ( unit ) Returns a queried metre unit as a number Examples: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_meter ( unit ): \"\"\"Returns a queried metre unit as a number Example: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"Ym\" : 1e24 , \"Zm\" : 1e21 , \"Em\" : 1e18 , \"Pm\" : 1e15 , \"Tm\" : 1e12 , \"Gm\" : 1e9 , \"Mm\" : 1e6 , \"km\" : 1e3 , \"hm\" : 1e2 , \"dam\" : 1e1 , \"m\" : 1 , \"dm\" : 1e-1 , \"cm\" : 1e-2 , \"mm\" : 1e-3 , \"\u00b5m\" : 1e-6 , \"um\" : 1e-6 , \"nm\" : 1e-9 , \"Ang\" : 1e-10 , \"pm\" : 1e-12 , \"fm\" : 1e-15 , \"am\" : 1e-18 , \"zm\" : 1e-21 , \"ym\" : 1e-24 , } return si_prefixes . get ( unit , None ) get_unit_value_tesla ( unit ) Returns a queried magnetic flux density unit as a number Examples: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_tesla ( unit ): \"\"\"Returns a queried magnetic flux density unit as a number Example: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"YT\" : 1e24 , \"ZT\" : 1e21 , \"ET\" : 1e18 , \"PT\" : 1e15 , \"TT\" : 1e12 , \"GT\" : 1e9 , \"MT\" : 1e6 , \"kT\" : 1e3 , \"hT\" : 1e2 , \"daT\" : 1e1 , \"T\" : 1 , \"dT\" : 1e-1 , \"cT\" : 1e-2 , \"mT\" : 1e-3 , \"\u00b5T\" : 1e-6 , \"uT\" : 1e-6 , \"nT\" : 1e-9 , \"pT\" : 1e-12 , \"fT\" : 1e-15 , \"aT\" : 1e-18 , \"zT\" : 1e-21 , \"yT\" : 1e-24 , } return si_prefixes . get ( unit , None ) pol2cart ( rho , phi ) Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho ndarray radial coordinates required phi ndarray azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/utils/_conversions.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (ndarray): radial coordinates phi (ndarray): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y ) sph2cart ( r , theta , phi ) Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r ndarray radial coordinates required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/utils/_conversions.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (ndarray): radial coordinates theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z sphere_sph2cart ( Br , Btheta , theta , phi ) Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br ndarray radial vector component required Btheta ndarray polar vector component required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (ndarray): radial vector component Btheta (ndarray): polar vector component theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz vector_pol2cart ( Brho , Bphi , phi ) Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho ndarray radial vector component required Bphi ndarray azimuthal vector component required phi ndarray azimuthal coordinates required Returns: Type Description tuple Bx, By Source code in pymagnet/utils/_conversions.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (ndarray): radial vector component Bphi (ndarray): azimuthal vector component phi (ndarray): azimuthal coordinates Returns: tuple: Bx, By \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By vector_sph2cart ( Br , Btheta , Bphi , theta , phi ) Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br ndarray radial vector component required Btheta ndarray polar vector component required Bphi ndarray azimuthal vector component required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (ndarray): radial vector component Btheta (ndarray): polar vector component Bphi (ndarray): azimuthal vector component theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz pymagnets.utils._point_structs Private module consiting of point classes and their methods. Point2 2D point class Note that multiplication of two points is done elementwise, dot product is a separate method. __init__ ( self , x , y ) special Init method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required Source code in pymagnet/utils/_point_structs.py def __init__ ( self , x , y ): \"\"\"Init method Args: x (ndarray): x coordinates y (ndarray): y coordinates \"\"\" self . x = x self . y = y distance_to ( self , point ) Calculates distance to a point Parameters: Name Type Description Default point Point2 Target point required Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to ( self , point ): \"\"\"Calculates distance to a point Args: point (Point2): Target point Returns: float: distance \"\"\" return _np . sqrt ( _np . power ( point . x - self . x , 2 ) + _np . power ( point . y - self . y , 2 )) distance_to_origin ( self ) Calculates distance to a origin Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to_origin ( self ): \"\"\"Calculates distance to a origin Returns: float: distance \"\"\" return self . _norm () Point3 3D point class Note that multiplication of two points is done elementwise, dot product is a separate method. distance_to ( self , point ) Calculates distance to a point Parameters: Name Type Description Default point Point2 Target point required Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to ( self , point ): return _np . sqrt ( _np . power ( point . x - self . x , 2 ) + _np . power ( point . y - self . y , 2 ) + _np . power ( point . z - self . z , 2 ) ) distance_to_origin ( self ) Calculates distance to a origin Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to_origin ( self ): return self . _norm () Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1 Quaternion Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ) special Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w ndarray scalar quaternion. Defaults to 1.0. 1.0 x ndarray vector component. Defaults to 0.0. 0.0 y ndarray vector component. Defaults to 0.0. 0.0 z ndarray vector component. Defaults to 0.0. 0.0 Source code in pymagnet/utils/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (ndarray, optional): scalar quaternion. Defaults to 1.0. x (ndarray, optional): vector component. Defaults to 0.0. y (ndarray, optional): vector component. Defaults to 0.0. z (ndarray, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z ) as_tuple ( self ) Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/utils/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z euler_to_quaternion ( alpha , beta , gamma ) staticmethod Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float angle to z-axis required beta float angle to y-axis required gamma float angle to x-axis required Returns: Type Description Quaternion Euler angles as a Quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): angle to z-axis beta (float): angle to y-axis gamma (float): angle to x-axis Returns: Quaternion: Euler angles as a Quaternion \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz ) gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ) staticmethod Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > MAG_TOL : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > MAG_TOL : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > MAG_TOL : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation get_conjugate ( self ) Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/utils/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z ) q_angle_from_axis ( theta , vec ) Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion vec_norm ( x , y , z ) staticmethod Normalises each x,y,z vector Parameters: Name Type Description Default x ndarray x array required y ndarray y array required z ndarray z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/utils/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (ndarray): x array y (ndarray): y array z (ndarray): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Routines for Two Dimensional Magnet Classes FgradB_2D ( B , x , y , chi_m , c ) Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description Field2 Magnetic field gradient force vector Source code in pymagnet/utils/_routines2D.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Field2): Magnetic field vector x (ndarray): x coordinates y (ndarray): y coordinates Returns: Field2: Magnetic field gradient force vector \"\"\" BgB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / MU0 ) * chi_m * c * BgB . n FB . x = ( 1 / MU0 ) * chi_m * c * BgB . x FB . y = ( 1 / MU0 ) * chi_m * c * BgB . y return FB get_field_2D ( Point_Array2 ) Calculates magnetic field at an array of points due to every instantated Magnet2D magnet. Parameters: Name Type Description Default Point_Array2 Point_Array2 array of x,y points and associated unit, defaults to 'mm' required Returns: Type Description Field2 array of Bx,By,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines2D.py def get_field_2D ( Point_Array2 ): \"\"\"Calculates magnetic field at an array of points due to every instantated `Magnet2D` magnet. Args: Point_Array2 (Point_Array2): array of x,y points and associated unit, defaults to 'mm' Returns: Field2: array of Bx,By,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet2D # Empty data structure B = _allocate_field_array2 ( Point_Array2 . x , Point_Array2 . y ) for magnet in Magnet2D . instances : Bx , By = magnet . get_field ( Point_Array2 . x , Point_Array2 . y ) B . x += Bx B . y += By B . calc_norm () return B gradB_2D ( B , x , y ) Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description Field2 Magnetic field gradient vector Source code in pymagnet/utils/_routines2D.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Field2): Magnetic field vector x (ndarray): x coordinates y (ndarray): y coordinates Returns: Field2: Magnetic field gradient vector \"\"\" dB = Field2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB grid2D ( xmax , ymax , ** kwargs ) Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (str): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines2D.py def grid2D ( xmax , ymax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (str): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j x , y = _np . mgrid [ xmin : xmax : NPJ , ymin : ymax : NPJ ] return Point_Array2 ( x , y , unit = unit ) rotate_points_2D ( x , y , alpha ) Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x ndarray array of x coordinates required y ndarray array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/utils/_routines2D.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (ndarray): array of x coordinates y (ndarray): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes get_field_3D ( points ) Calculates magnetic field at an array of points due to every instantated Magnet3D magnet. Parameters: Name Type Description Default Point_Array3 Point_Array3 array of x,y,z points and associated unit, defaults to 'mm' required Returns: Type Description Field3 array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines3D.py def get_field_3D ( points ): \"\"\"Calculates magnetic field at an array of points due to every instantated `Magnet3D` magnet. Args: Point_Array3 (Point_Array3): array of x,y,z points and associated unit, defaults to 'mm' Returns: Field3: array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet3D B = _allocate_field_array3 ( points . x , points . y , points . z ) for magnet in Magnet3D . instances : Bx , By , Bz = magnet . get_field ( points . x , points . y , points . z ) B . x += Bx . reshape ( B . x . shape ) B . y += By . reshape ( B . y . shape ) B . z += Bz . reshape ( B . z . shape ) B . calc_norm () return B grid3D ( xmax , ymax , zmax , ** kwargs ) Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required zmax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax zmin (float): minimum y value. Defaults to -zmax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def grid3D ( xmax , ymax , zmax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value zmax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax zmin (float): minimum y value. Defaults to -zmax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , None ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j if num_points is None : num_points_x = kwargs . pop ( \"num_points_x\" , 100 ) num_points_y = kwargs . pop ( \"num_points_y\" , 100 ) num_points_z = kwargs . pop ( \"num_points_z\" , 100 ) else : num_points_x = num_points num_points_y = num_points num_points_z = num_points x , y , z = _np . mgrid [ xmin : xmax : num_points_x * 1 j , ymin : ymax : num_points_y * 1 j , zmin : zmax : num_points_z * 1 j , ] return Point_Array3 ( x , y , z , unit = unit ) slice3D ( plane = 'xy' , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = 'mm' , ** kwargs ) Generates a planar slice of values Parameters: Name Type Description Default plane str plane. Defaults to \"xy\". 'xy' max1 float maximum along axis 1. Defaults to 1.0. 1.0 max2 float maximum along axis 2. Defaults to 1.0. 1.0 slice_value float constant value for third axis. Defaults to 0.0. 0.0 unit str length scale units. Defaults to \"mm\". 'mm' Kwargs num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Exceptions: Type Description Exception plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Type Description Point_Array3 array of x, y, and z values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def slice3D ( plane = \"xy\" , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = \"mm\" , ** kwargs ): \"\"\"Generates a planar slice of values Args: plane (str, optional): plane. Defaults to \"xy\". max1 (float, optional): maximum along axis 1. Defaults to 1.0. max2 (float, optional): maximum along axis 2. Defaults to 1.0. slice_value (float, optional): constant value for third axis. Defaults to 0.0. unit (str, optional): length scale units. Defaults to \"mm\". Kwargs: num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Raises: Exception: plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Point_Array3: array of x, y, and z values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) min1 = kwargs . pop ( \"min1\" , - 1 * max1 ) min2 = kwargs . pop ( \"min2\" , - 1 * max2 ) NPj = num_points * 1 j if plane . lower () == \"xy\" : x , y = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] z = _np . asarray ([ slice_value ]) z = _np . tile ( z , x . shape ) elif plane . lower () == \"xz\" : x , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] y = _np . asarray ([ slice_value ]) y = _np . tile ( y , x . shape ) elif plane . lower () == \"yz\" : y , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] x = _np . asarray ([ slice_value ]) x = _np . tile ( x , y . shape ) elif plane . lower () == \"custom\" : x = kwargs . pop ( \"custom_x\" , _np . array ([ 0.0 ])) y = kwargs . pop ( \"custom_y\" , _np . array ([ 0.0 ])) z = kwargs . pop ( \"custom_z\" , _np . array ([ 0.0 ])) else : raise Exception ( \"plane must be one of 'xy', 'xz, 'yz', or 'custom'\" ) return Point_Array3 ( x , y , z , unit = unit ) Contains functions needed to rotate and translate a triangle to lie in the xz plane and to divide it into two right angled triangles align_triangle_to_y ( triangle , rot_axis , norm_vec ) Rotates and translates a triangle in lie in the xz plane Parameters: Name Type Description Default triangle ndarray vertices of a triangle required rot_axis ndarray axis about which to rotate triangle required norm_vec ndarray normal to triangle required Returns: Type Description tuple aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_to_y ( triangle , rot_axis , norm_vec ): \"\"\"Rotates and translates a triangle in lie in the xz plane Args: triangle (ndarray): vertices of a triangle rot_axis (ndarray): axis about which to rotate triangle norm_vec (ndarray): normal to triangle Returns: tuple: aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) \"\"\" y_axis = _np . array ([ 0 , 1 , 0 ]) if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( y_axis , norm_vec ): # Parallel first_rotation = Quaternion () aligned_triangle = triangle else : # Anti-parallel first_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) else : angle = - _np . arccos ( _np . dot ( y_axis , norm_vec )) first_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) return aligned_triangle , first_rotation align_triangle_xz ( triangle , longest_side ) Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Parameters: Name Type Description Default triangle ndarray vertices of triangle required longest_side int index of the longest side of triangle required Returns: Type Description tuple second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_xz ( triangle , longest_side ): \"\"\"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Args: triangle (ndarray): vertices of triangle longest_side (int): index of the longest side of triangle Returns: tuple: second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): \"\"\" x_axis = _np . array ([ 1 , 0 , 0 ]) y_axis = _np . array ([ 0 , 1 , 0 ]) z_axis = _np . array ([ 0 , 0 , 1 ]) # side_list = [0, 1, 2] # side_list.pop(longest_side) vec_x = return_axis_vector ( triangle , longest_side ) rot_axis = _np . cross ( x_axis , vec_x ) # Check aligment of base of triangle with x-axis if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( x_axis , vec_x ): # Parallel second_rotation = Quaternion () tri_x = triangle else : # Anti-parallel second_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) tri_x = rotate_points ( triangle , second_rotation ) else : angle = - _np . arccos ( _np . dot ( x_axis , vec_x )) second_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) tri_x = rotate_points ( triangle , second_rotation ) vec_z = return_z_vector ( tri_x , longest_side ) rot_axis = _np . cross ( z_axis , vec_z ) # Check aligment of triangle altitude with z-axis if _np . all ( _np . fabs ([ rot_axis ]) < ALIGN_CUTOFF ): # Check if parallel anti-parallel if check_sign ( z_axis , vec_z ): # Parallel third_rotation = Quaternion () else : # Anti-parallel third_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) else : angle = - _np . arccos ( _np . dot ( z_axis , vec_z )) third_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) return second_rotation , third_rotation altitude ( a , b , c ) Gets altitude to side a of a triangle. Parameters: Name Type Description Default a float longest side required b float triangle side required c float triangle side required Returns: Type Description float altitude to side a Source code in pymagnet/utils/_trigonometry3D.py def altitude ( a , b , c ): \"\"\"Gets altitude to side `a` of a triangle. Args: a (float): longest side b (float): triangle side c (float): triangle side Returns: float: altitude to side `a` \"\"\" s = ( a + b + c ) / 2 return 2 * _np . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )) / a check_sign ( vector_1 , vector_2 ) Returns true if the signs of all elements of two arrays are the same Parameters: Name Type Description Default vector_1 ndarray input array 2 required vector_2 ndarray input array 2 required Returns: Type Description boolean True if elements in two arrays have the same sign Source code in pymagnet/utils/_trigonometry3D.py def check_sign ( vector_1 , vector_2 ): \"\"\"Returns true if the signs of all elements of two arrays are the same Args: vector_1 (ndarray): input array 2 vector_2 (ndarray): input array 2 Returns: boolean: True if elements in two arrays have the same sign \"\"\" sign_comp_1 = _np . fabs ( vector_1 + vector_2 ) sign_comp_2 = _np . fabs ( vector_1 ) + _np . fabs ( vector_2 ) return _np . allclose ( sign_comp_1 , sign_comp_2 , atol = 1e-6 ) norm_plane ( vec ) Calculates the normal to a triangular plane Parameters: Name Type Description Default vec ndarray/list/tuple (N,1) array required Returns: Type Description ndarray normal vector (N,) Source code in pymagnet/utils/_trigonometry3D.py def norm_plane ( vec ): \"\"\"Calculates the normal to a triangular plane Args: vec (ndarray/list/tuple): (N,1) array Returns: ndarray: normal vector (N,) \"\"\" norm = _np . cross ( vec [ 1 ] - vec [ 0 ], vec [ 2 ] - vec [ 0 ]) norm = norm / _np . linalg . norm ( norm ) return norm return_axis_vector ( triangle , longest_side ) Returns vector collinear to the longest side of a triangle Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray vector corresponding to longest side Source code in pymagnet/utils/_trigonometry3D.py def return_axis_vector ( triangle , longest_side ): \"\"\"Returns vector collinear to the longest side of a triangle Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: vector corresponding to longest side \"\"\" vector_A = triangle [ 1 ] - triangle [ 0 ] vector_A = vector_A / _np . linalg . norm ( vector_A ) vector_B = triangle [ 2 ] - triangle [ 1 ] vector_B = vector_B / _np . linalg . norm ( vector_B ) vector_C = triangle [ 2 ] - triangle [ 0 ] vector_C = vector_C / _np . linalg . norm ( vector_C ) vec_dict = { 0 : vector_A , 1 : vector_B , 2 : vector_C , } vec = vec_dict [ longest_side ] return vec return_z_vector ( triangle , longest_side ) Returns altitude vector from longest side Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray altitude vector Source code in pymagnet/utils/_trigonometry3D.py def return_z_vector ( triangle , longest_side ): \"\"\"Returns altitude vector from longest side Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: altitude vector \"\"\" new_vertex_dict = { 0 : [ triangle [ 2 , 0 ], triangle [ 0 , 1 ], triangle [ 0 , 2 ]], 1 : [ triangle [ 0 , 0 ], triangle [ 0 , 1 ], triangle [ 1 , 2 ]], 2 : [ triangle [ 1 , 0 ], triangle [ 2 , 1 ], triangle [ 2 , 2 ]], } new_vertex = _np . array ( new_vertex_dict [ longest_side ]) vec_z_dict = { 0 : triangle [ 2 ] - new_vertex , 1 : triangle [ 0 ] - new_vertex , 2 : triangle [ 1 ] - new_vertex , } vec_z = vec_z_dict [ longest_side ] vec_z = vec_z / _np . linalg . norm ( vec_z ) return vec_z rotate_points ( points , rotation_quaternion ) Rotates a set of points Parameters: Name Type Description Default points [type] [description] required rotation_quaternion [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/utils/_trigonometry3D.py def rotate_points ( points , rotation_quaternion ): \"\"\"Rotates a set of points Args: points ([type]): [description] rotation_quaternion ([type]): [description] Returns: [type]: [description] \"\"\" x_rot , y_rot , z_rot = rotation_quaternion * points . T rotate_points = _np . vstack ([ x_rot , y_rot , z_rot ]) . T return rotate_points signed_area ( triangle ) Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Parameters: Name Type Description Default triangle ndarray 3x3 array of vertices required Returns: Type Description float signed area Source code in pymagnet/utils/_trigonometry3D.py @jit def signed_area ( triangle ): \"\"\"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Args: triangle (ndarray): 3x3 array of vertices Returns: float: signed area \"\"\" j = 1 NP = 3 area = 0.0 for i in range ( NP ): j = j % NP area += ( triangle [ j ][ 0 ] - triangle [ i ][ 0 ]) * ( triangle [ j ][ 2 ] + triangle [ i ][ 2 ]) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points area /= 2.0 return area pymagnets.utils._vector_structs Private module consiting of vector and point array classes and their methods. Field1 1D Field vector This is used to contain one component (Bz as z), and the units ('T', 'mT', etc) __init__ ( self , z , unit = 'T' ) special Init method Parameters: Name Type Description Default z ndarray Magnetic field component required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , z , unit = \"T\" ): \"\"\"Init method Args: z (ndarray): Magnetic field component unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( z ) if get_unit_value_tesla ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. T, mT, uT, nT \" ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f82bde4df70 > ) Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value ) Field2 2D Field vector This is used to contain two components (x, y), and the units ('T', 'mT', etc) __init__ ( self , x , y , unit = 'T' ) special Init method Parameters: Name Type Description Default x ndarray Magnetic field component Bx required y ndarray Magnetic field component By required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , unit = \"T\" ): \"\"\"Init method Args: x (ndarray): Magnetic field component Bx y (ndarray): Magnetic field component By unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( x , y ) self . n = _np . zeros_like ( x ) if get_unit_value_tesla ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. T, mT, uT, nT \" ) calc_norm ( self ) Calculates the norm of the 2D vector Source code in pymagnet/utils/_vector_structs.py def calc_norm ( self ): \"\"\"Calculates the norm of the 2D vector\"\"\" self . n = _np . linalg . norm ([ self . x , self . y ], axis = 0 ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f82bde4df70 > ) Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value ) Field3 2D Field vector This is used to contain three components (x, y), and the units ('T', 'mT', etc) __init__ ( self , x , y , z , unit = 'T' ) special Init method Parameters: Name Type Description Default x ndarray Magnetic field component Bx required y ndarray Magnetic field component By required z ndarray Magnetic field component Bz required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , z , unit = \"T\" ): \"\"\"Init method Args: x (ndarray): Magnetic field component Bx y (ndarray): Magnetic field component By z (ndarray): Magnetic field component Bz unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( x , y , z ) self . n = _np . zeros_like ( x ) self . unit = unit calc_norm ( self ) Calculates the norm of the 3D vector Source code in pymagnet/utils/_vector_structs.py def calc_norm ( self ): \"\"\"Calculates the norm of the 3D vector\"\"\" self . n = _np . linalg . norm ([ self . x , self . y , self . z ], axis = 0 ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_tesla at 0x7f82bde4df70 > ) Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value ) Point_Array1 1D point structure This is used to contain one position array (z), and the units ('mm', 'cm', etc) __init__ ( self , z , unit = 'mm' ) special Init method Parameters: Name Type Description Default z ndarray z coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , z , unit = \"mm\" ): \"\"\"Init method Args: z (ndarray): z coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" self . z = _np . asarray ( z ) if get_unit_value_meter ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. km, m, cm, mm \" ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f82bde4dee0 > ) Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Prism , Cylinder current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . depth = magnet . depth * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val get_unit ( self ) Gets unit Returns: Type Description str unit Source code in pymagnet/utils/_vector_structs.py def get_unit ( self ): \"\"\"Gets unit Returns: str: unit \"\"\" return self . unit Point_Array2 2D point structure This is used to contain two position arrays (x, y), and the units ('mm', 'cm', etc) __init__ ( self , x , y , unit = 'mm' ) special Init Method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , unit = \"mm\" ): \"\"\"Init Method Args: x (ndarray): x coordinates y (ndarray): y coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) if get_unit_value_meter ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. km, m, cm, mm \" ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f82bde4dee0 > ) Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Rectangle , Square , Circle , PolyMagnet current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Rectangle ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Square ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Circle ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , PolyMagnet ): magnet . polygon . vertices = ( scale_val * _np . array ( magnet . polygon . vertices ) ) . tolist () Point_Array3 3D point structure This is used to contain three position arrays (x, y, z), and the units ('mm', 'cm', etc) __init__ ( self , x , y , z , unit = 'mm' ) special Init Method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , z , unit = \"mm\" ): \"\"\"Init Method Args: x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" super () . __init__ ( x , y , unit = unit ) self . z = _np . asarray ( z ) change_unit ( self , new_unit , get_unit_value =< function get_unit_value_meter at 0x7f82bde4dee0 > ) Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Prism , Cube , Cylinder , Sphere , Mesh current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val magnet . depth = magnet . depth * scale_val elif issubclass ( magnet . __class__ , Cube ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val elif issubclass ( magnet . __class__ , Sphere ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , Mesh ): magnet . mesh_vectors = magnet . mesh_vectors * scale_val Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"utils"},{"location":"code_reference/utils/#utils-module","text":"pymagnets.utils This module imports the classes and functions in the private modules to create a public API, including: Quaternion() Global Constants Point structures Vector structures","title":"Utils Module"},{"location":"code_reference/utils/#pymagnet.utils.global_const","text":"Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4 Routines for converting between coordinate systems, between 2D cartesian and polar, as well as 3D cartesian, cylindrical, and spherical.","title":"global_const"},{"location":"code_reference/utils/#pymagnet.utils._conversions.cart2pol","text":"Converts from cartesian to polar coordinates Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description tuple rho, phi Source code in pymagnet/utils/_conversions.py def cart2pol ( x , y ): \"\"\"Converts from cartesian to polar coordinates Args: x (ndarray): x coordinates y (ndarray): y coordinates Returns: tuple: rho, phi \"\"\" rho = _np . sqrt ( x ** 2 + y ** 2 ) phi = _np . arctan2 ( y , x ) return ( rho , phi )","title":"cart2pol()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.cart2sph","text":"Converts from cartesian to spherical coordinates Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required Returns: Type Description tuple r, theta, phi Source code in pymagnet/utils/_conversions.py def cart2sph ( x , y , z ): \"\"\"Converts from cartesian to spherical coordinates Args: x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates Returns: tuple: r, theta, phi \"\"\" r = _np . sqrt ( x ** 2 + y ** 2 + z ** 2 ) phi = _np . arctan2 ( y , x ) # Hide the warning for situtations where there is a divide by zero. # This returns a NaN in the array, which is ignored for plotting. with _np . errstate ( divide = \"ignore\" , invalid = \"ignore\" ): theta = _np . arccos ( z / r ) return ( r , theta , phi )","title":"cart2sph()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.get_unit_value_meter","text":"Returns a queried metre unit as a number Examples: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_meter ( unit ): \"\"\"Returns a queried metre unit as a number Example: factor = get_unit_value_meter('cm') print(f\"factor for 'cm' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"Ym\" : 1e24 , \"Zm\" : 1e21 , \"Em\" : 1e18 , \"Pm\" : 1e15 , \"Tm\" : 1e12 , \"Gm\" : 1e9 , \"Mm\" : 1e6 , \"km\" : 1e3 , \"hm\" : 1e2 , \"dam\" : 1e1 , \"m\" : 1 , \"dm\" : 1e-1 , \"cm\" : 1e-2 , \"mm\" : 1e-3 , \"\u00b5m\" : 1e-6 , \"um\" : 1e-6 , \"nm\" : 1e-9 , \"Ang\" : 1e-10 , \"pm\" : 1e-12 , \"fm\" : 1e-15 , \"am\" : 1e-18 , \"zm\" : 1e-21 , \"ym\" : 1e-24 , } return si_prefixes . get ( unit , None )","title":"get_unit_value_meter()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.get_unit_value_tesla","text":"Returns a queried magnetic flux density unit as a number Examples: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Parameters: Name Type Description Default unit string SI length unit required Returns: Type Description float SI prefix factor Source code in pymagnet/utils/_conversions.py def get_unit_value_tesla ( unit ): \"\"\"Returns a queried magnetic flux density unit as a number Example: factor = get_unit_value_meter('mT') print(f\"factor for 'mT' is {factor}\") Args: unit (string): SI length unit Returns: float: SI prefix factor \"\"\" si_prefixes = { \"YT\" : 1e24 , \"ZT\" : 1e21 , \"ET\" : 1e18 , \"PT\" : 1e15 , \"TT\" : 1e12 , \"GT\" : 1e9 , \"MT\" : 1e6 , \"kT\" : 1e3 , \"hT\" : 1e2 , \"daT\" : 1e1 , \"T\" : 1 , \"dT\" : 1e-1 , \"cT\" : 1e-2 , \"mT\" : 1e-3 , \"\u00b5T\" : 1e-6 , \"uT\" : 1e-6 , \"nT\" : 1e-9 , \"pT\" : 1e-12 , \"fT\" : 1e-15 , \"aT\" : 1e-18 , \"zT\" : 1e-21 , \"yT\" : 1e-24 , } return si_prefixes . get ( unit , None )","title":"get_unit_value_tesla()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.pol2cart","text":"Converts from polar to cartesian coordinates Parameters: Name Type Description Default rho ndarray radial coordinates required phi ndarray azimuthal coordinates required Returns: Type Description tuple x,y Source code in pymagnet/utils/_conversions.py def pol2cart ( rho , phi ): \"\"\"Converts from polar to cartesian coordinates Args: rho (ndarray): radial coordinates phi (ndarray): azimuthal coordinates Returns: tuple: x,y \"\"\" x = rho * _np . cos ( phi ) y = rho * _np . sin ( phi ) return ( x , y )","title":"pol2cart()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.sph2cart","text":"Converts from spherical to cartesian coordinates Parameters: Name Type Description Default r ndarray radial coordinates required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple x,y,z Source code in pymagnet/utils/_conversions.py def sph2cart ( r , theta , phi ): \"\"\"Converts from spherical to cartesian coordinates Args: r (ndarray): radial coordinates theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: x,y,z \"\"\" x = r * _np . sin ( theta ) * _np . cos ( phi ) y = r * _np . sin ( theta ) * _np . sin ( phi ) z = r * _np . cos ( theta ) return x , y , z","title":"sph2cart()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.sphere_sph2cart","text":"Converts magnetic field of a sphere from spherical to cartesian coordinates Parameters: Name Type Description Default Br ndarray radial vector component required Btheta ndarray polar vector component required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def sphere_sph2cart ( Br , Btheta , theta , phi ): \"\"\"Converts magnetic field of a sphere from spherical to cartesian coordinates Args: Br (ndarray): radial vector component Btheta (ndarray): polar vector component theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) By = Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz","title":"sphere_sph2cart()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.vector_pol2cart","text":"Converts Vectors from polar to cartesian coordinates Parameters: Name Type Description Default Brho ndarray radial vector component required Bphi ndarray azimuthal vector component required phi ndarray azimuthal coordinates required Returns: Type Description tuple Bx, By Source code in pymagnet/utils/_conversions.py def vector_pol2cart ( Brho , Bphi , phi ): \"\"\"Converts Vectors from polar to cartesian coordinates Args: Brho (ndarray): radial vector component Bphi (ndarray): azimuthal vector component phi (ndarray): azimuthal coordinates Returns: tuple: Bx, By \"\"\" Bx = Brho * _np . cos ( phi ) - Bphi * _np . sin ( phi ) By = Brho * _np . sin ( phi ) + Bphi * _np . cos ( phi ) return Bx , By","title":"vector_pol2cart()"},{"location":"code_reference/utils/#pymagnet.utils._conversions.vector_sph2cart","text":"Converts Vectors from spherical to cartesian coordinates Parameters: Name Type Description Default Br ndarray radial vector component required Btheta ndarray polar vector component required Bphi ndarray azimuthal vector component required theta ndarray azimuthal angles required phi ndarray polar angle required Returns: Type Description tuple Bx,By,Bz Source code in pymagnet/utils/_conversions.py def vector_sph2cart ( Br , Btheta , Bphi , theta , phi ): \"\"\"Converts Vectors from spherical to cartesian coordinates Args: Br (ndarray): radial vector component Btheta (ndarray): polar vector component Bphi (ndarray): azimuthal vector component theta (ndarray): azimuthal angles phi (ndarray): polar angle Returns: tuple: Bx,By,Bz \"\"\" Bx = ( Br * _np . sin ( theta ) * _np . cos ( phi ) + Btheta * _np . cos ( theta ) * _np . cos ( phi ) - Bphi * _np . sin ( phi ) ) By = ( Br * _np . sin ( theta ) * _np . sin ( phi ) + Btheta * _np . cos ( theta ) * _np . sin ( phi ) + Bphi * _np . cos ( phi ) ) Bz = Br * _np . cos ( theta ) - Btheta * _np . sin ( theta ) return Bx , By , Bz pymagnets.utils._point_structs Private module consiting of point classes and their methods.","title":"vector_sph2cart()"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point2","text":"2D point class Note that multiplication of two points is done elementwise, dot product is a separate method.","title":"Point2"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point2.__init__","text":"Init method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required Source code in pymagnet/utils/_point_structs.py def __init__ ( self , x , y ): \"\"\"Init method Args: x (ndarray): x coordinates y (ndarray): y coordinates \"\"\" self . x = x self . y = y","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point2.distance_to","text":"Calculates distance to a point Parameters: Name Type Description Default point Point2 Target point required Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to ( self , point ): \"\"\"Calculates distance to a point Args: point (Point2): Target point Returns: float: distance \"\"\" return _np . sqrt ( _np . power ( point . x - self . x , 2 ) + _np . power ( point . y - self . y , 2 ))","title":"distance_to()"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point2.distance_to_origin","text":"Calculates distance to a origin Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to_origin ( self ): \"\"\"Calculates distance to a origin Returns: float: distance \"\"\" return self . _norm ()","title":"distance_to_origin()"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point3","text":"3D point class Note that multiplication of two points is done elementwise, dot product is a separate method.","title":"Point3"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point3.distance_to","text":"Calculates distance to a point Parameters: Name Type Description Default point Point2 Target point required Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to ( self , point ): return _np . sqrt ( _np . power ( point . x - self . x , 2 ) + _np . power ( point . y - self . y , 2 ) + _np . power ( point . z - self . z , 2 ) )","title":"distance_to()"},{"location":"code_reference/utils/#pymagnet.utils._point_structs.Point3.distance_to_origin","text":"Calculates distance to a origin Returns: Type Description float distance Source code in pymagnet/utils/_point_structs.py def distance_to_origin ( self ): return self . _norm () Quaternion module Implements quaternion multiplication for convenient rotation of vectors in 3D. Examples: Rotation of a vector about the x-axis: import numpy as np import pymagnet as pm vector1 = np.array([1,0,0]) rotate_about_z = pm.magnets.Quaternion.q_angle_from_axis(np.pi/2, (0, 0, 1)) vector2 = rotate_about_z * vector1","title":"distance_to_origin()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion","text":"Quaternion class. overloading of multiplication symbol allows easy quaternion multiplications","title":"Quaternion"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.__init__","text":"Initialse a pure quaternion (1; 0, 0, 0) Parameters: Name Type Description Default w ndarray scalar quaternion. Defaults to 1.0. 1.0 x ndarray vector component. Defaults to 0.0. 0.0 y ndarray vector component. Defaults to 0.0. 0.0 z ndarray vector component. Defaults to 0.0. 0.0 Source code in pymagnet/utils/_quaternion.py def __init__ ( self , w = 1.0 , x = 0.0 , y = 0.0 , z = 0.0 ): \"\"\"Initialse a pure quaternion (1; 0, 0, 0) Args: w (ndarray, optional): scalar quaternion. Defaults to 1.0. x (ndarray, optional): vector component. Defaults to 0.0. y (ndarray, optional): vector component. Defaults to 0.0. z (ndarray, optional): vector component. Defaults to 0.0. \"\"\" self . w = _np . asarray ( w ) self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) self . z = _np . asarray ( z )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.as_tuple","text":"Returns quaternion as tuple of arrays Returns: Type Description tuple w (array), x (array), y (array), z (array) Source code in pymagnet/utils/_quaternion.py def as_tuple ( self ): \"\"\"Returns quaternion as tuple of arrays Returns: tuple: w (array), x (array), y (array), z (array) \"\"\" return self . w , self . x , self . y , self . z","title":"as_tuple()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.euler_to_quaternion","text":"Converts Euler angles to quaternion Parameters: Name Type Description Default alpha float angle to z-axis required beta float angle to y-axis required gamma float angle to x-axis required Returns: Type Description Quaternion Euler angles as a Quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def euler_to_quaternion ( alpha , beta , gamma ): \"\"\"Converts Euler angles to quaternion Args: alpha (float): angle to z-axis beta (float): angle to y-axis gamma (float): angle to x-axis Returns: Quaternion: Euler angles as a Quaternion \"\"\" qw = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qx = _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . cos ( gamma / 2 ) - _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . sin ( gamma / 2 ) qy = _np . cos ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) + _np . sin ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) qz = _np . cos ( alpha / 2 ) * _np . cos ( beta / 2 ) * _np . sin ( gamma / 2 ) - _np . sin ( alpha / 2 ) * _np . sin ( beta / 2 ) * _np . cos ( gamma / 2 ) return Quaternion ( qw , qx , qy , qz )","title":"euler_to_quaternion()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.gen_rotation_quaternion","text":"Generates quaternion for rotation around z, y, x axes Parameters: Name Type Description Default alpha_rad float angle to z-axis. Defaults to 0.0. 0.0 beta_rad float angle to y-axis. Defaults to 0.0. 0.0 gamma_rad float angle to x-axis. Defaults to 0.0. 0.0 Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py @staticmethod def gen_rotation_quaternion ( alpha_rad = 0.0 , beta_rad = 0.0 , gamma_rad = 0.0 ): \"\"\"Generates quaternion for rotation around z, y, x axes Args: alpha_rad (float): angle to z-axis. Defaults to 0.0. beta_rad (float): angle to y-axis. Defaults to 0.0. gamma_rad (float): angle to x-axis. Defaults to 0.0. Returns: Quaternion: rotation quaternion \"\"\" rotate_about_x = Quaternion () rotate_about_y = Quaternion () rotate_about_z = Quaternion () forward_rotation = Quaternion () if _np . fabs ( alpha_rad ) > MAG_TOL : rotate_about_z = Quaternion . q_angle_from_axis ( alpha_rad , ( 0 , 0 , 1 )) if _np . fabs ( beta_rad ) > MAG_TOL : rotate_about_y = Quaternion . q_angle_from_axis ( beta_rad , ( 0 , 1 , 0 )) if _np . fabs ( gamma_rad ) > MAG_TOL : rotate_about_x = Quaternion . q_angle_from_axis ( gamma_rad , ( 1 , 0 , 0 )) forward_rotation = rotate_about_x * rotate_about_z * rotate_about_y return forward_rotation","title":"gen_rotation_quaternion()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.get_conjugate","text":"Returns quaternion conjugate Returns: Type Description quaternion quaternion conjugate Source code in pymagnet/utils/_quaternion.py def get_conjugate ( self ): \"\"\"Returns quaternion conjugate Returns: quaternion: quaternion conjugate \"\"\" return Quaternion ( self . w , - self . x , - self . y , - self . z )","title":"get_conjugate()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.q_angle_from_axis","text":"Generates a rotation quaternion for an angle theta about an axis vec This is a normailsed, i.e. unit quaternion. Parameters: Name Type Description Default theta float angle of rotation required vec tuple/array axis vector required Examples: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Type Description Quaternion rotation quaternion Source code in pymagnet/utils/_quaternion.py def q_angle_from_axis ( theta , vec ): \"\"\"Generates a rotation quaternion for an angle `theta` about an axis `vec` This is a normailsed, i.e. unit quaternion. Args: theta (float): angle of rotation vec (tuple/array): axis vector Example: 90 degree rotation about the x axis: rotation_quaternion = Quaternion.q_angle_from_axis(np.pi/2, (1, 0, 0) ) Returns: Quaternion: rotation quaternion \"\"\" vec = Quaternion . _normalise_axis ( vec ) w = _np . cos ( theta / 2.0 ) vec *= _np . sin ( theta / 2.0 ) x = vec [ 0 ] y = vec [ 1 ] z = vec [ 2 ] rotation_quaternion = Quaternion ( w , x , y , z ) return rotation_quaternion","title":"q_angle_from_axis()"},{"location":"code_reference/utils/#pymagnet.utils._quaternion.Quaternion.vec_norm","text":"Normalises each x,y,z vector Parameters: Name Type Description Default x ndarray x array required y ndarray y array required z ndarray z array required Returns: Type Description array 3xN array of normalised vectors Source code in pymagnet/utils/_quaternion.py @staticmethod def vec_norm ( x , y , z ): \"\"\"Normalises each x,y,z vector Args: x (ndarray): x array y (ndarray): y array z (ndarray): z array Returns: array: 3xN array of normalised vectors \"\"\" vec = Quaternion . _prepare_vector ( x , y , z ) return _np . linalg . norm ( vec , axis = 0 ) Routines for Two Dimensional Magnet Classes","title":"vec_norm()"},{"location":"code_reference/utils/#pymagnet.utils._routines2D.FgradB_2D","text":"Calculates the magnetic field gradient force for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description Field2 Magnetic field gradient force vector Source code in pymagnet/utils/_routines2D.py def FgradB_2D ( B , x , y , chi_m , c ): \"\"\"Calculates the magnetic field gradient force for a 2D field. Args: B (Field2): Magnetic field vector x (ndarray): x coordinates y (ndarray): y coordinates Returns: Field2: Magnetic field gradient force vector \"\"\" BgB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) FB = Field2 ( _np . zeros_like ( B . n ), _np . zeros_like ( B . n )) dB = gradB_2D ( B , x , y ) BgB . n = dB . n * B . n BgB . x = dB . x * B . n BgB . y = dB . y * B . n FB . n = ( 1 / MU0 ) * chi_m * c * BgB . n FB . x = ( 1 / MU0 ) * chi_m * c * BgB . x FB . y = ( 1 / MU0 ) * chi_m * c * BgB . y return FB","title":"FgradB_2D()"},{"location":"code_reference/utils/#pymagnet.utils._routines2D.get_field_2D","text":"Calculates magnetic field at an array of points due to every instantated Magnet2D magnet. Parameters: Name Type Description Default Point_Array2 Point_Array2 array of x,y points and associated unit, defaults to 'mm' required Returns: Type Description Field2 array of Bx,By,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines2D.py def get_field_2D ( Point_Array2 ): \"\"\"Calculates magnetic field at an array of points due to every instantated `Magnet2D` magnet. Args: Point_Array2 (Point_Array2): array of x,y points and associated unit, defaults to 'mm' Returns: Field2: array of Bx,By,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet2D # Empty data structure B = _allocate_field_array2 ( Point_Array2 . x , Point_Array2 . y ) for magnet in Magnet2D . instances : Bx , By = magnet . get_field ( Point_Array2 . x , Point_Array2 . y ) B . x += Bx B . y += By B . calc_norm () return B","title":"get_field_2D()"},{"location":"code_reference/utils/#pymagnet.utils._routines2D.gradB_2D","text":"Calculates the magnetic field gradient for a 2D field. Parameters: Name Type Description Default B Field2 Magnetic field vector required x ndarray x coordinates required y ndarray y coordinates required Returns: Type Description Field2 Magnetic field gradient vector Source code in pymagnet/utils/_routines2D.py def gradB_2D ( B , x , y ): \"\"\"Calculates the magnetic field gradient for a 2D field. Args: B (Field2): Magnetic field vector x (ndarray): x coordinates y (ndarray): y coordinates Returns: Field2: Magnetic field gradient vector \"\"\" dB = Field2 ( _np . zeros_like ( B ), _np . zeros_like ( B )) Nx = x . shape [ 0 ] Ny = x . shape [ 1 ] dx = ( x . max () - x . min ()) / Nx dy = ( y . max () - y . min ()) / Ny dB . x , dB . y = _np . gradient ( B , dx , dy ) dB . calc_norm () return dB","title":"gradB_2D()"},{"location":"code_reference/utils/#pymagnet.utils._routines2D.grid2D","text":"Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (str): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines2D.py def grid2D ( xmax , ymax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax unit (str): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j x , y = _np . mgrid [ xmin : xmax : NPJ , ymin : ymax : NPJ ] return Point_Array2 ( x , y , unit = unit )","title":"grid2D()"},{"location":"code_reference/utils/#pymagnet.utils._routines2D.rotate_points_2D","text":"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Parameters: Name Type Description Default x ndarray array of x coordinates required y ndarray array of x coordinates required alpha float rotation angle w.r.t. x-axis required Returns: Type Description tuple (x', y') rotated array of points Source code in pymagnet/utils/_routines2D.py def rotate_points_2D ( x , y , alpha ): \"\"\"Counter-clockwise rotation of points x,y Rotates 2D coordinates using a rotation matrix Args: x (ndarray): array of x coordinates y (ndarray): array of x coordinates alpha (float): rotation angle w.r.t. x-axis Returns: tuple: (x', y') rotated array of points \"\"\" x = _np . atleast_1d ( x ) y = _np . atleast_1d ( y ) if len ( x ) != len ( y ): raise Exception ( \"Must have same number of points in x and y\" ) rot_matrix = _np . array ( [[ _np . cos ( alpha ), - _np . sin ( alpha )], [ _np . sin ( alpha ), _np . cos ( alpha )]] ) stacked_points = _np . column_stack (( _np . ravel ( x ), _np . ravel ( y ))) rotated_points = _np . dot ( rot_matrix , stacked_points . T ) x_rotated = rotated_points [ 0 , :] y_rotated = rotated_points [ 1 , :] return _np . reshape ( x_rotated , x . shape ), _np . reshape ( y_rotated , y . shape ) Routines for Three Dimensional Magnet Classes","title":"rotate_points_2D()"},{"location":"code_reference/utils/#pymagnet.utils._routines3D.get_field_3D","text":"Calculates magnetic field at an array of points due to every instantated Magnet3D magnet. Parameters: Name Type Description Default Point_Array3 Point_Array3 array of x,y,z points and associated unit, defaults to 'mm' required Returns: Type Description Field3 array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') Source code in pymagnet/utils/_routines3D.py def get_field_3D ( points ): \"\"\"Calculates magnetic field at an array of points due to every instantated `Magnet3D` magnet. Args: Point_Array3 (Point_Array3): array of x,y,z points and associated unit, defaults to 'mm' Returns: Field3: array of Bx,By,Bz,|B| values and associated unit (defaults to 'T') \"\"\" from ..magnets import Magnet3D B = _allocate_field_array3 ( points . x , points . y , points . z ) for magnet in Magnet3D . instances : Bx , By , Bz = magnet . get_field ( points . x , points . y , points . z ) B . x += Bx . reshape ( B . x . shape ) B . y += By . reshape ( B . y . shape ) B . z += Bz . reshape ( B . z . shape ) B . calc_norm () return B","title":"get_field_3D()"},{"location":"code_reference/utils/#pymagnet.utils._routines3D.grid3D","text":"Generates grid of x and y points Parameters: Name Type Description Default xmax float maximum x value required ymax float maximum y value required zmax float maximum y value required Kwargs num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax zmin (float): minimum y value. Defaults to -zmax unit (string): unit length. Defaults to 'mm' Returns: Type Description Point_Array2 array of x and y values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def grid3D ( xmax , ymax , zmax , ** kwargs ): \"\"\"Generates grid of x and y points Args: xmax (float): maximum x value ymax (float): maximum y value zmax (float): maximum y value Kwargs: num_points (int): Number of points in each direction. Defaults to 100 xmin (float): minimum x value. Defaults to -xmax ymin (float): minimum y value. Defaults to -ymax zmin (float): minimum y value. Defaults to -zmax unit (string): unit length. Defaults to 'mm' Returns: Point_Array2: array of x and y values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , None ) xmin = kwargs . pop ( \"xmin\" , - 1 * xmax ) ymin = kwargs . pop ( \"ymin\" , - 1 * ymax ) zmin = kwargs . pop ( \"zmin\" , - 1 * zmax ) unit = kwargs . pop ( \"unit\" , \"mm\" ) NPJ = num_points * 1 j if num_points is None : num_points_x = kwargs . pop ( \"num_points_x\" , 100 ) num_points_y = kwargs . pop ( \"num_points_y\" , 100 ) num_points_z = kwargs . pop ( \"num_points_z\" , 100 ) else : num_points_x = num_points num_points_y = num_points num_points_z = num_points x , y , z = _np . mgrid [ xmin : xmax : num_points_x * 1 j , ymin : ymax : num_points_y * 1 j , zmin : zmax : num_points_z * 1 j , ] return Point_Array3 ( x , y , z , unit = unit )","title":"grid3D()"},{"location":"code_reference/utils/#pymagnet.utils._routines3D.slice3D","text":"Generates a planar slice of values Parameters: Name Type Description Default plane str plane. Defaults to \"xy\". 'xy' max1 float maximum along axis 1. Defaults to 1.0. 1.0 max2 float maximum along axis 2. Defaults to 1.0. 1.0 slice_value float constant value for third axis. Defaults to 0.0. 0.0 unit str length scale units. Defaults to \"mm\". 'mm' Kwargs num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Exceptions: Type Description Exception plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Type Description Point_Array3 array of x, y, and z values of shape (num_points, num_points) and associated unit Source code in pymagnet/utils/_routines3D.py def slice3D ( plane = \"xy\" , max1 = 1.0 , max2 = 1.0 , slice_value = 0.0 , unit = \"mm\" , ** kwargs ): \"\"\"Generates a planar slice of values Args: plane (str, optional): plane. Defaults to \"xy\". max1 (float, optional): maximum along axis 1. Defaults to 1.0. max2 (float, optional): maximum along axis 2. Defaults to 1.0. slice_value (float, optional): constant value for third axis. Defaults to 0.0. unit (str, optional): length scale units. Defaults to \"mm\". Kwargs: num_points (int): Number of points in each direction. Defaults to 100 min1 (float): minimum along axis 1. Defaults to -min1 min2 (float): minimum along axis 2. Defaults to -min2 Raises: Exception: plane type, must be one of 'xy', 'xz, 'yz', or 'custom' Returns: Point_Array3: array of x, y, and z values of shape (num_points, num_points) and associated unit \"\"\" num_points = kwargs . pop ( \"num_points\" , 100 ) min1 = kwargs . pop ( \"min1\" , - 1 * max1 ) min2 = kwargs . pop ( \"min2\" , - 1 * max2 ) NPj = num_points * 1 j if plane . lower () == \"xy\" : x , y = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] z = _np . asarray ([ slice_value ]) z = _np . tile ( z , x . shape ) elif plane . lower () == \"xz\" : x , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] y = _np . asarray ([ slice_value ]) y = _np . tile ( y , x . shape ) elif plane . lower () == \"yz\" : y , z = _np . mgrid [ min1 : max1 : NPj , min2 : max2 : NPj ] x = _np . asarray ([ slice_value ]) x = _np . tile ( x , y . shape ) elif plane . lower () == \"custom\" : x = kwargs . pop ( \"custom_x\" , _np . array ([ 0.0 ])) y = kwargs . pop ( \"custom_y\" , _np . array ([ 0.0 ])) z = kwargs . pop ( \"custom_z\" , _np . array ([ 0.0 ])) else : raise Exception ( \"plane must be one of 'xy', 'xz, 'yz', or 'custom'\" ) return Point_Array3 ( x , y , z , unit = unit ) Contains functions needed to rotate and translate a triangle to lie in the xz plane and to divide it into two right angled triangles","title":"slice3D()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.align_triangle_to_y","text":"Rotates and translates a triangle in lie in the xz plane Parameters: Name Type Description Default triangle ndarray vertices of a triangle required rot_axis ndarray axis about which to rotate triangle required norm_vec ndarray normal to triangle required Returns: Type Description tuple aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_to_y ( triangle , rot_axis , norm_vec ): \"\"\"Rotates and translates a triangle in lie in the xz plane Args: triangle (ndarray): vertices of a triangle rot_axis (ndarray): axis about which to rotate triangle norm_vec (ndarray): normal to triangle Returns: tuple: aligned_triangle (ndarray, rotated triangle), first_rotation (quaternion, align to y-axis) \"\"\" y_axis = _np . array ([ 0 , 1 , 0 ]) if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( y_axis , norm_vec ): # Parallel first_rotation = Quaternion () aligned_triangle = triangle else : # Anti-parallel first_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) else : angle = - _np . arccos ( _np . dot ( y_axis , norm_vec )) first_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) aligned_triangle = rotate_points ( triangle , first_rotation ) return aligned_triangle , first_rotation","title":"align_triangle_to_y()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.align_triangle_xz","text":"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Parameters: Name Type Description Default triangle ndarray vertices of triangle required longest_side int index of the longest side of triangle required Returns: Type Description tuple second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): Source code in pymagnet/utils/_trigonometry3D.py def align_triangle_xz ( triangle , longest_side ): \"\"\"Returns quaternions needed to rotate a triangle lying in the xz plane to be aligned with its longest side along x and altitude along z Args: triangle (ndarray): vertices of triangle longest_side (int): index of the longest side of triangle Returns: tuple: second_rotation (quaternion, align to x-axis), third_rotation (quaternion, align to z-axis): \"\"\" x_axis = _np . array ([ 1 , 0 , 0 ]) y_axis = _np . array ([ 0 , 1 , 0 ]) z_axis = _np . array ([ 0 , 0 , 1 ]) # side_list = [0, 1, 2] # side_list.pop(longest_side) vec_x = return_axis_vector ( triangle , longest_side ) rot_axis = _np . cross ( x_axis , vec_x ) # Check aligment of base of triangle with x-axis if _np . linalg . norm ( rot_axis ) < ALIGN_CUTOFF : # Check if parallel or anti-parallel if check_sign ( x_axis , vec_x ): # Parallel second_rotation = Quaternion () tri_x = triangle else : # Anti-parallel second_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) tri_x = rotate_points ( triangle , second_rotation ) else : angle = - _np . arccos ( _np . dot ( x_axis , vec_x )) second_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) tri_x = rotate_points ( triangle , second_rotation ) vec_z = return_z_vector ( tri_x , longest_side ) rot_axis = _np . cross ( z_axis , vec_z ) # Check aligment of triangle altitude with z-axis if _np . all ( _np . fabs ([ rot_axis ]) < ALIGN_CUTOFF ): # Check if parallel anti-parallel if check_sign ( z_axis , vec_z ): # Parallel third_rotation = Quaternion () else : # Anti-parallel third_rotation = Quaternion . q_angle_from_axis ( PI , y_axis ) else : angle = - _np . arccos ( _np . dot ( z_axis , vec_z )) third_rotation = Quaternion . q_angle_from_axis ( angle , rot_axis ) return second_rotation , third_rotation","title":"align_triangle_xz()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.altitude","text":"Gets altitude to side a of a triangle. Parameters: Name Type Description Default a float longest side required b float triangle side required c float triangle side required Returns: Type Description float altitude to side a Source code in pymagnet/utils/_trigonometry3D.py def altitude ( a , b , c ): \"\"\"Gets altitude to side `a` of a triangle. Args: a (float): longest side b (float): triangle side c (float): triangle side Returns: float: altitude to side `a` \"\"\" s = ( a + b + c ) / 2 return 2 * _np . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c )) / a","title":"altitude()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.check_sign","text":"Returns true if the signs of all elements of two arrays are the same Parameters: Name Type Description Default vector_1 ndarray input array 2 required vector_2 ndarray input array 2 required Returns: Type Description boolean True if elements in two arrays have the same sign Source code in pymagnet/utils/_trigonometry3D.py def check_sign ( vector_1 , vector_2 ): \"\"\"Returns true if the signs of all elements of two arrays are the same Args: vector_1 (ndarray): input array 2 vector_2 (ndarray): input array 2 Returns: boolean: True if elements in two arrays have the same sign \"\"\" sign_comp_1 = _np . fabs ( vector_1 + vector_2 ) sign_comp_2 = _np . fabs ( vector_1 ) + _np . fabs ( vector_2 ) return _np . allclose ( sign_comp_1 , sign_comp_2 , atol = 1e-6 )","title":"check_sign()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.norm_plane","text":"Calculates the normal to a triangular plane Parameters: Name Type Description Default vec ndarray/list/tuple (N,1) array required Returns: Type Description ndarray normal vector (N,) Source code in pymagnet/utils/_trigonometry3D.py def norm_plane ( vec ): \"\"\"Calculates the normal to a triangular plane Args: vec (ndarray/list/tuple): (N,1) array Returns: ndarray: normal vector (N,) \"\"\" norm = _np . cross ( vec [ 1 ] - vec [ 0 ], vec [ 2 ] - vec [ 0 ]) norm = norm / _np . linalg . norm ( norm ) return norm","title":"norm_plane()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.return_axis_vector","text":"Returns vector collinear to the longest side of a triangle Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray vector corresponding to longest side Source code in pymagnet/utils/_trigonometry3D.py def return_axis_vector ( triangle , longest_side ): \"\"\"Returns vector collinear to the longest side of a triangle Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: vector corresponding to longest side \"\"\" vector_A = triangle [ 1 ] - triangle [ 0 ] vector_A = vector_A / _np . linalg . norm ( vector_A ) vector_B = triangle [ 2 ] - triangle [ 1 ] vector_B = vector_B / _np . linalg . norm ( vector_B ) vector_C = triangle [ 2 ] - triangle [ 0 ] vector_C = vector_C / _np . linalg . norm ( vector_C ) vec_dict = { 0 : vector_A , 1 : vector_B , 2 : vector_C , } vec = vec_dict [ longest_side ] return vec","title":"return_axis_vector()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.return_z_vector","text":"Returns altitude vector from longest side Parameters: Name Type Description Default triangle ndarray triangle vertices required longest_side int longest side index required Returns: Type Description ndarray altitude vector Source code in pymagnet/utils/_trigonometry3D.py def return_z_vector ( triangle , longest_side ): \"\"\"Returns altitude vector from longest side Args: triangle (ndarray): triangle vertices longest_side (int): longest side index Returns: ndarray: altitude vector \"\"\" new_vertex_dict = { 0 : [ triangle [ 2 , 0 ], triangle [ 0 , 1 ], triangle [ 0 , 2 ]], 1 : [ triangle [ 0 , 0 ], triangle [ 0 , 1 ], triangle [ 1 , 2 ]], 2 : [ triangle [ 1 , 0 ], triangle [ 2 , 1 ], triangle [ 2 , 2 ]], } new_vertex = _np . array ( new_vertex_dict [ longest_side ]) vec_z_dict = { 0 : triangle [ 2 ] - new_vertex , 1 : triangle [ 0 ] - new_vertex , 2 : triangle [ 1 ] - new_vertex , } vec_z = vec_z_dict [ longest_side ] vec_z = vec_z / _np . linalg . norm ( vec_z ) return vec_z","title":"return_z_vector()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.rotate_points","text":"Rotates a set of points Parameters: Name Type Description Default points [type] [description] required rotation_quaternion [type] [description] required Returns: Type Description [type] [description] Source code in pymagnet/utils/_trigonometry3D.py def rotate_points ( points , rotation_quaternion ): \"\"\"Rotates a set of points Args: points ([type]): [description] rotation_quaternion ([type]): [description] Returns: [type]: [description] \"\"\" x_rot , y_rot , z_rot = rotation_quaternion * points . T rotate_points = _np . vstack ([ x_rot , y_rot , z_rot ]) . T return rotate_points","title":"rotate_points()"},{"location":"code_reference/utils/#pymagnet.utils._trigonometry3D.signed_area","text":"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Parameters: Name Type Description Default triangle ndarray 3x3 array of vertices required Returns: Type Description float signed area Source code in pymagnet/utils/_trigonometry3D.py @jit def signed_area ( triangle ): \"\"\"Calculates signed area of a triangle. Area area < 0 for clockwise ordering. Assumes the triangle is in the xz plane (i.e. with the normal parallel to y). Args: triangle (ndarray): 3x3 array of vertices Returns: float: signed area \"\"\" j = 1 NP = 3 area = 0.0 for i in range ( NP ): j = j % NP area += ( triangle [ j ][ 0 ] - triangle [ i ][ 0 ]) * ( triangle [ j ][ 2 ] + triangle [ i ][ 2 ]) j += 1 # check winding order of polygon, area < 0 for clockwise ordering of points area /= 2.0 return area pymagnets.utils._vector_structs Private module consiting of vector and point array classes and their methods.","title":"signed_area()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field1","text":"1D Field vector This is used to contain one component (Bz as z), and the units ('T', 'mT', etc)","title":"Field1"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field1.__init__","text":"Init method Parameters: Name Type Description Default z ndarray Magnetic field component required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , z , unit = \"T\" ): \"\"\"Init method Args: z (ndarray): Magnetic field component unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( z ) if get_unit_value_tesla ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. T, mT, uT, nT \" )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field1.change_unit","text":"Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field2","text":"2D Field vector This is used to contain two components (x, y), and the units ('T', 'mT', etc)","title":"Field2"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field2.__init__","text":"Init method Parameters: Name Type Description Default x ndarray Magnetic field component Bx required y ndarray Magnetic field component By required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , unit = \"T\" ): \"\"\"Init method Args: x (ndarray): Magnetic field component Bx y (ndarray): Magnetic field component By unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( x , y ) self . n = _np . zeros_like ( x ) if get_unit_value_tesla ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. T, mT, uT, nT \" )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field2.calc_norm","text":"Calculates the norm of the 2D vector Source code in pymagnet/utils/_vector_structs.py def calc_norm ( self ): \"\"\"Calculates the norm of the 2D vector\"\"\" self . n = _np . linalg . norm ([ self . x , self . y ], axis = 0 )","title":"calc_norm()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field2.change_unit","text":"Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field3","text":"2D Field vector This is used to contain three components (x, y), and the units ('T', 'mT', etc)","title":"Field3"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field3.__init__","text":"Init method Parameters: Name Type Description Default x ndarray Magnetic field component Bx required y ndarray Magnetic field component By required z ndarray Magnetic field component Bz required unit str Unit of field. Defaults to \"T\". 'T' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. T, mT, uT, nT Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , z , unit = \"T\" ): \"\"\"Init method Args: x (ndarray): Magnetic field component Bx y (ndarray): Magnetic field component By z (ndarray): Magnetic field component Bz unit (str, optional): Unit of field. Defaults to \"T\". Raises: ValueError: Unit must an SI prefix, e.g. T, mT, uT, nT \"\"\" super () . __init__ ( x , y , z ) self . n = _np . zeros_like ( x ) self . unit = unit","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field3.calc_norm","text":"Calculates the norm of the 3D vector Source code in pymagnet/utils/_vector_structs.py def calc_norm ( self ): \"\"\"Calculates the norm of the 3D vector\"\"\" self . n = _np . linalg . norm ([ self . x , self . y , self . z ], axis = 0 )","title":"calc_norm()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Field3.change_unit","text":"Converts field array to a different unit. e.g from 'T' to 'mT' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_tesla. <function get_unit_value_tesla at 0x7f82bde4df70> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_tesla ): \"\"\"Converts field array to a different unit. e.g from 'T' to 'mT' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_tesla. \"\"\" super () . change_unit ( new_unit , get_unit_value )","title":"change_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array1","text":"1D point structure This is used to contain one position array (z), and the units ('mm', 'cm', etc)","title":"Point_Array1"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array1.__init__","text":"Init method Parameters: Name Type Description Default z ndarray z coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , z , unit = \"mm\" ): \"\"\"Init method Args: z (ndarray): z coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" self . z = _np . asarray ( z ) if get_unit_value_meter ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. km, m, cm, mm \" )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array1.change_unit","text":"Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Prism , Cylinder current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . depth = magnet . depth * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val","title":"change_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array1.get_unit","text":"Gets unit Returns: Type Description str unit Source code in pymagnet/utils/_vector_structs.py def get_unit ( self ): \"\"\"Gets unit Returns: str: unit \"\"\" return self . unit","title":"get_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array2","text":"2D point structure This is used to contain two position arrays (x, y), and the units ('mm', 'cm', etc)","title":"Point_Array2"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array2.__init__","text":"Init Method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , unit = \"mm\" ): \"\"\"Init Method Args: x (ndarray): x coordinates y (ndarray): y coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" self . x = _np . asarray ( x ) self . y = _np . asarray ( y ) if get_unit_value_meter ( unit ) is not None : self . unit = unit else : raise ValueError ( \"Error, not an SI prefix, e.g. km, m, cm, mm \" )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array2.change_unit","text":"Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Rectangle , Square , Circle , PolyMagnet current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Rectangle ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val elif issubclass ( magnet . __class__ , Square ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Circle ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , PolyMagnet ): magnet . polygon . vertices = ( scale_val * _np . array ( magnet . polygon . vertices ) ) . tolist ()","title":"change_unit()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array3","text":"3D point structure This is used to contain three position arrays (x, y, z), and the units ('mm', 'cm', etc)","title":"Point_Array3"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array3.__init__","text":"Init Method Parameters: Name Type Description Default x ndarray x coordinates required y ndarray y coordinates required z ndarray z coordinates required unit str Unit of length. Defaults to \"mm\". 'mm' Exceptions: Type Description ValueError Unit must an SI prefix, e.g. km, m, cm, mm Source code in pymagnet/utils/_vector_structs.py def __init__ ( self , x , y , z , unit = \"mm\" ): \"\"\"Init Method Args: x (ndarray): x coordinates y (ndarray): y coordinates z (ndarray): z coordinates unit (str, optional): Unit of length. Defaults to \"mm\". Raises: ValueError: Unit must an SI prefix, e.g. km, m, cm, mm \"\"\" super () . __init__ ( x , y , unit = unit ) self . z = _np . asarray ( z )","title":"__init__()"},{"location":"code_reference/utils/#pymagnet.utils._vector_structs.Point_Array3.change_unit","text":"Converts point array to a different unit. e.g from 'cm' to 'mm' Parameters: Name Type Description Default new_unit str unit to be converted to required get_unit_value function Function for checking unit type. Defaults to get_unit_value_meter. <function get_unit_value_meter at 0x7f82bde4dee0> Source code in pymagnet/utils/_vector_structs.py def change_unit ( self , new_unit , get_unit_value = get_unit_value_meter ): \"\"\"Converts point array to a different unit. e.g from 'cm' to 'mm' Args: new_unit (str): unit to be converted to get_unit_value (function, optional): Function for checking unit type. Defaults to get_unit_value_meter. \"\"\" from ..magnets import Magnet , Prism , Cube , Cylinder , Sphere , Mesh current_unit_val = get_unit_value ( self . get_unit ()) new_unit_val = get_unit_value ( new_unit ) scale_val = current_unit_val / new_unit_val self . x *= scale_val self . y *= scale_val self . z *= scale_val self . unit = new_unit for magnet in Magnet . instances : magnet . center = scale_val * magnet . center if issubclass ( magnet . __class__ , Prism ): magnet . a = magnet . a * scale_val magnet . b = magnet . b * scale_val magnet . c = magnet . c * scale_val magnet . width = magnet . width * scale_val magnet . height = magnet . height * scale_val magnet . depth = magnet . depth * scale_val elif issubclass ( magnet . __class__ , Cube ): magnet . a = magnet . a * scale_val magnet . width = magnet . width * scale_val elif issubclass ( magnet . __class__ , Cylinder ): magnet . radius = magnet . radius * scale_val magnet . length = magnet . length * scale_val elif issubclass ( magnet . __class__ , Sphere ): magnet . radius = magnet . radius * scale_val elif issubclass ( magnet . __class__ , Mesh ): magnet . mesh_vectors = magnet . mesh_vectors * scale_val Global Constants PI, PI/2, PI/4, \u00b50, and three internally used constants: FP_CUTOFF = 1e-8, ALIGN_CUTOFF = 1e-5, MAG_TOL = 1e-4","title":"change_unit()"},{"location":"magnets/composite_magnets/","text":"Composite Magnets Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. 2D Polygons Line Elements The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is 1 \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\] Composite Polygons An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet. 3D Polyhedra For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements 3 : \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{4\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r_2 + b - z }{ r_3 - z}\\right) + \\frac{b}{c} \\ln \\left( \\frac{r - s }{ r_2 + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{4\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{r_3 + a}\\right) + \\frac{a}{c} \\ln \\left( \\frac{ r_2 + t}{r - s } \\right) \\right] \\end{align} \\] where \\(c = \\sqrt{a^2 + b^2}\\) \\(r = \\sqrt{x^2 + y^2 + z^2}\\) \\(r_2 = \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 }\\) \\(r_3 = \\sqrt{(a-x)^2 + y^2 + z^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{x-a + z + r_3}{y}\\right)\\right. - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha D} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\delta^2} + \\delta \\right)}{D} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left( \\frac{C + (A+B)\\left( \\sqrt{1 + \\eta^2} + \\eta \\right)}{D} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{\\alpha^2}, \\, \\gamma = \\sqrt{\\frac{r^2}{\\alpha^2} - \\beta^2}\\) \\(\\delta = \\frac{\\alpha + \\beta}{\\gamma}, \\, \\eta = \\frac{\\beta}{\\gamma}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\alpha,\\, C = z + \\beta\\frac{b}{a}, \\, D = \\sqrt{B^2 - A^2 - C^2}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 J. Hilton, Computational Modelling of Novel Permanent Magnetic Designs, Ph.D. thesis, Trinity College (Dublin, Ireland), School of Physics, (2005). \u21a9","title":"Composite Magnets"},{"location":"magnets/composite_magnets/#composite-magnets","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor.","title":"Composite Magnets"},{"location":"magnets/composite_magnets/#2d-polygons","text":"","title":"2D Polygons"},{"location":"magnets/composite_magnets/#line-elements","text":"The magnetic field due to an infinitely long, thin magnetic sheet of height \\(2h\\) with a surface current density \\(\\mathbf{K} = K_0 \\mathbf{\\hat{z}}\\) is 1 \\[ B_x = \\frac{\\mu_0 K_0}{4\\pi} \\ln \\left( \\frac{x^2 + (y-h)^2}{x^2 + (y+h)^2} \\right) \\] and \\[ B_y = \\frac{\\mu_0 K_0}{2\\pi} \\tan^{-1} \\left( \\frac{2hx}{x^2 + y^2 - h^2} \\right) \\]","title":"Line Elements"},{"location":"magnets/composite_magnets/#composite-polygons","text":"An object consisting of two vertical sheets, one at \\(-w\\) with \\(\\mathbf{K} = -K_0 \\mathbf{\\hat{z}}\\) , and one at \\(+w\\) with with \\(\\mathbf{K} = K_0\\mathbf{\\hat{z}}\\) will produce the same field as a rectangular magnetic of width \\(2w\\) , height \\(2h\\) , and remnant magnetisation \\(\\mathbf{J_r} = J_y \\mathbf{\\hat{y}}\\) , The surface current \\(\\mu_0 \\mathbf{K}\\) \\[ \\mu_0 \\mathbf{K} = \\mathbf{J} \\times \\mathbf{\\hat{n}} = \\left( J_x n_y - J_y n_x \\right)\\mathbf{\\hat{z}} \\] where \\(\\mathbf{\\hat{n}} = n_x \\mathbf{\\hat{x}} + n_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the unit normal vector to the magnetic sheet, and \\(\\mathbf{J} = J_x \\mathbf{\\hat{x}} + J_y \\mathbf{\\hat{y}} + 0 \\mathbf{\\hat{z}}\\) is the remnant magnetisation vector of the composite polygonal magnet.","title":"Composite Polygons"},{"location":"magnets/composite_magnets/#3d-polyhedra","text":"For polyhedra composed of right angled triangles, the magnetic field can be calculated as the sum of magnetic fields due to these elements 3 : \\[ \\sigma_m = \\mathbf{M} \\cdot \\mathbf{\\hat{n}} \\] \\[ \\begin{align} H_x &= \\frac{\\sigma_m}{4\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r_2 + b - z }{ r_3 - z}\\right) + \\frac{b}{c} \\ln \\left( \\frac{r - s }{ r_2 + t } \\right) \\right] \\end{align} \\] and similarly \\[ \\begin{align} H_z &= \\frac{\\sigma_m}{4\\pi\\mu_0} \\left[ \\ln \\left( \\frac{ r - x }{r_3 + a}\\right) + \\frac{a}{c} \\ln \\left( \\frac{ r_2 + t}{r - s } \\right) \\right] \\end{align} \\] where \\(c = \\sqrt{a^2 + b^2}\\) \\(r = \\sqrt{x^2 + y^2 + z^2}\\) \\(r_2 = \\sqrt{ (a - x)^2 + y^2 + (b - z)^2 }\\) \\(r_3 = \\sqrt{(a-x)^2 + y^2 + z^2}\\) \\(s = \\frac{ax + bz}{c },\\, t = \\frac{a (a-x) + b(b-z)}{c}\\) \\[ \\begin{align} H_y = \\frac{\\sigma_m}{2\\pi\\mu_0} &\\left[ \\tan^{-1}\\left(\\frac{x-a + z + r_3}{y}\\right)\\right. - \\tan^{-1} \\left(\\frac{x+z+r}{y} \\right) \\\\ & + \\frac{y}{\\alpha D} \\left\\{ \\tan^{-1} \\left(\\frac{C + (A+B)\\left( \\sqrt{1 + \\delta^2} + \\delta \\right)}{D} \\right) \\right. \\\\ &\\,\\, \\left.\\left. -\\tan^{-1} \\left( \\frac{C + (A+B)\\left( \\sqrt{1 + \\eta^2} + \\eta \\right)}{D} \\right) \\right\\} \\right] \\end{align} \\] where \\(\\alpha = \\sqrt{1 + \\frac{b^2}{a^2}}, \\, \\beta = - \\frac{x + \\frac{bz}{a}}{\\alpha^2}, \\, \\gamma = \\sqrt{\\frac{r^2}{\\alpha^2} - \\beta^2}\\) \\(\\delta = \\frac{\\alpha + \\beta}{\\gamma}, \\, \\eta = \\frac{\\beta}{\\gamma}\\) \\(A = -\\gamma \\frac{b}{a},\\, B = \\gamma\\alpha,\\, C = z + \\beta\\frac{b}{a}, \\, D = \\sqrt{B^2 - A^2 - C^2}\\) J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 J. Hilton, Computational Modelling of Novel Permanent Magnetic Designs, Ph.D. thesis, Trinity College (Dublin, Ireland), School of Physics, (2005). \u21a9","title":"3D Polyhedra"},{"location":"magnets/magnets_1d/","text":"Magnetic Field 1D Methods Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. Cylinder The magnetic field directly above the centre of a cylinder is 2 : Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\] Cuboid While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\] J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9","title":"1D Methods"},{"location":"magnets/magnets_1d/#magnetic-field-1d-methods","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor.","title":"Magnetic Field 1D Methods"},{"location":"magnets/magnets_1d/#cylinder","text":"The magnetic field directly above the centre of a cylinder is 2 : Magnetic cylinder schematic \\[ B_z = \\frac{\\mu_0 M_r}{2} \\left[ \\frac{z+L}{\\sqrt{(z+L)^2 + R^2} } - \\frac{z}{\\sqrt{z^2 + R^2}} \\right] \\]","title":"Cylinder"},{"location":"magnets/magnets_1d/#cuboid","text":"While for a cuboid, this equation is: Magnetic cuboid \\[ B_z = \\frac{\\mu_0 M_r}{2} {\\left[ \\tan^{-1}{\\left( \\frac{(z+L)\\sqrt{a^2 + b^2 + (z+L)^2} }{ab} \\right)} - \\tan^{-1}{\\left( \\frac{z\\sqrt{a^2 + b^2 + z^2} }{ab} \\right)} \\right]} \\] J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9","title":"Cuboid"},{"location":"magnets/magnets_2d/","text":"2D Magnets Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\] Rectangles 2D Magnet Rectangle The magnetic field due to rectangle magnetised in \\(y\\) is 2 : \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\] or magnetised in \\(x\\) is: TODO: \\[ B_x = \\frac{\\mu_0 M_r}{2\\pi} [] \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi}[] \\] Biaxial Rods (Circle) 2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as 2 : \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\] J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 \u21a9","title":"2D Magnets"},{"location":"magnets/magnets_2d/#2d-magnets","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. For infinitely long objects, the field problems can be approximated in 2D, where the magnet field consists of: \\[ \\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y\\mathbf{\\hat{y}} \\]","title":"2D Magnets"},{"location":"magnets/magnets_2d/#rectangles","text":"2D Magnet Rectangle The magnetic field due to rectangle magnetised in \\(y\\) is 2 : \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi} \\left[\\ln {\\left( \\frac{{\\left(x+a\\right)}^2 + {\\left(y-b\\right)}^2}{{\\left(x+a\\right)}^2 +{\\left(y+b\\right)}^2} \\right)} -\\ln{\\left( \\frac{{\\left(x-a\\right)}^2+{\\left(y-b\\right)}^2}{ {\\left(x-a\\right)}^2 + {\\left(y+b\\right)}^2} \\right)}\\right] \\] \\[ B_y = \\frac{\\mu_0 M_r}{2\\pi} \\left[{\\tan}^{-1}{\\left( \\frac{2b \\left(x+a\\right)}{y^2-b^2+{\\left(x+a\\right)}^2} \\right)} - {\\tan}^{-1}{\\left(\\frac{2b\\left(x-a\\right)}{y^2-b^2+{\\left(x-a\\right)}^2}\\right)}\\right] \\] or magnetised in \\(x\\) is: TODO: \\[ B_x = \\frac{\\mu_0 M_r}{2\\pi} [] \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi}[] \\]","title":"Rectangles"},{"location":"magnets/magnets_2d/#biaxial-rods-circle","text":"2D Magnet Circle A long bipolar rod of radius \\(a\\) can be approximated as circular source. The magnetic stray field is most conveniently written in polar coordinates, as 2 : \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{2} \\left( \\frac{a^2}{r^2}\\right) \\left[ \\cos(\\phi) \\mathbf{\\hat{r}} + \\sin(\\phi) \\mathbf{\\hat{\\phi}} \\right] \\] J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 \u21a9","title":"Biaxial Rods (Circle)"},{"location":"magnets/magnets_3d/","text":"3D Magnets Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) . Prisms/Cuboids For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis. Cylinders/Solenoids Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 . Bulirsch's complete elliptic integral See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s) Example Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 ) Spheres Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\] Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 See http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9","title":"3D Magnets"},{"location":"magnets/magnets_3d/#3d-magnets","text":"Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. The derived equations for 3D magnets were performed using the Coulombic Charge model rather than the Amperian current model of the 2D systems. More correctly they are derived in terms of the \\(H\\) field rather than \\(B\\) , but which in free space only differ by a factor \\(\\mu_0\\) , i.e. \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) . In the Kennelly convention of electromagnetic units every factor \\(\\mu_0 M_r\\) can be replaced by \\(J\\) or \\(J_r\\) .","title":"3D Magnets"},{"location":"magnets/magnets_3d/#prismscuboids","text":"For a uniformly magnetised cuboid, used in our experiments, with dimensions \\(2a \\times 2b \\times 2c\\) magnetised in the \\(x\\) -direction is 3 \\[ \\begin{align} B_x = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] \\[ B_y = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[\\frac{F_2\\left(-x,-y,-z\\right)F_2\\left(x,y,z\\right)}{F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)}\\right]} \\] \\[ B_z = \\frac{\\mu_0 M_r}{4\\pi} \\ln{\\left[ \\frac{F_2\\left(-x,-z,y\\right)F_2\\left(x,z,y\\right)}{F_2\\left(-x,z,y\\right)F_2\\left(x,-z,y\\right)} \\right]} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right) = \\tan^{-1}{\\frac{\\left(b+y\\right)\\left(c+z\\right)} {\\left(a+x\\right)\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}}} \\] \\[ F_2\\left(x,y,z\\right) = \\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c-z\\right)^2}+c-z} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-c-z} \\] For a bar magnetised in \\(z\\) , the above equations can be rewritten by a 90\u02da rotation about \\(y\\) , leading to 4 \\[ B_x = \\frac{\\mu_0 M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-x,y,-z\\right)F_2\\left(x,y,z\\right)} {F_2\\left(x,y,-z\\right)F_2\\left(-x,y,z\\right)} \\right]} \\] \\[ B_y = \\frac{\\mu_0M_r}{4\\pi}\\ln{\\left[ \\frac{F_2\\left(-y,x,-z\\right)F_2\\left(y,x,z\\right)} {F_2\\left(y,x,-z\\right)F_2\\left(-y,x,z\\right)} \\right]} \\] \\[ \\begin{align} B_z = &-\\frac{\\mu_0 M_r}{4\\pi} \\Big[ F_1\\left(-x,y,z\\right) + F_1\\left(-x,y,-z \\right) \\nonumber\\\\ & + F_1\\left(-x,-y,z \\right) + F_1\\left(-x,-y,-z\\right) + F_1\\left(x,y,z\\right) \\nonumber\\\\ & + F_1\\left(x,y,-z \\right) + F_1\\left(x,-y,z\\right) + F_1\\left(x,-y,-z\\right) \\Big] \\end{align} \\] where the functions \\(F_1\\) and \\(F_2\\) are \\[ F_1\\left(x,y,z\\right)= \\tan^{-1} \\frac{\\left(a+x\\right)\\left(b+y\\right)}{\\left(c+z\\right) \\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}} \\] \\[ F_2\\left(x,y,z\\right)=\\frac{\\sqrt{\\left(a+x\\right)^2+\\left(b-y\\right)^2+\\left(c+z\\right)^2}+b-y} {\\sqrt{\\left(a+x\\right)^2+\\left(b+y\\right)^2+\\left(c+z\\right)^2}-b-y} \\] Similar equations can be attained for a magnet magnetised in \\(y\\) by a 90\u02da rotation of the first set of equations about the \\(z\\) -axis.","title":"Prisms/Cuboids"},{"location":"magnets/magnets_3d/#cylinderssolenoids","text":"Recalling that the magnetic field due to a cylinder of length \\(2b\\) and radius \\(a\\) , with a current \\(I\\) running through \\(n\\) turns of wire along the symmetry axis is: \\[ B_z = \\frac{\\mu_0 n I}{2} \\left[ \\frac{z + b}{\\sqrt{ (z + b)^2 - a^2 }} - \\frac{z - b}{\\sqrt{ (z - b)^2 - a^2 }} \\right] \\] Note This is equivalent to the equation in the Cylinder section , where \\(\\mu_0 n I \\equiv \\mu_0 M_r\\) For an infinite solenoid, this reduces to \\(B_z = \\mu_0 n I\\) at its center For the general case, including off-axis points the field in cylindrical coordinates becomes \\[ B_\\rho = B_0 \\left[ \\alpha_+ C(k_+, 1, 1, -1) - \\alpha_- C(k_-, 1, 1, -1) \\right] \\] and \\[ B_z = \\frac{B_0 a}{a + \\rho} \\left[ \\beta_+ C(k_+, \\gamma^2, 1, \\gamma) - \\beta_- C(k_, \\gamma^2, 1, \\gamma) \\right] \\] where: \\[ B_0 = \\frac{\\mu_0}{\\pi}n I \\,\\,\\,\\,\\, z_\\pm = z \\pm b \\] \\[ \\alpha_\\pm = \\frac{a}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\,\\,\\,\\,\\,\\, \\beta_\\pm = \\frac{z_\\pm}{\\sqrt{z^2_\\pm + (\\rho + a)^2 }} \\] \\[ \\gamma = \\frac{a - \\rho}{a + \\rho} \\,\\,\\,\\,\\,\\,\\, k_\\pm = \\sqrt{ \\frac{z^2_\\pm + (a - \\rho)^2}{z^2_\\pm + (a + \\rho)^2} } \\] and \\(C\\) is Bulirsch's 'cel' function 5 .","title":"Cylinders/Solenoids"},{"location":"magnets/magnets_3d/#bulirschs-complete-elliptic-integral","text":"See NIST Handbook of Mathematical Functions 6 \\[ C\\left(k_c, p, c,s \\right) = \\int_0 ^{\\pi/2} \\frac{ \\left( c \\cos^2 \\varphi + s \\sin^s \\varphi \\right) d\\varphi } {\\left( \\cos^2 \\varphi + p \\sin^2 \\varphi \\right) \\sqrt{ \\cos^2 \\varphi + k_c^2 \\sin^2 \\varphi } } \\] The three standard Legendre forms of the complete elliptic integrals can be written using the generalised complete elliptic integral of Bulirsch: \\(K(k) = C(k_c, 1, 1, 1)\\) \\((K) = C(k_c, 1, 1, k_c^2)\\) \\(\\Pi(n, k) = C(k_c, n+1, 1, 1)\\) A simple algorirthm for solving the elliptic integrals 6 is included as a @staticmethod in the Cylinder subclass. It is vectorised and JIT compiled as a Numpy ufunc using Numba for improved performance: Cylinder._cel(kc, p, c, s)","title":"Bulirsch's complete elliptic integral"},{"location":"magnets/magnets_3d/#example","text":"Here is an example of how to use it, for the special case of \\(k_c = 1\\) for the first complete elliptic integral, \\(K(1)\\) : \\(C\\left(1, 1, 1, 1 \\right) = \\pi/2\\) import pymagnet as pm import numpy as np cel_value = pm . magnets . Cylinder . _cel ( 1 , 1 , 1 , 1 ) np . allclose ( cel_value , np . pi / 2.0 )","title":"Example"},{"location":"magnets/magnets_3d/#spheres","text":"Outside a uniformly magnetised sphere of radius \\(a\\) , the stray field is identical to a magnetic dipole, and has a convenient representation in spherical coordinates: \\[ \\mathbf{B} = \\frac{\\mu_0 M_r}{3} \\left( \\frac{a^3}{r^3}\\right) \\left[ 2\\cos(\\theta) \\mathbf{\\hat{r}} + \\sin(\\theta) \\mathbf{\\hat{\\theta}} \\right] \\] Note SI Units with the Sommerfeld convetion are used for this discussion: \\(\\mathbf{B} = \\mu_0 \\left( \\mathbf{H} + \\mathbf{M} \\right)\\) 1 However, the Kennelly Convetion is used for the creation of each magnet object in the library: \\(\\mathbf{B} = \\mu_0\\mathbf{H} + \\mathbf{J}\\) 1 In free space \\(\\mathbf{B} = \\mu_0 \\mathbf{H}\\) In magnetised bodies, the demagnetising field \\(\\mathbf{H_d} = - N \\mathbf{M}\\) , where \\(N\\) is the demagnetising factor. J. M. D. Coey, Magnetism and Magnetic Materials (Cambridge University Press, 2010). \u21a9 \u21a9 \u21a9 \u21a9 E. P. Furlani, Permanent Magnet and Electromechanical Devices (Academic Press, San Diego, 2001). \u21a9 Z. J. Yang, T. H. Johansen, H. Bratsberg, G. Helgesen, and A. T. Skjeltorp, Potential and Force between a Magnet and a Bulk Y1Ba2Cu3O7-\u03b4 Superconductor Studied by a Mechanical Pendulum, Superconductor Science and Technology 3, 591 (1990). \u21a9 J. M. Camacho and V. Sosa, Alternative Method to Calculate the Magnetic Field of Permanent Magnets with Azimuthal Symmetry, Revista Mexicana de F\u00edsica E 59, 8 (2013). \u21a9 R. Bulirsch, Numerical Calculation of Elliptic Integrals and Elliptic Functions. III, Numer. Math. 13, 305 (1969). \u21a9 See http://dlmf.nist.gov/19.2 \u21a9 \u21a9 N. Derby and S. Olbert, Cylindrical Magnets and Ideal Solenoids, American Journal of Physics 78, 229 (2010). \u21a9","title":"Spheres"},{"location":"magnets/magnets_overview/","text":"Magnets Overview 2D Magnets Additional keyword arguments for all Magnet2D magnets: phi: angle in degrees between magnetisation vector and x-axis. Defaults to 90. alpha: rotation angle in degrees. Defaults to 0. center: 2 element tuple (x,y) corresponding to centre of magnet. Defaults to (0,0). Rectangle Rectangle 2D magnet class import pymagnet as pm magnet = pm . magnets . Rectangle ( width = 10 , height = 30 , Jr = 1.0 ) print ( magnet ) Jr: remnant magnetisation in T. Defaults to 1.0. Square Square 2D magnet class, a subclass of Rectangle import pymagnet as pm magnet = pm . magnets . Square ( width = 10 , Jr = 1.0 ) print ( magnet ) Circle Circle 2D magnet class import pymagnet as pm magnet = pm . magnets . Circle ( radius = 10 , Jr = 1.0 ) print ( magnet ) PolyMagnet PolyMagnet 2D magnet class 3D Magnets Additional keyword arguments for all Magnet2D magnets: theta: angle in degrees between magnetisation vector and z-axis. Defaults to 0. phi: angle in degrees between magnetisation vector and x-axis. Defaults to . alpha: rotation angle in degrees about z-axis. Defaults to 0. beta: rotation angle in degrees about y-axis. Defaults to 0. gamma: rotation angle in degrees about x-axis. Defaults to 0. center: 3 element tuple (x,y, z) corresponding to centre of magnet. Defaults to (0,0,0). Prism/ import pymagnet as pm magnet = pm . magnets . Prism ( width = 10 , depth = 20 , height = 30 , Jr = 1.0 ) print ( magnet ) Cube import pymagnet as pm magnet = pm . magnets . Cube ( width = 10 , Jr = 1.0 ) print ( magnet ) Cylinder Cylinder 3D magnet class Sphere Sphere 3D magnet class Mesh Mesh 3D magnet class","title":"Overview"},{"location":"magnets/magnets_overview/#magnets-overview","text":"","title":"Magnets Overview"},{"location":"magnets/magnets_overview/#2d-magnets","text":"Additional keyword arguments for all Magnet2D magnets: phi: angle in degrees between magnetisation vector and x-axis. Defaults to 90. alpha: rotation angle in degrees. Defaults to 0. center: 2 element tuple (x,y) corresponding to centre of magnet. Defaults to (0,0).","title":"2D Magnets"},{"location":"magnets/magnets_overview/#rectangle","text":"Rectangle 2D magnet class import pymagnet as pm magnet = pm . magnets . Rectangle ( width = 10 , height = 30 , Jr = 1.0 ) print ( magnet ) Jr: remnant magnetisation in T. Defaults to 1.0.","title":"Rectangle"},{"location":"magnets/magnets_overview/#square","text":"Square 2D magnet class, a subclass of Rectangle import pymagnet as pm magnet = pm . magnets . Square ( width = 10 , Jr = 1.0 ) print ( magnet )","title":"Square"},{"location":"magnets/magnets_overview/#circle","text":"Circle 2D magnet class import pymagnet as pm magnet = pm . magnets . Circle ( radius = 10 , Jr = 1.0 ) print ( magnet )","title":"Circle"},{"location":"magnets/magnets_overview/#polymagnet","text":"PolyMagnet 2D magnet class","title":"PolyMagnet"},{"location":"magnets/magnets_overview/#3d-magnets","text":"Additional keyword arguments for all Magnet2D magnets: theta: angle in degrees between magnetisation vector and z-axis. Defaults to 0. phi: angle in degrees between magnetisation vector and x-axis. Defaults to . alpha: rotation angle in degrees about z-axis. Defaults to 0. beta: rotation angle in degrees about y-axis. Defaults to 0. gamma: rotation angle in degrees about x-axis. Defaults to 0. center: 3 element tuple (x,y, z) corresponding to centre of magnet. Defaults to (0,0,0).","title":"3D Magnets"},{"location":"magnets/magnets_overview/#prism","text":"import pymagnet as pm magnet = pm . magnets . Prism ( width = 10 , depth = 20 , height = 30 , Jr = 1.0 ) print ( magnet )","title":"Prism/"},{"location":"magnets/magnets_overview/#cube","text":"import pymagnet as pm magnet = pm . magnets . Cube ( width = 10 , Jr = 1.0 ) print ( magnet )","title":"Cube"},{"location":"magnets/magnets_overview/#cylinder","text":"Cylinder 3D magnet class","title":"Cylinder"},{"location":"magnets/magnets_overview/#sphere","text":"Sphere 3D magnet class","title":"Sphere"},{"location":"magnets/magnets_overview/#mesh","text":"Mesh 3D magnet class","title":"Mesh"},{"location":"methods/methods/","text":"Methods Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calculated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot. Classes At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes. Magnet Classes The hierarcy of magnet classes is (click image for high resolution view) Quaternion Class This is a convenience class for performing rotations of points/vectors about arbitrary axes. Plot Methods Draw Magnets on Plot","title":"Class Methods"},{"location":"methods/methods/#methods","text":"Todo Complete all methods documentation The overall approach is to Instantiate a set of magnets Generate an array of points to be calculated Loop over each magnet, calcuate the field at each point and sum this to the total field. Draw the resulting data as a line, contour, slice, or volume plot.","title":"Methods"},{"location":"methods/methods/#classes","text":"At the top of the hierarchy is the Registry class which records a set of Weakref references to instances of each class, which is used for the Magnet and Polyhedron child classes.","title":"Classes"},{"location":"methods/methods/#magnet-classes","text":"The hierarcy of magnet classes is (click image for high resolution view)","title":"Magnet Classes"},{"location":"methods/methods/#quaternion-class","text":"This is a convenience class for performing rotations of points/vectors about arbitrary axes.","title":"Quaternion Class"},{"location":"methods/methods/#plot-methods","text":"","title":"Plot Methods"},{"location":"methods/methods/#draw-magnets-on-plot","text":"","title":"Draw Magnets on Plot"},{"location":"methods/transforms/","text":"Transforms Coordinate System Transforms Scalar Transforms Vector Transforms For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) . Polar to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\] Cylindrical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\] Spherical to Cartesian \\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\] Misc Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Transforms"},{"location":"methods/transforms/#transforms","text":"","title":"Transforms"},{"location":"methods/transforms/#coordinate-system-transforms","text":"","title":"Coordinate System Transforms"},{"location":"methods/transforms/#scalar-transforms","text":"","title":"Scalar Transforms"},{"location":"methods/transforms/#vector-transforms","text":"For certain magnetic sources, like a sphere or solenoid, their field equations are more conveniently written in non-cartesian coordinates. The resulting vector fields then need to be transformed back into cartesian coordinates of the form \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}} + B_z \\mathbf{\\hat{z}}\\) or \\(\\mathbf{B} = B_x \\mathbf{\\hat{x}} + B_y \\mathbf{\\hat{y}}\\) .","title":"Vector Transforms"},{"location":"methods/transforms/#polar-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\end{align} \\]","title":"Polar to Cartesian"},{"location":"methods/transforms/#cylindrical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\phi \\mathbf{\\hat{\\phi}} + B_h \\mathbf{\\hat{h}}\\) \\[ \\begin{align} B_x &= B_r \\cos \\phi - B_\\phi \\sin \\phi \\\\ B_y &= B_r \\sin \\phi + B_\\phi \\cos \\phi \\\\ B_z &= B_h \\end{align} \\] For a solenoid or cylinder \\(B_\\phi = 0\\) , thus: \\[ \\begin{align} B_x &= B_r \\cos \\phi \\\\ B_y &= B_r \\sin \\phi \\\\ B_z &= B_h \\end{align} \\]","title":"Cylindrical to Cartesian"},{"location":"methods/transforms/#spherical-to-cartesian","text":"\\(\\mathbf{B} = B_r \\mathbf{\\hat{r}} + B_\\theta \\mathbf{\\hat{\\theta}} + B_\\phi \\mathbf{\\hat{\\phi}}\\) \\[ \\begin{align} B_x &= B_r \\sin\\theta \\cos\\phi + B_\\theta \\cos\\theta\\cos\\phi - B_\\phi \\sin\\phi \\\\ B_y &= B_r \\sin\\theta\\sin\\phi + B_\\theta \\cos\\theta\\sin\\phi + B_\\phi \\cos\\phi \\\\ B_z &= B_r \\cos\\theta - B_\\theta \\sin\\theta \\end{align} \\]","title":"Spherical to Cartesian"},{"location":"methods/transforms/#misc","text":"Signed area of a polygon: \\[ A = \\frac{1}{2} \\left( \\begin{vmatrix} x_1 & x_2 \\\\ y_1 & y_2 \\\\ \\end{vmatrix} + \\begin{vmatrix} x_2 & x_3 \\\\ y_2 & y_3 \\\\ \\end{vmatrix} + \\cdots + \\begin{vmatrix} x_n & x_1 \\\\ y_n & y_1 \\\\ \\end{vmatrix} \\right) \\] For a convex polygon, if \\(A > 0\\) the vertices are listed in counter-clockwise order, and clockwise if \\(A < 0\\) .","title":"Misc"},{"location":"plots/plots_2d/","text":"2D Plotting Matplotlib Backend All main plots are produced using this method. 2D Magnetic Sources 3D Magnetic Sources Plotly Backend This feature is under development.","title":"2D Plots"},{"location":"plots/plots_2d/#2d-plotting","text":"","title":"2D Plotting"},{"location":"plots/plots_2d/#matplotlib-backend","text":"All main plots are produced using this method.","title":"Matplotlib Backend"},{"location":"plots/plots_2d/#2d-magnetic-sources","text":"","title":"2D Magnetic Sources"},{"location":"plots/plots_2d/#3d-magnetic-sources","text":"","title":"3D Magnetic Sources"},{"location":"plots/plots_2d/#plotly-backend","text":"This feature is under development.","title":"Plotly Backend"},{"location":"plots/plots_3d/","text":"3D Plotting All plots are produced using plotly. Slices Volume Plots","title":"3D Plots"},{"location":"plots/plots_3d/#3d-plotting","text":"All plots are produced using plotly.","title":"3D Plotting"},{"location":"plots/plots_3d/#slices","text":"","title":"Slices"},{"location":"plots/plots_3d/#volume-plots","text":"","title":"Volume Plots"},{"location":"plots/plots_overview/","text":"Plots Overview","title":"Overview"},{"location":"plots/plots_overview/#plots-overview","text":"","title":"Plots Overview"}]}